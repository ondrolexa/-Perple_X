      subroutine iniprp
c----------------------------------------------------------------------
c iniprp - read data files and initialization for mingee
c----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      logical first, output, vertex 

      integer iopt
      logical lopt
      double precision nopt
      common/ opts /nopt(i10),iopt(i10),lopt(i10)

      integer iemod,kmod
      logical smod,pmod
      double precision emod
      common/ cst319 /emod(k15,k10),smod(h9),pmod(k10),iemod(k10),kmod
c----------------------------------------------------------------------- 
      first = .true.
      output = .false.
      vertex = .true.
c                                 elastic modulii flag
      kmod = 0 
c                                 -------------------------------------------
c                                 open statements for units n1-n5 and n9
c                                 are in subroutine input1
      call input1 (first,output)
c                                 for meemum turn auto_refine OFF
      iopt(6) = 0 
c                                 read thermodynamic data on unit n2:
      call input2 (first)
c                                 read data for solution phases on n9:
      call input9 (first,output)
c                                 call initlp to initialize arrays 
c                                 for optimization.
      call initlp     

      end

c-----------------------------------------------------------------------

c RLIB - a library of subprograms called by VERTEX, FRENDLY, ACTCOR
c BUILD, ADIABAT, and ISOCHOR.

c Copyright (c) 1990 by James A. D. Connolly, Institute for Mineralogy
c & Petrography, Swiss Federal Insitute of Technology, CH-8092 Zurich,
c SWITZERLAND. All rights reserved.
 
c Please do not distribute this source.

c-----------------------------------------------------------------------

      character*10 function gname (id)
c-----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer id
 
      character names*8
      common/ cst8  /names(k1)

      character fname*10
      common/ csta7 /fname(h9)
c-----------------------------------------------------------------------
      if (id.lt.0) then
         gname = names(-id)
      else if (id.gt.0) then 
         gname = fname(id)
      end if 

      end 

      subroutine gexces (id,dg)
c-----------------------------------------------------------------------
c gexces evaluates the contribution to the gibbs energy of a pseudocompound
c arising from configurational entropy, excess properties, and dqf corrections
c for special cases (internal EoS's or Van Laar gexces does not return
c the excess energy, see routines fexces, gvlaar, and toop).
c-----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer id

      double precision p,t,xco2,u1,u2,tr,pr,r,ps,dg
      common/ cst5 /p,t,xco2,u1,u2,tr,pr,r,ps

      integer ixp
      double precision sxs,exces
      common/ cst304 /sxs(k13),exces(m3,k1),ixp(k1)
c-----------------------------------------------------------------------
      
      dg = exces(1,id) + t * exces(2,id) + p * exces(3,id)

      end 

      double precision function gfluid (y)
c-----------------------------------------------------------------------
c gfluid returns the fugacities computed from a binary phase described 
c by an internal EoS referenced by cfluid, the composition of the phase
c is y (the amount of component 2).
c-----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      double precision fo2, fs2, y

      double precision p,t,xco2,u1,u2,tr,pr,r,ps
      common/ cst5 /p,t,xco2,u1,u2,tr,pr,r,ps

      double precision f
      common/ cst11 /f(2)
c-----------------------------------------------------------------------
      xco2 = y

      call cfluid (fo2,fs2)

      gfluid = r*t*((1d0-y)*f(1) + y*f(2))

      end 


      subroutine fexces (id,dg)
c-----------------------------------------------------------------------
c gexces evaluates the contribution to the gibbs energy of a pseudocompound
c arising from dqf corrections, and excess properties computed from an
c internal fluid EoS
c-----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer id

      double precision dg,f,fo2,fs2

      common/ cst11 /f(2)

      double precision cp
      common/ cst12 /cp(k5,k1)

      double precision p,t,xco2,u1,u2,tr,pr,r,ps
      common/ cst5 /p,t,xco2,u1,u2,tr,pr,r,ps

      integer ixp
      double precision sxs,exces
      common/ cst304 /sxs(k13),exces(m3,k1),ixp(k1)
c-----------------------------------------------------------------------

      dg = exces(1,id) + t * exces(2,id) + p * exces(3,id)

      xco2 = cp(2,id)

      call cfluid (fo2,fs2)

      dg = dg + r*t*(cp(1,id)*f(1) + cp(2,id)*f(2))

      end 

      double precision function gzero (id)
c----------------------------------------------------------------------
c gzero computes the reference pressure free energy of a compound 
c with no transitions identified by the argument 'id'. see gcpd. 
c----------------------------------------------------------------------
      implicit none
 
      include 'perplex_parameters.h'

      integer id,j

      double precision thermo,uf,us
      common/ cst1 /thermo(k4,k10),uf(2),us(h5)

      integer jfct,jmct,jprct
      common/ cst307 /jfct,jmct,jprct

      double precision p,t,xco2,u1,u2,tr,pr,r,ps
      common/ cst5 /p,t,xco2,u1,u2,tr,pr,r,ps

      double precision mu
      common/ cst39 /mu(i6)

      double precision vnumu
      common/ cst44 /vnumu(i6,k10)
c----------------------------------------------------------------------
 
      gzero = thermo(1,id)
c                                 -sdt
     *      + t * (thermo(2,id) - thermo(4,id) * dlog(t)
     *      - t * (thermo(5,id) + thermo(7,id) * t))
     *      - (thermo(6,id) + thermo(10,id) / t) / t
     *      + thermo(8,id) * dsqrt(t) + thermo(9,id)*dlog(t)
 
      do j = 1, jmct      
c                                 -ndu   
         gzero = gzero - vnumu(j,id) * mu(j)
      end do

      end 

      subroutine gcpd (id,gval)
c-----------------------------------------------------------------------
c gcpd computes the gibbs free energy of a compound identified by
c the arguement 'id' from the thermochemical parameters stored
c in the array 'thermo' which is located in common block 'cst1'.
c the parameters are: g(pr,tr) [thermo(1,id)], s(pr,tr) [thermo
c (2,id)], v(pr,tr) [thermo(3,id)], the coefficients of the extended
c maier-kelley heat capacity equation:
 
c           cp(pr,t)=a+b*t+c/(t*t)+d*t*t+e/t**(1/2)+f/t+g/t**3
 
c [thermo(4-10,id)], and the coefficients of the volumetric 
c equations given in the program documentation (Eqs 2.1-2.3):

c        b8 = 0 =>
 
c           v(p,t) = v(pr,tr) + b2*(t-tr) + b4*(p-pr)
c                           + b6*(p-pr)**2 + b7*(t-tr)**2

c        -3d0 < b8 < 0 =>

c           v(p,t) = v(pr,tr) * exp[ b3*(t-tr) + b8*(p-pr) ]

c        b8 < -3d0 =>

c           p = 3 * k * f * (2f + 1)^(5/2) * (1 - 3/2 * f * (4 + b8))
c           f = 1/2 * ((v0/v)^(2/3) - 1)
c           v0 = v(pr,tr) + b1 * (t - tr)
c           k = -v0 / (b2 + b3 * (t - tr))

c        b8 > 0 =>

c           v(p,t) = v(pr,t) * [1 - b8*p/(b8*p+Kt)]^(1/b8)
c               Kt = b6 + b7 * t
c            alpha = b1 + b2*t + b3/t - b4/t^2 + b5/t^(1/2)      

c Ghiorso parameters:

c v(J/bar) dv/dt(J/K/bar) dv/dp(J/bar^2) dv/dp/dt(J/bar^2/K) -K'

c Perple_X parameters (1st index in array thermo):

c    3            11           12             13              18

c N.B. for some reason Ghiorso chooses a reference T = 1673 for tbe
c mechanical EoS parameters, this is hardwired as variable trv.
c---------------------------------------------------------------------
      implicit none
 
      include 'perplex_parameters.h'

      integer id,j

      double precision ialpha, vt, trv, pth, vdp, ndu, vdpbm3, gsixtr, 
     *                 gstxgi, fs2, fo2, dg, kt, gval, gmake, gkomab,
     *                 a, b, c, gstxlq
 
      double precision f
      common/ cst11 /f(2)

      integer jfct,jmct,jprct
      common/ cst307 /jfct,jmct,jprct

      double precision therdi,therlm
      common/ cst203 /therdi(m8,m9),therlm(m7,m6,k9)

      integer idis,lmda,ltyp
      common/ cst204 /ltyp(k10),lmda(k10),idis(k10)

      double precision thermo,uf,us
      common/ cst1 /thermo(k4,k10),uf(2),us(h5)    

      double precision p,t,xco2,u1,u2,tr,pr,r,ps
      common/ cst5 /p,t,xco2,u1,u2,tr,pr,r,ps

      double precision mu
      common/ cst39 /mu(i6)

      integer make
      common / cst335 /make(k10)

      integer eos
      common/ cst303 /eos(k10)

      integer ifp
      common/ cxt32 /ifp(k1)

      double precision vnumu
      common/ cst44 /vnumu(i6,k10)

      integer iopt
      logical lopt
      double precision nopt
      common/ opts /nopt(i10),iopt(i10),lopt(i10)

      save kt,trv 
      data kt,trv/0d0,1673.15d0/
c---------------------------------------------------------------------

      if (make(id).ne.0) then 
c                                 the phase is a made phase, compute 
c                                 and sum the component g's.
         gval = gmake (id)

         goto 999

      else if (eos(id).eq.5) then
c                                 sixtrude 05 JGR EoS 
         gval = gsixtr (id)
         
         return

      else if (eos(id).eq.6) then
c                                 stixrude JGI '05 Eos
         gval = gstxgi (id) 

         return
         
      else if (eos(id).eq.11) then
c                                 stixrude EPSL '09 Liquid Eos
         gval = gstxlq (id) 

         goto 999

      end if 
c                                 all other EoS's with Cp function
      gval = thermo(1,id)
c                                 -sdt
     *       + t * (thermo(2,id) - thermo(4,id) * dlog(t)
     *       - t * (thermo(5,id) + thermo(7,id) * t))
     *       - (thermo(6,id) + thermo(10,id) / t) / t
     *       + thermo(8,id) * dsqrt(t) + thermo(9,id)*dlog(t)
c                                 vdp-ndu term:
      if (eos(id).eq.8) then 
c                                 HP Tait EoS, einstein thermal pressure
          pth = thermo(11,id)*(1d0/(dexp(thermo(15,id)/t)-1d0)
     *         -thermo(19,id))
c                                 int(vdp,p=Pr..Pf)
          vdp = (thermo(16,id)*(
     *         ((1d0+(p -pth)*thermo(17,id))**thermo(18,id)
     *         -(1d0+(pr-pth)*thermo(17,id))**thermo(18,id))
     *         /thermo(20,id)-p+pr)+p-pr)*thermo(3,id)

      else if (eos(id).eq.9) then 
c                                 True tait used for melt endmembers
c                                 kt = b6 + b5*(T-Tr)
c                                 vt = v0*exp(b1*(T-Tr))
          kt = thermo(16,id) + thermo(15,id) * (t-tr)         
c                                 tait parameters, "c" is 1 - tait c
          a = thermo(19,id)/(thermo(19,id)+kt*thermo(17,id))
          b = thermo(18,id)/kt-thermo(21,id)
          c = 1d0 - (thermo(19,id)+kt*thermo(17,id))
     *             /(thermo(20,id)-kt*thermo(17,id))
c                                 int(vdp,p=Pr..Pf)
          vdp = ((((p*b+1d0)**c-(Pr*b+1d0)**c)/b/c+pr-p)*a-pr+p)*
c                                 vt
     *          thermo(3,id)*dexp(thermo(11,id)*(t-tr))
 
      else if (eos(id).eq.10) then 
c                                 ideal gas EoS
         vdp = r*t*dlog(p/pr)

      else if (thermo(18,id).eq.0d0) then 
c                                 normal polynomial:
          vdp =  p * (thermo(3,id) 
     *               + (thermo(17,id) * t + thermo(12,id)) * t
     *               + (thermo(16,id) * p + thermo(14,id)) * p)

      else if (thermo(18,id).gt.0d0) then
c                                 murnaghan EoS:
c                                 int(alpha,T=Tr..T)
         ialpha = (thermo(11,id) + thermo(12,id)*t)*t +
     *            thermo(13,id)*dlog(t) + thermo(14,id)/t + 
     *            thermo(15,id)*dsqrt(t) + thermo(23,id)

         if (lopt(8)) then 
c                                 use hollad & powell's approximate form
            vt = thermo(3,id)*(1d0 + ialpha)

         else        
c                                 v(t,pr), correct form
            vt = thermo(3,id)*dexp(ialpha)

         end if 

         if (lopt(4)) then 
c                                 compute kt using Anderson-Gruneisen parameter
c                                 and expansivity ala Helffrich & Connolly 2009.
            kt = thermo(16,id)*dexp(-thermo(21,id)*ialpha)

         else 

            kt = thermo(16,id) + thermo(17,id)*t
c                                 a ****wit has entered a ridiculous
c                                 temperature
            if (kt.lt.0d0) then 
               call warn (46,t,id,'GCPD') 
               kt = 0d0
            end if 

         end if 
c                                 Murnaghan EoS:
c                                 vdp = V(1,T)*KT**(1/K')/(K'-1)
c                                 * [(KT+K'*p)**(1-1/K') -
c                                 (KT+K'*pr)**(1-1/K')]
         vdp = vt * kt**(1d0/thermo(18,id))/thermo(22,id) 
     *            *((kt+thermo(18,id)*p)**thermo(19,id)
     *            -(kt+thermo(20,id))**thermo(19,id))

      else if (thermo(18,id).lt.-3d0) then
c                                 3rd order Birch-Murnaghan
c                                 Ghirso Eos is a special case
c                                 indicated by thermo(16,id) = K0 = 0
         if (thermo(16,id).eq.0) then 
c                                 assume ghiorso's expressions for v0 and k (KT)
c                                 vt = Volume at 1 bar, T
            vt = thermo(3,id) + thermo(11,id) * (t - trv)

            kt = -vt / (thermo(12,id) + thermo(13,id) * (t - trv) )

         else 
c                                 int(alpha,T=Tr..Tf)
            ialpha = (thermo(11,id) + thermo(12,id)*t)*t +
     *               thermo(13,id)*dlog(t) + thermo(14,id)/t + 
     *               thermo(15,id)*dsqrt(t) + thermo(23,id)
c                                 v(t,pr)
            vt = thermo(3,id)*dexp(ialpha)
         
            if (lopt(4)) then 
c                                 compute kt using Anderson-Gruneisen parameter
c                                 and expansivity ala Helffrich & Connolly 2009.
               kt = thermo(16,id)*dexp(-thermo(21,id)*ialpha)

            else 

               kt = thermo(16,id) + thermo(17,id)*t
c                                 a ****wit has entered a ridiculous
c                                 temperature
               if (kt.lt.0d0) then 
                  call warn (46,t,id,'GCPD') 
                  kt = 0d0
               end if 

            end if 

         end if 

         vdp = vdpbm3 (vt,kt,thermo(18,id))

      else 
c                                 gottschalk.
         vdp = thermo(11,id)*dexp(thermo(13,id)*t)*
     *               (1d0 - dexp(thermo(18,id)*(p - pr)))

      end if
c                                 -ndu term
      ndu = 0d0

      do j = 1, jmct      
         ndu = ndu - vnumu(j,id) * mu(j)
      end do
c                                 fluids in the saturated
c                                 or thermodynamic composition space
      if (eos(id).gt.100) then 

         if (eos(id).eq.101) then 
         
            xco2 = 0d0 
            call cfluid (fo2,fs2)
            gval = gval + r*t*f(1)
            
         else if (eos(id).eq.102) then
          
            xco2 = 1d0
            call cfluid (fo2,fs2)
            gval = gval + r*t*f(2)
            
         else if (eos(id).ge.600.and.eos(id).le.603) then
c                                 komabayashi & fei (2010) EoS for Fe
            gval = gkomab (eos(id),id,vdp)
              
         end if          

      end if

      gval = gval + vdp + ndu 
c                                 check for lambda transitions:
      if (ltyp(id).ne.0) then
 
         if (ltyp(id).lt.4) then
c                                 ubc-type transitions
            call lamubc (p,t,dg,lmda(id),ltyp(id))
            gval = gval + dg
 
         else if (ltyp(id).lt.7) then
c                                 standard transitions
            call lamhel (p,t,gval,vdp,lmda(id),ltyp(id))
 
         else if (ltyp(id).lt.10) then
c                                 supcrt q/coe lambda transition
            call lamqtz (p,t,gval,ndu,lmda(id),id)
 
         else if (ltyp(id).eq.10) then

            if (eos(id).ne.8.and.eos(id).ne.9) then 
c                                 putnis landau model as implemented in hp98 
               call lamla0 (dg,vdp,lmda(id))
               
            else
             
               call lamla1 (dg,vdp,lmda(id))
               
            end if 

            gval = gval + dg 

         else if (ltyp(id).eq.13) then
c                                 holland and powell bragg-williams model
            call lambw (dg,lmda(id))
            gval = gval + dg

         else 

            write (*,*) 'no such transition model'
            stop
 
         end if

      end if
c                                 check for temperature dependent
c                                 order/disorder:
      if (idis(id).ne.0) then
      
         call disord (dg,idis(id))
         gval = gval + dg
         
      end if
 
999   if (ifp(id).lt.0) then 
c                                 kill melt endmembers if T < T_melt
         if (t.lt.nopt(20)) gval = gval + 1d8

      end if 

      end

      subroutine zeroi (iarray,index,ivalue,n)

      implicit none

      integer n, iarray(n), index, ivalue, i

      do i = 1, index
         iarray(i) = ivalue
      end do 

      end

      subroutine xchk (xmin, xmax, xinc, tname) 

      implicit none

      double precision xmin, xmax, xinc

      character tname*10

      if (xmax.gt.1d0) then 
         call warn (21,xmax,1,tname)
         xmax = 1d0
      end if 

      if (xmin.lt.0d0) then 
         call warn (22,xmin,1,tname) 
         xmin = 0d0
      end if 

      if (xmax.lt.xmin) then
         call warn (23,xmax,1,tname)
         xmax = 1d0
         xmin = 0d0
      end if 

      if (xinc.le.0d0) then 
         call warn (23,xinc,1,tname)
         xinc = 1d0       
      end if

      end 

      logical function badz (z)
c----------------------------------------------------------------------
      implicit none

      double precision z

      if (z.gt.-1d-5.and.z.le.1.00001) then
         badz = .false.
      else 
         badz = .true.         
      end if

      end 

      subroutine assptx
c---------------------------------------------------------------------
c assptx assigns the current value of v1 and v2 to the array ptx and
c increments the ordinate counter ipt2.
c---------------------------------------------------------------------
      implicit none
 
      include 'perplex_parameters.h'

      integer ipt2
      double precision ptx 
      common/ cst32 /ptx(l5),ipt2

      double precision v,tr,pr,r,ps
      common/ cst5  /v(l2),tr,pr,r,ps

      integer ipot,jv,iv1,iv2,iv3,iv4,iv5
      common / cst24 /ipot,jv(l2),iv1,iv2,iv3,iv4,iv5

      ipt2 = ipt2 + 2

      if (ipt2.gt.l5) ipt2 = l5

      ptx(ipt2-1) = v(iv1)
      ptx(ipt2)   = v(iv2)
 
      end
 
      subroutine concrt
c---------------------------------------------------------------------
c concrt determines convergence criteria and limits for reasonable
c solutions for the routine univeq. the array delt is also used in
c the routine slope.
 
c input:  dv - array of default search increments.
c         vmax,vmin - arrays containing the maximum and minimum values
c           of the independent and dependent intensive variables.
c         iv - array indexes variables in vmax, vmin, and output arrays
c output: ulim, blim - arrays with upper and lower limits for reasonable
c           solutions (vmax,vmin+/-4*dv)
c         delt - array containing the finite difference increments
c           (vmax-vmin/10**5), delt also serves as the test value
c           for convergence.
c---------------------------------------------------------------------
      implicit none
 
      include 'perplex_parameters.h'

      integer i

      double precision ddv
 
      double precision blim, ulim, dgr
      common/ cxt62 /blim(l2),ulim(l2),dgr

      double precision vmax,vmin,dv
      common/ cst9 /vmax(l2),vmin(l2),dv(l2)
c---------------------------------------------------------------------
      do i = 1, l2
         if (dv(i).lt.0d0) call error (34,dv(i),i,'CONCRT')
         if (i.eq.3) then 
            ulim(i) = vmax(i)
            blim(i) = vmin(i)
         else if (i.eq.1.or.i.eq.2) then
            ulim(i) = vmax(i)+dv(i)
            blim(i) = vmin(i)-dv(i)
            if (blim(i).lt.0d0) blim(i) = 1d0 
         else 
            ulim(i) = vmax(i)+dv(i)
            blim(i) = vmin(i)-dv(i)
         end if 
         ddv = vmax(i)-vmin(i)
         if (ddv.lt.0d0) call error (35,ddv,i,'CONCRT')
      end do 
 
      end
 
      subroutine conver (g,s,v,a,b,c,d,e,f,gg,b1,b2,b3,b4,b5,b6,b7,b8,
     *                   b9,b10,b11,b12,b13,tr,pr,r,ieos)
c---------------------------------------------------------------------
c convert thermodynamic equation of state from a pr tr reference state
c to minimize references to to reference conditions and constants.
c---------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer ieos

      double precision g,s,v,a,b,c,d,e,f,gg,b1,b2,b3,b4,b5,b6,b7,b8,
     *                 b9,b10,b11,b12,b13,tr,pr,n,v0,k00,k0p,gamma0,q0,
     *                 etas0,g0,g0p,r,c1,c2

      double precision emodu
      common/ cst318 /emodu(k15)
      
      integer iopt
      logical lopt
      double precision nopt
      common/ opts /nopt(i10),iopt(i10),lopt(i10)
c----------------------------------------------------------------------
      if (ieos.eq.1) then 
c                                G(P,T) polynomial forms, e.g., Helgeson et al 1978 (AJS)
c                                Berman 1988 (J Pet).
         g  = g
c                                add the integral of sdt at tr,pr:
     *       + s * tr - a * tr - b * tr * tr / 2d0 + c / tr
     *       - d * tr**3 / 3d0 - 2d0 * e * dsqrt(tr)
     *       - f * dlog(tr) + gg / tr / tr / 2d0 + f
c                                add the constant components of the
c                                integral -vdp at (t,pr):
     *       - v * pr + b2 * tr * pr + b4 * pr * pr / 2d0
c                                sign on b7 corrected June 16, 2004. PJ Gorman. 
     *       - b6 * pr**3/3d0 - b7 * tr * tr * pr
c                                S* (T)
         s  = a - b2*pr - s + a*dlog(tr) + b*tr - c/tr/tr/2d0
     *        + d * tr * tr / 2d0 - 2d0 * e / dsqrt(tr) - f/tr
     *        - gg / tr**3 / 3.d0
c                                b7 term added June 16, 2004. PJ Gorman.
     *        + b7 * 2d0 * pr * tr
c                                V* (P)
         v  = v - b2 * tr - b4 * pr  
c                                b6 term added June 16, 2004. PJ Gorman.
     *          + b6 * pr * pr
c                                sign on b7 corrected June 16, 2004. PJ Gorman.
     *          + b7 * tr * tr
c                                a*  (-T log T)
c        a  = a
c                                b*  (-T*T)
         b  = b7 * pr + b / 2d0
c                                c*  (-1/T)
         c  = c / 2d0
c                                d*  (-T**3)
         d  = d / 6d0
c                                e*  (sqrt T)
         e  = 4d0 * e
c                                f*  (log T)
c        f  = f
c                                gg* (-1/T**2)
         gg = gg/6d0
c                                b2* (PT)
         b2 = b2
c                                b7 term added June 16, 2004. PJ Gorman.
     *          - 2d0 * b7 * tr 
c                                b3* ((P-Pr) exp (T / c1))
c        b3 = b3
c                                b4* (P**2)
         b4 = b4/2d0
c                                b6 term added June 16, 2004. PJ Gorman.
     *          - b6 * pr 
c                                b5* (exp (P/ c2))
c        b5 = c2 * b5
c                                b6* (P**3)
         b6 = b6/3d0
c                                b7* (P*T**2)
c        b7 = b7

         return

      else if (ieos.eq.5.or.ieos.eq.6) then 
c                              Mie-Gruneisen Solid Models:
         if (ieos.eq.5) then
c                              stixrude & bukowinski JGR '93 +
c                              stixrude & lithgow-bertelloni 2005a (JGR)
            n = s

         else
c                              stixrude & lithgow-bertelloni GJI '05
            n = -s

         end if 

         v0     = -v 
         k00    = a
         k0p    = b
         gamma0 = d
         q0     = e
         etas0  = f
         g0     =  emodu(1)
         g0p    =  emodu(2)            
c                                 nr9
         b1 = 9d0*n*r
c                                 c1
         b2 = 9d0*k00*v0
c                                 c2
         b3 = k0p/2d0-2d0
c                                 c3
         b4 = 3d0*b2*b3
c                                 aii
         b5 = 6d0*gamma0
c                                 aiikk
         b6 = -12d0*gamma0 + 36d0*gamma0**2 - 18d0*q0*gamma0
c                                 as 
         b7 = -(gamma0 + etas0)
c                                 aiikk2 
         b8 = b6/2d0
c                                 aii2   
         b9 = b5/2d0
c                                 nr9t0  
         b10 = b1*tr
         b11 = (3d0*k00*g0p-5d0*g0)
         b12 = ((6d0*g0p-24d0+4.5d0*k0p)*k00-14d0*g0)

         return
         
      else if (ieos.eq.11) then 
c                                Mie-Gruneisen Stixrude liquid Model:
c                                G0 = F0 
c                                S0 = S0 => S0 - Cv  
c                                V0 = V0   
c                                a  = Cv  
c                                b  = K0 => 4.5d0*K0*V0  
c                                c  = K0' => 4.5d0*K0*V0*(K'-4)    
c                                d  = y0 => y0 - y'   
c                                e  = y'    
c                                f  = T0
c                                --- dependent ---
c                                gg = (S0-Cv-Cv*y0)*T0
c                                b1 = Cv*(y0+ln(T0))-S0+Cv
c                                b2 = ln(v0)
         
         gg = (s - a - a*d)*f
         b1 = a*(d+dlog(f)) - s + a
         b2 = dlog(v)

         s = s - a
         b = 4.5d0*b*v
         c = b*(c-4d0)
         d = d - e

         return
c                                remaining standard forms have caloric polynomial
      else if (ieos.lt.103) then
c                                G(Pr,T) polynomial 
         g  = g
     *       + s * tr - a * tr - b * tr * tr / 2d0 + c / tr
     *       - d * tr**3 / 3d0 - 2d0 * e * dsqrt(tr)
     *       - f * dlog(tr) + gg / tr / tr / 2d0 + f
         s  = a - s + a * dlog(tr) + b * tr - c / tr / tr /2d0
     *        + d * tr * tr / 2d0 - 2d0 * e / dsqrt(tr) - f / tr
     *        - gg / tr**3 / 3d0
         b  = b / 2d0
         c  = c / 2d0
         d  = d / 6d0
         e  = 4d0 * e
         gg = gg/6d0
c                                 fluid special case, this is sloppy
         if (ieos.gt.100.and.ieos.lt.103) return

      end if 

      if (ieos.eq.3) then 
c                                 for Ghiorso et al.'s PMELTS formulation
c                                 b6 (K0) is 0 and alpha is a constant to an
c                                 arbitrary reference, therefore parameters are left as is.
      else if (ieos.eq.7) then 
c                                 exponential polynomial on volume, e.g., Haas et al 1986,
c                                 Gottschalk 1997. b3 = alpha, -b8 = beta: 
         b1 = -v / b8 / dexp (b3*tr)

      else if (ieos.eq.8.or.ieos.eq.9) then 
c                                 The HP Tait EoS:
         if (ieos.eq.8) then 
c                                 HP 2010 Full Tait EoS
c                                 on input b1=alpha0, b5=theta, b6=k0, b7=k", b8=k'
c                                 thermal pressure cofficients:
c                                 alpha0/k0/xi0*theta -> b1
            b1 = 1d0/b5*b1*b6*tr**2/dexp(b5/tr)*(dexp(b5/tr)-1d0)**2
            b9 = 1d0/(dexp(b5/tr)-1d0)
c                                 Tait a parameter -> b6
            c1 = (1d0+b8)/(1d0+b8+b6*b7)
c                                 Tait b parameter -> b7
            c2 = b8/b6 - b7/(1d0+b8)
c                                 Tait c parameter -> b8 = 1-c
            b8 = 1d0 - (1d0+b8+b6*b7)/(b8**2+b8-b6*b7)
            b7 = c2
            b6 = c1
            b10 = b7*b8

         else 
c                                 True tait used for melt endmembers
c                                 kt = b6 + b5*(T-Tr)
c                                 vt = v0*exp(b1*(T-Tr))
            b9 = 1d0 + b8
            b10 = b8*b9
            b11 = b7/b9
c                                 tait parameters computed as f(T)
         end if 

      else if (ieos.eq.10) then 
c                                 ideal gas, could make a reference pressure correction here. 
      else 
c                                 All remaining forms (ieos = 2, 4, >100) assume:
c                                 1) alpha = b1 + b2*T + b3/T + b4/T^2 + b5/sqrt(T)
c                                    which is reformulated here to 
c                                    int(alpha,T=Tr..Tf) = b13 + b1*T + b2*T^2 + b3*ln(T) + b4/T + b5*sqrt(T)
         b2 = b2/2d0 
         b4 = -b4 
         b5 = 2d0*b5
         b13 = -(b1*tr + b2*tr*tr + b3*dlog(tr) + b4/tr + b5*dsqrt(tr))
c                                 2) if lopt(4) not true, then the isothermal bulk modulus is
c                                    K = b6 + b7*(T-Tr)
c                                    which is reformulated to 
c                                    K = b6 + b7*T
         if (.not.lopt(4)) b6 = b6 - b7*tr
c                                 operation solving constants for the Murnaghan (ieos=2), these are not
c                                 used for the BM3.
         b9 = (1d0-1d0/b8) 
         b10 = b8*pr 
         b12 = b8 - 1d0 
c                                 anderson-gruneisen parameter is assumed = K' (abs(b8)) except for
c                                 special EoS forms           
         if (ieos.gt.100) then 
            b11 = -s
         else 
c                                 special EoS, anderson-gruneisen stored in 
c                                 s-position. 
            b11 = dabs(b8) 
         end if 

      end if 

      end
 
      subroutine chkphi (ichk,name,good)
c-----------------------------------------------------------------------
c ichk = 0 and 2 -> test for saturated entities
c ichk = 1 and 3 -> test for non-saturated entities
c ichk > 1 -> do not compare against excluded list (for make definitions). 
c-----------------------------------------------------------------------
      implicit none
 
      include 'perplex_parameters.h'
 
      character*8 name
 
      integer ichk,i,j

      logical good
 
      integer icomp,istct,iphct,icp
      common/ cst6 /icomp,istct,iphct,icp

      integer ic
      common/ cst42 /ic(k0)

      integer jfct,jmct,jprct
      common/ cst307 /jfct,jmct,jprct

      integer ids,isct,icp1,isat,io2
      common/ cst40 /ids(h5,h6),isct(h5),icp1,isat,io2

      integer ifct,idfl
      common/ cst208 /ifct,idfl

      integer ixct,iexyn,ifact
      common/ cst37 /ixct,iexyn,ifact 

      character*8 exname,afname
      common/ cst36 /exname(h8),afname(2)

      integer idh2o,idco2,ikind,icmpn,icout,ieos
      double precision comp,tot
      common/ cst43 /comp(k0),tot,icout(k0),idh2o,idco2,
     *               ikind,icmpn,ieos
c-----------------------------------------------------------------------
      good = .true.
c                               reject the data if excluded in input:
      if (ichk.lt.2) then 
         do i = 1, ixct
            if (name.eq.exname(i)) goto 90
         end do
      end if 
c                               reject phases which have a component
c                               not included in the input:
      do i= 1, icmpn
         if (icout(i).eq.0.and.comp(i).ne.0d0) goto 90
      end do
c                               reject phases with negative/zero compositions
      tot = 0d0

      do j = 1, icmpn
         if (comp(j).lt.0d0.and.comp(j).gt.-1d-14) then
            comp(j) = 0d0
         else if (comp(j).lt.0d0) then 
c                               use ichk to avoid multiple messages
            if (ichk.eq.1) call warn (13,tot,j,name)
            goto 90
         else 
            tot = tot + comp(j)
         end if
      end do 

      if (tot.eq.0d0) goto 90 
c                               do a check to make sure that the phase does
c                               not consist of just mobile components
      if (jmct.gt.0) then

         tot = 0d0

         do j = 1, icp + isat + ifct
            tot = tot + comp(ic(j))
         end do  

         if (tot.eq.0d0) goto 90

      end if 
c                               the following is not executed by build:
c                               if ichk ne 0 reject phases that consist entirely
c                               of saturated components: 

      if (ichk.eq.0.or.ichk.eq.2) return
c                               reject phases with null composition, in case
c                               a user puts one in by accident
      tot = 0d0
      do j = 1, icp
         tot = tot + comp(ic(j))
      end do 

      if (tot.eq.0d0) goto 90

      return

90    good = .false.
 
      end

      logical function findph (igood)
c-----------------------------------------------------------------------
c findph checks if a phase loaded by getphi consists entirely of 
c component igood, if it does it returns true. 
c-----------------------------------------------------------------------
      implicit none
 
      include 'perplex_parameters.h'
 
      integer igood, i

      integer idh2o,idco2,ikind,icmpn,icout,ieos
      double precision comp,tot
      common/ cst43 /comp(k0),tot,icout(k0),idh2o,idco2,
     *               ikind,icmpn,ieos
c-----------------------------------------------------------------------

      if (comp(igood).ne.0d0) then 
c                                 the phase has the component,
c                                 does it have others?
         do i= 1, icmpn
            if (i.ne.igood.and.comp(i).ne.0d0) then
               findph = .false.
               return
            end if  
         end do

         findph = .true.

      else 

         findph = .false.

      end if 

      end

      subroutine lambw (dg,ld)
c---------------------------------------------------------------------
c calculate the energy of an order-disorder transition using the 
c Bragg-Williams model (Holland and Powell, '96), 0-d speciation.
c    input: ld - pointer to the phase in therlm
c   output: dg - energy change of ordering
c---------------------------------------------------------------------
      implicit none
 
      include 'perplex_parameters.h'

      integer ld

      double precision dg,h,w

      double precision therdi,therlm
      common/ cst203 /therdi(m8,m9),therlm(m7,m6,k9)

      double precision p,t,xco2,u1,u2,tr,pr,r,ps
      common/ cst5 /p,t,xco2,u1,u2,tr,pr,r,ps
c----------------------------------------------------------------------
c                                 enthalpy of complete disordering
      h = therlm(1,1,ld) + therlm(2,1,ld)*p
c                                 interaction energy
      w = therlm(3,1,ld) + therlm(4,1,ld)*p
 
      call speci0 (dg,h,w,therlm(5,1,ld),therlm(6,1,ld),
     *                    therlm(7,1,ld),therlm(8,1,ld))
 
      end

      subroutine lamla0 (dg,intvdp,ld)
c---------------------------------------------------------------------
c     calculate the extra energy of a lamdba transition using  the
c     Landau model (Holland and Powell '98). 
 
c     input variables
 
c                        t = temperature in k
c                        p = pressure in bar
c                        ld = pointer to phase in therlm
c                        intvdp = the vdp integral of the phase
 
c     returned - dg - difference in free energy due to the transition
c---------------------------------------------------------------------
      implicit none
 
      include 'perplex_parameters.h'

      integer ld

      double precision dg,tc,tc0,q2,intvdp
 
      double precision therdi,therlm
      common/ cst203 /therdi(m8,m9),therlm(m7,m6,k9)

      double precision p,t,xco2,u1,u2,tr,pr,r,ps
      common/ cst5 /p,t,xco2,u1,u2,tr,pr,r,ps
c----------------------------------------------------------------------

      tc0 =  therlm(1,1,ld)
      tc = tc0 + therlm(3,1,ld)*(p-pr)

      if (t.lt.tc) then
c                                 partially disordered:
c        q2 = dsqrt((tc-t)/tc0)
c                                 the hp98 form is 
         q2 = dsqrt(1d0-t/tc)
      else 

         q2 = 0d0

      end if 
c                                 modified from TC code Aug 2010,
c                                 this differs from the HP98 text. 
c     dg = therlm(2,1,ld)*q2*(t-tc) - therlm(4,1,ld)*t + therlm(5,1,ld)
c                                 perp 6.5 version
      dg = therlm(2,1,ld)*(q2*(t-tc) + therlm(8,1,ld)*t) 
     *                               + therlm(7,1,ld)

c                                 + int(vt,p)
     *     + therlm(6,1,ld)*intvdp
 
      end

      subroutine lamla1 (dg,intvdp,ld)
c---------------------------------------------------------------------
c     calculate the extra energy of a lamdba transition using  the
c     Landau model (Holland and Powell '98) but as apparently 
c     implemented for DS6 (i.e., HP 2010) 
 
c     input variables
 
c                        t = temperature in k
c                        p = pressure in bar
c                        ld = pointer to phase in therlm
c                        intvdp = the vdp integral of the phase
 
c     returned - dg - difference in free energy due to the transition
c---------------------------------------------------------------------
      implicit none
 
      include 'perplex_parameters.h'

      integer ld

      double precision dg,tc,tc0,q2,intvdp
 
      double precision therdi,therlm
      common/ cst203 /therdi(m8,m9),therlm(m7,m6,k9)

      double precision p,t,xco2,u1,u2,tr,pr,r,ps
      common/ cst5 /p,t,xco2,u1,u2,tr,pr,r,ps
c----------------------------------------------------------------------

      tc0 =  therlm(1,1,ld)
      tc = tc0 + therlm(3,1,ld)*(p-pr)

      if (t.lt.tc) then
c                                 partially disordered:
         q2 = dsqrt((tc-t)/tc0)

      else 

         q2 = 0d0

      end if 
c                                 modified from TC code Aug 2010,
c                                 this differs from the HP98 text. 
      dg = therlm(2,1,ld)*q2*(t-tc) - therlm(4,1,ld)*t + therlm(5,1,ld)
c                                 + int(vt,p)
     *     + therlm(6,1,ld)*intvdp
 
      end

      double precision function gtrans (id,j)
c-----------------------------------------------------------------------
c gtrans computes the reference pressure free energy of a compound 
c aboves its jth transition. 
c---------------------------------------------------------------------
      implicit none
 
      include 'perplex_parameters.h'

      integer id,j
 
      double precision therdi,therlm
      common/ cst203 /therdi(m8,m9),therlm(m7,m6,k9)

      double precision p,t,xco2,u1,u2,tr,pr,r,ps
      common/ cst5 /p,t,xco2,u1,u2,tr,pr,r,ps
 
      gtrans = therlm(12,j,id)
c                                 -sdt
     *       + t * (therlm(3,j,id) - therlm(5,j,id) * dlog(t)
     *       - t * (therlm(6,j,id) + therlm(8,j,id) * t))
     *       - (therlm(7,j,id) + therlm(11,j,id) / t) / t
     *       + therlm(9,j,id) * dsqrt(t) + therlm(10,j,id)*dlog(t)

      end 
 
      subroutine lamhel (p,t,g,vdp,ld,ltype)
c---------------------------------------------------------------------
c     calculate the extra energy of a lamdba transition using model
c     of helgeson et al 1978 (AJS).
 
c     there is something seriously wrong in this routine!!!!
 
c     input variables
c                        p = pressure in bars
c                        t = temperature in k
c                        ld = pointer to phase in therlm
c                        g = initial free energy
 
c     returned - g - modified phase free energy
c---------------------------------------------------------------------
      implicit none
 
      include 'perplex_parameters.h'

      integer lct,ltype,ld,i,jtran
      double precision t,g,gtrans,vdp,trtp,p,dt,pstar
 
      double precision therlm,therdi
      common/ cst203 /therdi(m8,m9),therlm(m7,m6,k9)

      double precision v,tr,pr,r,ps
      common/ cst5  /v(l2),tr,pr,r,ps
c----------------------------------------------------------------------
      lct = ltype - 3
c                                 T<T lowest transition, ignore
c                                 possibility of < clapeyron slope
c                                 and exit:
      if (t.lt.therlm(1,1,ld)) return

      do i = 1, lct 
         if (t.lt.therlm(1,i,ld)) then 

            if (i.eq.1) then
c                                 T<T lowest transition, ignore
c                                 possibility of < clapeyron slope
c                                 and exit:
                return
             else
c                                 at the i-1 th transition:
                jtran = i - 1
                exit
             end if 
          else 
             jtran = i 
          end if 
      end do 

      g = gtrans(ld,jtran) + vdp 
c                                 add vtrans*dp terms, this is
c                                 only set up for one transition
c                                 with a non-zero clapeyron.
c                                 should write warning. 
      if (therlm(2,1,ld).eq.0d0) return

      trtp = therlm(1,1,ld) + (p-pr)/therlm(2,1,ld)
      dt = t - therlm(1,1,ld)

      if (t .gt. trtp) then
c                                 1 bar polymorph is stable at p,
c                                 p*thermo(3,id) is 0 bar standard
c                                 state pdv polymorph contribution &
c                                 therlm(4,j,ld) is Delta V of trans
c                                 contribution.
         pstar = dt*therlm(2,1,ld) + pr
 
         g = g + (p-pstar)*therlm(4,1,ld)
 
      else
c                                 the 1 bar polymorph isn't stable.
         g = g + dt * therlm(2,1,ld) * therlm(4,1,ld)
 
      end if
 
      end
 
      subroutine lamqtz (p,t,g,ndu,ld,id)
c---------------------------------------------------------------------
c     calculate the extra energy of a lamdba transition using model
c     of helgeson et al 1978 (AJS). eq. (114) (corrected for the
c     misplaced parenthesis and the sign on c sub alpha), this is
C     probably bogus for coesite note that only one transition
c     is allowed.
 
c     input variables
c                        p = pressure in bars
c                        t = temperature in k
c                        ld = pointer to phase in therlm
c                        g = initial free energy
 
c     constants
c                Tr = 298.15 K
c                Pr = 1. bar
c                S(lope) = 38.5 bar/K
c                ba = 0.066 j/bar
c                aa = 549.82 K
c                ca = -4.973d-6 j/bar/bar
c                trt = 848. K
 
c     returned - g - modified phase free energy
c---------------------------------------------------------------------
      implicit none
 
      include 'perplex_parameters.h'

      integer id,ld

      double precision p,t,ps,g,ndu,pdv
 
      double precision thermo,uf,us
      common/ cst1 /thermo(k4,k10),uf(2),us(h5)

      double precision therdi,therlm
      common/ cst203 /therdi(m8,m9),therlm(m7,m6,k9)

      double precision trt, tr, pr, s, aa, ba, ca , vb
 
      save trt, tr, pr, s, aa, ba, ca , vb
 
      data trt, tr, pr, s, aa, ba, ca, vb / 848., 298.15, 1d0,
     *                  38.5, 549.82, 0.066, -4.973d-6, 2.372 /
 
c      trtp = trt + (p-pr) / s
 
      if (t.gt.trt) then
         ps = (t-trt) * therlm(2,1,ld) + pr
      else
         ps = pr
      end if
c                                 if above the ref P transition T
c                                 do the cp integration:
      if (t.gt.trt) g = therlm(8,1,ld) + (p-ps) * thermo(3,id)
     *                - therlm(3,1,ld) * (t-trt) 
     *     + therlm(5,1,ld) * (t - trt - t * dlog(t/trt))
     *     - (therlm(7,1,ld) + therlm(6,1,ld) * t * trt * trt)
     *     * (t - trt)**2 / 2d0 / t / trt / trt
 
c                                 now add in pdv terms to
c                                 the free energy, note that
c                                 pdv term for the ref polymorph
c                                 is already in:
 
      pdv  =  vb * (ps-pr)
     *      - ca * ( (2d0 * pr * (p-ps) - (p * p - ps * ps) ) / 2d0
     *              + s * (t-tr) * (p-ps) )
     *      + s * (ba + aa*ca*s) * (t-tr)
     *                           * dlog ((aa+p/s) / (aa + ps/s))
 
      g = g + pdv + ndu
 
      end
 
      subroutine lamubc (p,t,gspk,k,ltype)
c---------------------------------------------------------------------
c     calculate the extra energy of a lamdba transition using model
c     of berman and brown (1985, contribs. miner. petro.)
 
c     input variables
c                        p = pressure in bars
c                        t = temperature in k
c                        k = pointer to phase in therlm
 
c     returned - gspk - energy because of lambda spike
 
c     modified from perkins et al 1986 (computers and geosciences).
c---------------------------------------------------------------------
      implicit none
 
      include 'perplex_parameters.h'

      integer j,ltype,k

      double precision gspk,ctrans,aspk2,bspk2,ct2,ct3,a1,b1,c1,t92,t93,
     *                 tr92,tr93,dhspk,dsspk,t9,tr,teq,tq1bar,p,tr9,
     *                 dvdtr,dvdp,dstr,abspk,t
 
      double precision therdi, therlm
      common/ cst203 /therdi(m8,m9),therlm(m7,m6,k9)
c---------------------------------------------------------------------
      gspk=0d0
 
      do j = 1, ltype
 
         tq1bar = therlm(3,j,k)
 
         if (tq1bar.eq.0d0) cycle
 
            tr    = therlm(7,j,k)
            teq   = therlm(4,j,k) * (p-1d0) + tq1bar
            ctrans = tq1bar - teq
            tr9    = tr - ctrans
 
            if (t.lt.tr9) cycle 
 
            aspk2 = therlm(1,j,k)
            bspk2 = therlm(2,j,k)
            dvdtr = therlm(5,j,k)
            dvdp  = therlm(6,j,k)
            dstr  = therlm(8,j,k) / tq1bar
            abspk = therlm(9,j,k)
 
            if (t .gt. teq) then
               t9 = teq
            else
               t9 = t
            end if
 
            ct2 = ctrans * ctrans
            ct3 = ct2 * ctrans
 
            a1 = aspk2 * ctrans + 2d0 * abspk * ct2 + bspk2 * ct3
            b1 = aspk2 + 4d0 * abspk * ctrans + 3d0 * bspk2 * ct2
            c1 = 2d0 * abspk + 3d0 * ctrans * bspk2
 
            t92 = t9 * t9
            t93 = t9 *t92
            tr92 = tr9 * tr9
            tr93 = tr92 * tr9
 
            dhspk = a1 * (t9 - tr9)
     *            + b1 * (t92 - tr92) / 2d0
     *            + c1 * (t93 - tr93) / 3d0
     *            + bspk2 * (t9*t93 - tr93*tr9) / 4d0
 
            dsspk = a1 * (dlog(t9) - dlog(tr9))
     *            + b1 * (t9 - tr9)
     *            + c1 * (t92 - tr92) / 2d0
     *            + bspk2 * (t93 - tr93) / 3d0
 
            gspk = gspk - (t9 * dsspk) + dhspk
 
            if (t.gt.teq) gspk = gspk - (dstr + dsspk ) * (t-teq)
 
            gspk = gspk + dvdtr * (p-1d0) * (t9-tr)
     *                  + dvdp * ((p*p-1d0)/2d0 - (p-1d0))
 
      end do 

      end

      subroutine disord (g,id)
c----------------------------------------------------------------------
c compute t-dependent disorder contribution, g is the
c gibbs energy of disordering, therdi(8,id) is the t of onset of
c disordering, therdi(9,id) is the t of complete disorder.
c---------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer id

      double precision g,dh,tt,ds,trr

      double precision p,t,xco2,u1,u2,tr,pr,r,ps
      common/ cst5 /p,t,xco2,u1,u2,tr,pr,r,ps

      double precision therdi,therlm
      common/ cst203 /therdi(m8,m9),therlm(m7,m6,k9)
 
      g = 0d0

      trr = therdi(8,id)
      if (t .lt. trr) return

      tt  = t
      if (t.gt.therdi(9,id)) tt = therdi(9,id)
 
      dh = therdi(1,id) * (tt - trr)
     *     + 2d0 * therdi(2,id) * (dsqrt(tt) - dsqrt(trr))
     *     - therdi(3,id) * (1d0 / tt - 1d0 / trr)
     *     + therdi(5,id) * dlog(tt/trr)
     *     + therdi(6,id) * (tt*tt - trr*trr) / 2d0
     *     + therdi(7,id) * (tt**3 - trr**3) / 3d0
 
      ds = therdi(1,id) * dlog(tt/trr)
     *     - 2d0 * therdi(2,id) * (tt**(-0.5d0) - trr**(-0.5d0))
     *     - therdi(3,id) * (1d0/tt/tt - 1d0/trr/trr) / 2d0
     *     - therdi(5,id) * (1d0/tt - 1d0 / trr)
     *     + therdi(6,id) * (tt - trr)
     *     + therdi(7,id) * (tt*tt - trr*trr) / 2d0
 
      g = dh - (t * ds)

      if (therdi(4,id).ne.0d0) g = g + dh/therdi(4,id) * (p - pr)

      end
 
      subroutine loadit (id,make)
c---------------------------------------------------------------------
c loadit loads descriptive data for phases and species (name,comp,
c and therm) into the appropriate arrays (names,comps,thermo,vf,
c and vs).  the arguement 'id' indexes the phase in the arrays.
c note that loadit also computes reference state constants which
c are dependent on the state function being used and on its
c analytical expression.
c---------------------------------------------------------------------
      implicit none
 
      include 'perplex_parameters.h'
 
      integer id,i,j,k,lct

      logical make 

      double precision z(14),smax,t0,qr2,vmax,gph
 
      character*8 names
      common/ cst8   /names(k1)

      double precision therdi, therlm
      common/ cst203 /therdi(m8,m9),therlm(m7,m6,k9)

      integer ltyp,lmda,idis
      common/ cst204 /ltyp(k10),lmda(k10),idis(k10)

      integer iff,idss,ifug,ifyn,isyn
      common/ cst10  /iff(2),idss(h5),ifug,ifyn,isyn

      double precision thermo, uf, us
      common/ cst1 /thermo(k4,k10),uf(2),us(h5)

      double precision cp
      common/ cst12 /cp(k5,k1)

      double precision cp0
      common/ cst71 /cp0(k0,k5)

      integer icomp,istct,iphct,icp
      common/ cst6 /icomp,istct,iphct,icp

      integer ipoint,imyn
      common/ cst60 /ipoint,imyn

      character*8 name
      common/ csta6 /name

      double precision emodu
      common/ cst318 /emodu(k15)

      integer ic
      common/ cst42 /ic(k0)

      double precision p,t,xco2,u1,u2,tr,pr,r,ps
      common/ cst5 /p,t,xco2,u1,u2,tr,pr,r,ps

      integer ilam,idiso,lamin,idsin
      double precision tm,td
      common/ cst202 /tm(m7,m6),td(m8),ilam,idiso,lamin,idsin

      integer idh2o,idco2,ikind,icmpn,icout,ieos
      double precision comp,tot
      common/ cst43 /comp(k0),tot,icout(k0),idh2o,idco2,
     *               ikind,icmpn,ieos

      integer ikp
      common/ cst61 /ikp(k1)

      integer iemod,kmod
      logical smod,pmod
      double precision emod
      common/ cst319 /emod(k15,k10),smod(h9),pmod(k10),iemod(k10),kmod

      integer ifp
      common/ cxt32 /ifp(k1)

      logical gflu,aflu,fluid,shear,lflu,volume,rxn
      common/ cxt20 /gflu,aflu,fluid(k5),shear,lflu,volume,rxn

      integer eos
      common/ cst303 /eos(k10)

      integer cl
      character cmpnt*5, dname*80
      common/ csta5 /cl(k0),cmpnt(k0),dname

      integer ifct,idfl
      common/ cst208 /ifct,idfl

      integer indxs(k4), ierct 
      logical amir
      double precision therm0, err0, qemm0
      common/ cst53 /therm0(k4,k10), err0(k4,k10), qemm0(4,k10), amir

      double precision delta
      common/ cst325 /delta(11)

      double precision vnumu
      common/ cst44 /vnumu(i6,k10)

      integer jfct,jmct,jprct
      common/ cst307 /jfct,jmct,jprct

      character*8 eoscmp
      common/ cst98 /eoscmp(2)

      integer iam
      common/ cst4 /iam
      
      integer iopt
      logical lopt
      double precision nopt
      common/ opts /nopt(i10),iopt(i10),lopt(i10)
c---------------------------------------------------------------------

      if (id.gt.k10) call error (1,0d0,id,'k10')

      ipoint = iphct
      
c                               load name and phase flag
      names(id) = name
c                               moduli flags, indicate availability of
c                               bulk and shear modulus
      if (ieos.eq.5.or.ieos.eq.6) then 
c                               stixrude formulations, both available
         iemod(id) = 2

      else 
c                               if ikind = 0, no explicit moduli 
c                                        = 1, just shear
c                                        = 2, shear and bulk   
         iemod(id) = ikind

      end if 

      ikp(id) = 0
      ifp(id) = 0
      idis(id) = 0
      lmda(id) = 0

      eos(id) = ieos
c                                 use ieos flag to signal melt endmembers
c                                 in ifp array, this is only used by gcpd.
      if (ieos.eq.3.or.ieos.eq.9) ifp(id) = -1

      if (lopt(7)) then
       
         if (name.eq.cmpnt(idh2o).or.name.eq.eoscmp(1)) then 
c                                 set fluid flag for gcpd, this flag
c                                 is used to indicate the endmember is
c                                 a fluid and the id of the fluid component.
            if (ifyn.ne.0) then 
c                                 no saturated phase
               eos(id) = 101

            else if (idfl.ne.2) then 
c                                 saturated phase, and it's not CO2, ergo
c                                 will be computed by ufluid.
               eos(id) = ieos 

            end if
c                                 set fluid flag, this flag is 
c                                 used only to match fluid endmembers
c                                 with fluid pseudocompounds
            ifp(id) = 1  
c                                 gflu used to indicate whether a fluid is 
c                                 in the calculation.  
            if (ifyn.eq.1) gflu = .true. 

         else if (name.eq.cmpnt(idco2).or.name.eq.eoscmp(2)) then 

            if (ifyn.ne.0) then 
c                                 no saturated phase
               eos(id) = 102

            else if (idfl.ne.1) then 
c                                 saturated phase, and it's not H2O, ergo
c                                 will be computed by ufluid.
               eos(id) = ieos 

            end if

            ifp(id) = 1 
   
            if (ifyn.eq.1) gflu = .true. 

         end if
          
      end if 
c                               load stoichiometry of components.
      do i = 1, icomp
         cp(i,id) = comp(ic(i))
      end do 
c                               compositional array for frendly
      if (iam.eq.5.and.id.le.k5) then 
         do i = 1, k0
            cp0(i,id) = comp(i)
         end do 
      end if 

      if (make) return
c                               and just mobile components
      do i = 1, jmct 
         vnumu(i,id) = comp(ic(i+jprct))
      end do 
c                               load elastic props if present
      if (iemod(id).ne.0) then 
c                               kmod initialized 0 in main.
         kmod = 1        
         do i = 1, k15
            emod(i,id) = emodu(i)
         end do

      end if 
c                               compute reference state constants,
c                               etc..
      do i = 1, k4
         thermo(i,id) = thermo(i,k10)
         therm0(i,id) = thermo(i,k10)
         err0(i,id)   = err0(i,k10)
      end do 

c                                 save the raw values of q, eta, g0, g0p
      qemm0(1,id) = thermo(8,id)
      qemm0(2,id) = thermo(9,id)
      qemm0(3,id) = emodu(1)
      qemm0(4,id) = emodu(2)
 
      call conver (thermo(1,id),thermo(2,id),thermo(3,id),thermo(4,id),
     *             thermo(5,id),thermo(6,id),thermo(7,id),thermo(8,id),
     *             thermo(9,id),thermo(10,id),thermo(11,id),
     *             thermo(12,id),thermo(13,id),thermo(14,id),
     *             thermo(15,id),thermo(16,id),thermo(17,id),
     *             thermo(18,id),thermo(19,id),thermo(20,id),
     *             thermo(21,id),thermo(22,id),thermo(23,id),
     *             tr,pr,r,eos(id))
 
      if (tr.eq.0d0) then
         thermo(1,id) = thermo(1,k10)
         thermo(2,id) = thermo(2,k10)
      end if
c                              lmda transitions:
      if (ilam.ne.0) then

         lamin = lamin + 1

         if (lamin.gt.k9) call error (1,0d0,lamin,'k9')
 
         if (ilam.eq.13) then 
c                                 holland and powell, bragg-williams model:
c                                 enthalpy change of disordering
            therlm(1,1,lamin) = tm(1,1) - pr*tm(2,1)
c                                 volume change of disordering
            therlm(2,1,lamin) = tm(2,1)
c                                 excess enthalpy
            therlm(3,1,lamin) = tm(3,1) 
c                                 excess volume
            therlm(4,1,lamin) = tm(4,1)
c                                 n
            therlm(5,1,lamin) = tm(5,1)
c                                 fac - unused?
            therlm(6,1,lamin) = tm(6,1)
c                                 n+1
            therlm(7,1,lamin) = tm(5,1) + 1d0
c                                 f 
            therlm(8,1,lamin) = tm(5,1)/(tm(5,1) + 1d0)

         else if (ilam.eq.10) then
c                                 holland and powell, landau model:
            lct = ilam - 9
            do j = 1, lct       

               smax = tm(2,j)
               t0 = tm(1,j)
               vmax = tm(3,j)

               therlm(1,j,lamin) = t0
               therlm(2,j,lamin) = smax*2d0/3d0
c                                 this makes therlm(3) dt/dp
               therlm(3,j,lamin) = vmax/smax
c                                 qr2
               qr2 = dsqrt (1d0 - tr/t0)
c                                 constant term from ht - T*st + Glandau
               therlm(4,j,lamin) = qr2*smax
               therlm(5,j,lamin) = (2d0*t0+tr)*qr2/3d0*smax
c                                 reference volume/normalized by true volume
c                                 so that int(vt,P) is vt/v0*vdp
               therlm(6,j,lamin) = vmax*qr2/thermo(3,k10)
c                                 old version
               therlm(7,j,lamin) = smax*2d0/3d0*(t0+tr/2d0)*qr2
               therlm(8,j,lamin) = -1.5*qr2

            end do 

         else if (ilam.le.3) then
c                              ubc:
            do j = 1, ilam
 
               therlm(1,j,lamin)=tm(1,j)*tm(1,j)
               therlm(2,j,lamin)=tm(2,j)*tm(2,j)
               therlm(9,j,lamin)=tm(1,j)*tm(2,j)
 
               do k = 3, 8
                  therlm(k,j,lamin)=tm(k,j)
               end do 
            end do 
 
         else if (ilam.gt.3.and.ilam.lt.8) then
c                              helgeson:
            p = pr
c                              now convert paramters:
            do k = 1, ilam - 3
c                              load into therlm:
               therlm(1,k,lamin) = tm(1,k)
               therlm(2,k,lamin) = tm(2,k)

               do j = 4, 10
                  therlm(j+1,k,lamin) = tm(j,k)
               end do 

               t = tm(1,k)
               if (k.eq.1) then
c                              set transition type to null
c                              for call to gphase
                  lmda(id) = 0
               else 
                  lmda(id) = lamin
                  ltyp(id) = 2 + k
               end if
c                              g at trt:
               call gphase (id,gph)
               therlm(12,k,lamin) = gph
c                              delta v trans:
               therlm(4,k,lamin) = 0d0
               if (tm(2,k).ne.0d0) therlm(4,k,lamin) = tm(3,k)/tm(2,k)
c                              s + st at trt:
               t = t + 1d-3
               call gphase (id,gph)
               therlm(3,k,lamin) = tm(3,k) -
     *                             (gph - therlm(12,k,lamin))/1d-3
c                              streamline the eos:
               do j = 1, 13
                  z(j) = 0d0 
               end do 

               call conver (therlm(12,k,lamin),therlm(3,k,lamin),
     *          z(1),therlm(5,k,lamin),therlm(6,k,lamin),
     *          therlm(7,k,lamin),therlm(8,k,lamin),therlm(9,k,lamin),
     *          therlm(10,k,lamin),therlm(11,k,lamin),
     *          z(2),z(3),z(4),z(5),z(6),z(7),z(8),
     *          z(9),z(10),z(11),z(12),z(13),z(14),tm(1,k),pr,r,0)
            end do 

         else 

            write (*,*) 'no such transition model'
            stop

         end if
 
         lmda(id)=lamin
         ltyp(id)=ilam
 
      end if
c                              t dependent order: load berman and brown
c                              parameters, (this should be cleaned up)
      if (idiso.ne.0) then
         idsin = idsin + 1
         idis(id) = idsin
         do j = 1, m8
            therdi(j,idsin) = td(j)
         end do 
      end if
 
      end

      subroutine univeq (i,ier)
c---------------------------------------------------------------------
c univeq computes the equilibrium condition of a univariant reaction.
c using a finite difference newton-raphson approximation. the method
c will fail when the derivative of the state function, with respect to
c the state variable v(i), goes to infinity.
c---------------------------------------------------------------------
      implicit none

      double precision vi,delv,del,u,gr,b

      integer i,j,ier
 
      include 'perplex_parameters.h'

      double precision blim, ulim, dgr
      common/ cxt62 /blim(l2),ulim(l2),dgr
 
      double precision delt,dtol,utol,ptol
      common/ cst87 /delt(l2),dtol,utol,ptol

      double precision ddv,vmax,vmin       
      common/ cst9 /vmax(l2),vmin(l2),ddv(l2)

      double precision v,tr,pr,r,ps
      common/ cst5  /v(l2),tr,pr,r,ps
 
      ier = 0
 
      vi = v(i)
      del = delt(i)
      b = blim(i)
      u = ulim(i)
c                                 phase composition special case:
      if (i.eq.3) then 
         if (vi.lt.1d1*del) then 
            del = dabs(vi)/1d1
         else if (1d0-vi.lt.1d1*del) then 
            del = dabs(1d0-vi)/1d1
         end if 
      end if 
 
      if (vi+dabs(del).gt.u.or.vi-dabs(del).lt.b) goto 30
 
      do j = 1, 100

         call grxn (gr)

         v(i) = vi + del
         call incdep (i)

         call grxn (dgr) 
         dgr = dgr - gr

         if (dgr.eq.0d0) exit
 
         delv = gr*del/dgr

         if (delv/ddv(i).gt.1d0) then 
            v(i) = vi - del
            del = del*ddv(i)/delv/2d0
            if (del/delt(i).lt.1d-6) goto 30 
            cycle
         end if 

         vi = vi - delv

         if (vi+dabs(del).gt.u.or.vi-dabs(del).lt.b) goto 30

         v(i) = vi

         call incdep (i)
c                                 used to be on the basis of utol,
c                                 but this allows uniform relative error.
         if (dabs(delv).lt.del) return

      end do 
c                                 error code 1: iv and dv must be
c                                 switched
      ier = 1
      return
c                                 error code 2: value too far out of
c                                 range, refine iv increment.
30    ier = 2
      end

      subroutine unver (g,s,v,a,b,c,d,e,f,gg,
     *                  b1,b2,b3,b4,b5,b6,b7,b8,tr,pr)
c----------------------------------------------------------------------
c convert thermodynamic equation of state from a 0-0 reference state
c to a pr-tr reference state.

c corrections made corresponding to PJ's corrections in conver, 
c June 16, 2004.
c----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      double precision v,gg,a,b,c,d,e,f,g,b1,b2,b3,b4,b5,b6,b7,b8,pr,
     *                 tr,s
c----------------------------------------------------------------------
c                               Stixrude's EoS, exit without
c                               doing anything
      if (v.lt.0d0) return

      gg = 6d0 * gg
      e  = e / 4d0
      d  = 6d0 * d
      c  = 2d0 * c

      if (b8.eq.0d0) then 
c                                normal vdp term:
         b6 = 3d0 * b6
         b4 = 2d0 * (b4 + b6 * pr)
         b2 = b2 + 2d0 * b7 * tr
         b  = 2d0 * (b - b7*pr)
         v  = v + b2 * tr + b4 * pr - b6 * pr * pr - b7 * tr * tr
         s  = -1d0 * ( s - ( a - b2 * pr  + a * dlog(tr) + b * tr
     *        - c / tr / tr /2d0
     *        + d * tr * tr / 2d0 - 2d0 * e / dsqrt(tr) - f / tr
     *        - gg / tr**3 / 3d0 + b7 * 2d0 * pr * tr ) )
         g  = g - ( s * tr - a * tr - b * tr * tr / 2d0 + c / tr
     *        - d * tr**3 / 3d0 - 2d0 * e * dsqrt(tr)
     *        - f * dlog(tr) + gg / tr / tr / 2d0 + f
     *        - v * pr + b2 * tr * pr + b4 * pr * pr / 2d0 
     *        - b6 * pr**3/3d0 - b7 * tr * tr * pr )
      else 

         b  = 2d0 * b

         s  = -1d0 * ( s - ( a + a * dlog(tr) + b * tr
     *        - c / tr / tr /2d0
     *        + d * tr * tr / 2d0 - 2d0 * e / dsqrt(tr) - f / tr
     *        - gg / tr**3 / 3d0 ) )
         g  = g - ( s * tr - a * tr - b * tr * tr / 2d0 + c / tr
     *        - d * tr**3 / 3d0 - 2d0 * e * dsqrt(tr)
     *        - f * dlog(tr) + gg / tr / tr / 2d0 + f)

         if (b8.gt.0d0.or.(b8.le.-3d0.and.b6.ne.0d0)) then 
c                                 murnaghan or bm3:
            b2 = 2d0 * b2
            b4 = -b4
            b5 = b5 / 2d0  
c                                 convert b6 back to K(Tr)
            b6 = b6 - b7*tr
 
         else if (b8.le.-3d0.and.b6.ne.0d0) then 
c                                 ghirso, do nothing.

         else 
c                                 v = f(exponential(beta))
c                                 zero b1, so users don't get confused.
            b1 = 0d0
         end if  

      end if 
 
      end
 
c-----------------------------------------------------------------------
 
c PLIB -  subroutines common to FRENDLY and VERTEX.
 
c-----------------------------------------------------------------------
 
      subroutine slope (iv1,iv2,s)
c---------------------------------------------------------------------
c slope computes the slope (div(1)/div(2)) of a univariant
c equilibria by approximating the derivatives dg/div(1) and
c dg/div(2) by finite differences.
c---------------------------------------------------------------------
      implicit none
 
      include 'perplex_parameters.h'
 
      integer iv(2),iv1,iv2,i

      double precision dg(2),gr,s,gval
 
      double precision delt,dtol,utol,ptol
      common/ cst87 /delt(l2),dtol,utol,ptol

      double precision v,tr,pr,r,ps
      common/ cst5  /v(l2),tr,pr,r,ps
 
      iv(1) = iv1
      iv(2) = iv2
      call grxn (gr)

      do i = 1, 2
         v(iv(i)) = v(iv(i)) + delt(iv(i))
         call incdep (iv(i))
         call grxn (gval)
         dg(i) = (gval-gr)/delt(iv(i))
c                                 note the possibility exists here
c                                 for the value of an intensive
c                                 parameter to excede allowed
c                                 limits.  although this is very
c                                 unlikely a limit test like the
c                                 one done in 'univeq' could be
c                                 used.
         v(iv(i)) = v(iv(i)) - delt(iv(i))
         call incdep (iv(i))
      end do 

      s = -dg(2) / dg(1)
 
      end
 
      subroutine switch (div,ivi,ivd,jer)
c---------------------------------------------------------------------
      implicit none
 
      include 'perplex_parameters.h'
 
      integer ivi,ivd,jer,iovd

      double precision div,vo,s,odiv

      double precision vmax,vmin,dv
      common/ cst9 /vmax(l2),vmin(l2),dv(l2)

      double precision v,tr,pr,r,ps
      common/ cst5  /v(l2),tr,pr,r,ps

      double precision blim, ulim, dgr
      common/ cxt62 /blim(l2),ulim(l2),dgr
c---------------------------------------------------------------------
c                                 reset intensive variables
      call reptx 
      vo = v(ivi)
c                                 determine the sign for the
c                                 ivd increment
      call slope(ivd,ivi,s)
      jer = 0
c
      if (s.eq.0d0) then
c                                 a zero slope shouldn't occur
c                                 someplace is a bug
         jer = 1
         return
      end if
c
      odiv = div
      div = dv(ivd)
      if (odiv.gt.0d0) goto 10
      if (s.gt.0d0) div = -dv(ivd)
      goto 20
10    if (s.lt.0d0) div = -dv(ivd)
c                                 estimate a new value for v(ivi)
20    v(ivi) = v(ivi)+div/s
c     call incdep (ivi) 
c                                 switch variables
      if ((v(ivi).gt.vmin(ivi)).and.(v(ivi).lt.vmax(ivi))) then
         goto 30
      else if (v(ivi).lt.blim(ivi).or.v(ivi).gt.ulim(ivi)) then 
         jer = 1
         return
      end if         
c                                 call to incdep moved from above 3/2/2011
c                                 to prevent problem with negative T in 
c                                 subinc (calculation with fugacity). 
      call incdep (ivi) 

      div = div/5d0

      if (dabs(div).lt.dv(ivd)/1d6) then
         jer = 1
         return
      end if 

      v(ivi) = vo
      call incdep (ivi) 
      goto 20

30    iovd = ivd
      ivd = ivi
      ivi = iovd

      end

      subroutine reptx
c-----------------------------------------------------------------------
c reset - resets indendent potentials to the last known stable condition 
c along a univariant curve 
c----------------------------------------------------------------------- 
      implicit none

      double precision ptx

      integer ipt2

      include 'perplex_parameters.h'
    
      common/ cst32 /ptx(l5),ipt2

      double precision v,tr,pr,r,ps
      common/ cst5  /v(l2),tr,pr,r,ps

      integer ipot,jv,iv
      common/ cst24 /ipot,jv(l2),iv(l2)

      v(iv(1)) = ptx(ipt2-1)
      v(iv(2)) = ptx(ipt2)
      call incdp0
   
      end

      subroutine toop (id,gex)
c-----------------------------------------------------------------------
c giulio, here is a dummy routine to serve as a template, be careful
c of the type conventions that i use (i.e., all reals are implicit
c double) and also not to change any of the variables in the common
c blocks. you have to keep the three common blocks cts6, cst5 and cst12
c for input, the variables that will concern you are 

c on input:
c           r - the gas constant, J/mol-K
c           t - temperature (K)
c           p - pressure (bar)
c           tr - reference t, as in the thermodynamic data file header.
c           pt - reference p, dido.
c           icp - the number of components.
c           id - a pointer to the phase composition
c           cp(i,id) - the mol fraction of the ith component in composition id.
c on output:
c           gex - the excess free energy in J (i.e., in excess of a mechanical
c                 mixture of the endmembers) per mol of components.

c N.B. the components appear in the same order that they are entered in 
c the input file and this must also be identical to the order in the 
c solution model data file. i think build will always make SIO2 the 
c first component, overriding your choice. so to be safe anywhere you
c enter components expect SIO2 to be the 1st composition, then enter 
c the remaining components in order of the cation atomic weight, e.g., 
c cp(1,id) will always be X(SIO2) in the id'th composition, cp(2,id) will
c be X(CA0) if there are no other components.
c----------------------------------------------------------------------- 
      implicit none

      include 'perplex_parameters.h'

      integer i,id
     
      double precision gex

      double precision cp
      common/ cst12 /cp(k5,k1)

      integer icomp,istct,iphct,icp
      common/ cst6 /icomp,istct,iphct,icp

      double precision p,t,xco2,u1,u2,tr,pr,r,ps
      common/ cst5 /p,t,xco2,u1,u2,tr,pr,r,ps

      gex = 0d0

      do i = 1, icp
         if (cp(i,id).ne.0d0) gex = gex + r*t*cp(i,id)*log(cp(i,id))
      end do 

      end 
         
      subroutine unlam (tm,id,lct)
c---------------------------------------------------------------------
      implicit none
 
      include 'perplex_parameters.h'

      integer ilam,id,jd,lct,i,j,k
  
      double precision tm(m7,m6),z(9),g1,gph,g0,s0

      double precision therdi, therlm
      common/ cst203 /therdi(m8,m9),therlm(m7,m6,k9)

      integer ltyp,lmda,idis
      common/ cst204 /ltyp(k10),lmda(k10),idis(k10)

      double precision p,t,xco2,u1,u2,tr,pr,r,ps
      common/ cst5 /p,t,xco2,u1,u2,tr,pr,r,ps
c-----------------------------------------------------------------------
                                 
      ilam = ltyp(id)
      jd = lmda(id)
      lct = 0 

      do i = 1, m7
         do j = 1, m6
            tm(i,j) = 0d0
         end do 
      end do 

      if (ilam.ne.0.and.(ilam.lt.4.or.ilam.gt.7)) then
   
         ilam = ltyp(id)
         jd = lmda(id)
         if (ilam.le.3) then
            lct = ilam
            do j = 1, ilam
               tm(1,j) = dsqrt (therlm(1,j,jd))
               tm(2,j) = dsqrt (therlm(2,j,jd)) 
            end do         
         else if (ilam.gt.9.and.ilam.lt.13) then
            lct = ilam - 9
            do j = 1, ilam - 9
               tm(1,j) = therlm(1,j,jd)
               tm(2,j) = therlm(2,j,jd)
               tm(3,j) = therlm(3,j,jd) *therlm(2,j,jd) 
            end do 
         end if
      end if

      if (ilam.gt.3.and.ilam.lt.7) then

         lct = ilam - 3
         p = pr
         do i = lct, 1 , -1
c                              get s transition:
c                              load into therlm:
            tm(1,i) = therlm(1,i,jd) 
            tm(2,i) = therlm(2,i,jd) 

            do j = 5, 11
               tm(j-1,i) = therlm(j,i,jd)  
            end do 
            t = tm(1,i)

            if (i.eq.1) then
c                              set transition type to null
c                              for call to gphase 
               ltyp(id) = 0
            else 
               ltyp(id) = 2 + i
            end if
c    c                         -s at trt:

            call gphase (id,g1)
            t = t + 1d-3

            call gphase (id,gph)
            tm(3,i) =  (gph - g1)/1d-3

            g0 = therlm(12,i,jd)
            s0 = therlm(3,i,jd)
            do k = 1, 9
               z(k) = 0d0
            end do 

            call unver (g0,s0,z(1),tm(4,i),tm(5,i),tm(6,i),tm(7,i),
     *                  tm(8,i),tm(9,i),tm(10,i),z(2),z(3),z(4),z(5),
     *                  z(6),z(7),z(8),z(9),tm(1,i),pr) 

            tm(3,i) = s0 + tm(3,i)
         end do 

         ltyp(id) = ilam
         lmda(id) = jd

      end if
      
      end 

      subroutine incdep (ind) 
c-----------------------------------------------------------------------
c either indep or incdp0 are called whenever any primary potential
c variables are changed to reevaluate secondary variables. this 
c cumbersome structure is necessitated by the fact that computational
c variables were mapped directly to the thermodynamic variables in 
c cst5. a more rational strategy, which is used in werami/pssect, is
c to separate the computational and thermodynamic variables.

c incdep:

c  1) if ind = iind, computes the dependent variable if P(T) or T(P)

c  ind  - is the index of the current variable. 
c  iind - is the index of the independent variable that v(idep) is a 
c         function of.
c  idep - is the index of the dependent variable.

c  2) if jmct > 0, assigns the independent chemical potentials
c-----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer ind
       
      double precision var

      double precision v,tr,pr,r,ps
      common/ cst5  /v(l2),tr,pr,r,ps

      integer iind, idep
      double precision c0,c1,c2,c3,c4,c5
      common/ cst316 /c0,c1,c2,c3,c4,c5,iind,idep

      integer jfct,jmct,jprct
      common/ cst307 /jfct,jmct,jprct
c----------------------------------------------------------------------
      if (ind.eq.iind) then 
         var = v(iind)
         v(idep) = c0 + var*(c1 + var*(c2 
     *                          + var*(c3 + var*c4))) 
c    *                           var*(c3 + var*(c4 + c5*var)))) 
      end if 

      if (jmct.gt.0) call subinc 

      end 

      subroutine incdp1 
c-----------------------------------------------------------------------
c automatically update variables if P(T) or T(P)
c-----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'
       
      double precision var

      double precision v,tr,pr,r,ps
      common/ cst5  /v(l2),tr,pr,r,ps

      integer iind, idep
      double precision c0,c1,c2,c3,c4,c5
      common/ cst316 /c0,c1,c2,c3,c4,c5,iind,idep
c----------------------------------------------------------------------
      if (iind.ne.0) then 

         var = v(iind)
         v(idep) = c0 + var*(c1 + var*(c2 
     *                          + var*(c3 + var*c4))) 
c    *                           var*(c3 + var*(c4 + c5*var)))) 
      end if 

      end

      subroutine subinc 
c-----------------------------------------------------------------------
c assigns the independent chemical potentials, called by incdep and 
c incdp0
c-----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer i
       
      double precision gref, xp

      double precision v,tr,pr,r,ps
      common/ cst5  /v(l2),tr,pr,r,ps

      integer jfct,jmct,jprct
      common/ cst307 /jfct,jmct,jprct

      integer imaf,idaf
      common/ cst33 /imaf(i6),idaf(i6)

      double precision mu
      common/ cst39 /mu(i6)
c----------------------------------------------------------------------
      do i = 1, jmct

            if (imaf(i).eq.1) then 
c                                 the primary variable is a chemical
c                                 potential.
               mu(i) = v(3+i)

            else 
c                                 the primary variable is a fugacity or
c                                 an activity.
               if (imaf(i).eq.2) then 
c                                 fugacity
                  xp = v(1)
                  v(1) = pr
                  call gcpd (idaf(i),gref)
                  v(1) = xp

               else 
c                                 activity
                  call gcpd (idaf(i),gref)

               end if 

               mu(i) = gref + r*v(2)*v(3+i)*2.302585093d0

             end if 

      end do 
c                                 this line is here to prevent an optimization 
c                                 bug with compaq visual fortran. 
      xp = xp * xp

      end 

      subroutine incdp0 
c----------------------------------------------------------------------
c incdep 1) conditionally computes the dependent variable if one exists 
c (idep ne 0), 2) assigns independent chemical potentials.

c  idep - is the index of the dependent variable 
c  iind - is the index of the independent variable that v(idep) is a 
c         function of.
c----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'
       
      double precision var 

      double precision v,tr,pr,r,ps
      common/ cst5  /v(l2),tr,pr,r,ps

      integer iind, idep
      double precision c0,c1,c2,c3,c4,c5
      common/ cst316 /c0,c1,c2,c3,c4,c5,iind,idep

      integer jfct,jmct,jprct
      common/ cst307 /jfct,jmct,jprct
c----------------------------------------------------------------------
      if (idep.ne.0) then 
         var = v(iind)
         v(idep) = c0 + var*(c1 + var*(c2 
     *                          + var*(c3 + var*c4))) 
c    *                            var*(c3 + var*(c4 + c5*var)))) 
      end if 

      if (jmct.gt.0) call subinc

      end 

      double precision function depvar (var) 
c--------------------------------------------------------------------
c depvar computes the dependent variable from the independent variable
c var
c--------------------------------------------------------------------
      implicit none

      double precision var 

      integer iind,idep
      double precision c0,c1,c2,c3,c4,c5
      common/ cst316 /c0,c1,c2,c3,c4,c5,iind,idep

      depvar = c0 + var*(c1 + var*(c2 + var*(c3 + var*c4)))

c      depvar = c0 + var*(c1 + var*(c2 + var*(c3 + var*(c4 + c5*var))))

      end 

      integer function match (idim,ier,name)
c----------------------------------------------------------------------
c find the index of endmember identified by name
c----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer idim, ier 

      character*8 name

      character mname*8
      common/ cst18a /mname(m4)

      ier = 0

      do match = 1, idim
         if (name.eq.mname(match)) exit
      end do  

      if (match.gt.idim) ier = 1
      
      end 

      subroutine readn (idim,tname)
c----------------------------------------------------------------------
c readn - read idim endmember names expected format

c  name_1 name_2 ... | comment
c  name_n+1....      | comment

c end_of_data is either a "|" or the end of the record.
c----------------------------------------------------------------------
 
      implicit none

      include 'perplex_parameters.h'

      integer ibeg, iend, len, ier, idim, ict, i

      character name*8, tname*10 

      character mname*8
      common/ cst18a /mname(m4)

      integer length,iblank,icom
      character chars*1
      common/ cst51 /length,iblank,icom,chars(240)
c----------------------------------------------------------------------
      ier = 0 

      call readcd (n9,len,ier)
      if (ier.ne.0) goto 90

      ibeg = 1
      iend = len
      ict = 0  

      do while (ict.lt.idim) 
c                                 find the name
         call readnm (ibeg,iend,len,ier,name)
         if (ier.ne.0) goto 90
         ict = ict + 1
         mname(ict) = name

         if (ibeg.ge.len.and.ict.lt.idim) then
            call readcd (n9,len,ier)
            ibeg = 1
            if (ier.ne.0) goto 90
         end if 

      end do

      return      

90    write (*,1000) tname,(chars(i),i=1,len),name
      stop
      
1000  format ('**error ver200** READN bad data, currently ',
     *        'reading solution model: ',a,' data was:',/,240a,/,
     *        'last name read was: ',a,/)

      end 


      subroutine readda (rnums,idim,tname)
c----------------------------------------------------------------------
c readda - reads idim numbers, discarding all data in records 
c          beyond the comment marker "|" or the end of the record.
c----------------------------------------------------------------------

      implicit none

      include 'perplex_parameters.h'

      integer len, idim, kdim, jdim, i, isnum, ier

      character tname*10, nums*240

      double precision rnums(100)

      integer length,iblank,icom
      character chars*1
      common/ cst51 /length,iblank,icom,chars(240)
c----------------------------------------------------------------------
c                                 read card scans for non blank data
c                                 card:
      kdim = 1
      jdim = 0
      isnum = 0 

      do while (jdim.lt.idim)

         call readcd (n9,len,ier)
         if (ier.ne.0) exit
c                                 got data, count how many "numbers"
         do i = 1, len
            if (chars(i).ne.' '.and.isnum.eq.0) then
               jdim = jdim + 1
               isnum = 1
            else if (chars(i).eq.' ') then
               isnum = 0
            end if 
         end do
c                                 if there is no comment
c                                 marker there can be more 
c                                 data than anticipated:
         if (jdim.gt.idim) jdim = idim
c                                 write numbers to string
         write (nums,*) (chars(i), i = 1, len),' '
         
         read (nums,*,iostat=ier) (rnums(i), i = kdim, jdim)
         if (ier.ne.0) exit

         kdim = jdim + 1

      end do 

      if (ier.gt.0) then 

         write (*,1000) tname, (chars(i),i = 1, len)
         write (*,1020)
         stop

      else if (ier.lt.0) then 

         write (*,1010) tname
         write (*,1020)
         stop

      end if 

1000  format ('**error ver209** READDA bad data, currently',
     *        ' reading solution model: ',/,a,/,'data was:',/,240a)
1010  format ('**error ver210** READDA read to end of file',
     *        ' reading solution model: ',/,a)
1020  format ('READDA was expecting numeric data.',/)

      end 

      subroutine readx (idim,tname)
c----------------------------------------------------------------------
c readx - read excess function for a solution model, assumes
c data on one line of less than 240 characters, the expected format

c        W(name-name-...) number number number

c end_of_data is either a "|" or the end of the record.
c----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer ibeg, jend, len, ier, iscan, lord, imax, match, idim

      character name*8, begin*5, eod*3, tname*10

      integer i,j

      integer iend,isub,imd,insp,ist,isp,isite,iterm,iord,istot,jstot,
     *        kstot
      double precision wg,xmn,xmx,xnc
      common/ cst108 /wg(m1,m3),xmn(mst,msp),xmx(mst,msp),xnc(mst,msp),
     *      iend(m4),isub(m1,m2,2),imd(msp,mst),insp(m4),ist(mst),
     *      isp(mst),isite,iterm,iord,istot,jstot,kstot

      integer length,iblank,icom
      character chars*1
      common/ cst51 /length,iblank,icom,chars(240)
c----------------------------------------------------------------------

      iterm = 0 
      iord = 0 

      call readcd (n9,len,ier)

      write (begin,'(5a)') (chars(i),i=1, 5)

      if (begin.eq.'ideal') then
         return
      else if (begin.ne.'begin') then 
         goto 90
      end if 

      do i = 1, m1
         do j = 1, m2
            isub(i,j,1) = 0 
         end do 
      end do 
 
      eod = ' '

      do while (eod.ne.'end')  

         call readcd (n9,len,ier)
         if (ier.ne.0) goto 90

         write (eod,'(3a)') (chars(i),i=1,3) 
c                                 find brackets
         ibeg = iscan (1,len,'(') + 1
         imax = iscan (1,len,')') - 1

         if (ibeg.gt.len.or.imax.gt.len) cycle
c                                 data found
         iterm = iterm + 1
         if (iterm.gt.m1) call error (48,wg(1,1),m1,tname)

         lord = 0

         do while (ibeg.lt.imax)

            jend = imax

            call readnm (ibeg,jend,imax,ier,name)
            if (ier.ne.0) goto 90

            lord = lord + 1
            if (lord.gt.m2) call error (49,wg(1,1),m2,tname)

            isub(iterm,lord,1) = match (idim,ier,name)  

            if (ier.ne.0) goto 90         

         end do 

         if (lord.gt.iord) iord = lord

         ibeg = imax + 2
         jend = len

         do i = 1, 3

            call readfr (wg(iterm,i),ibeg,jend,len,ier)
     
            if (ier.ne.0) goto 90 
    
         end do 
      end do

      return

90    write (*,1000) tname,(chars(i),i=1,len),name
      stop
      
1000  format ('**error ver200** READX bad data, currently ',
     *        'reading solution model: ',a,' data was:',/,240a,/,
     *        'last name read was: ',a,/,
     *        'usually this error is due to a mispelled ',
     *        'endmember name.',/)

      end 

      subroutine readop (idim,jlaar,kstot,tname)
c----------------------------------------------------------------------
c readop - tail of solution model to find optional dqf and
c          van laar size parameters

c readop - reads data until it finds an     "end_of_model" record

c          van laar data is identified by a "begin_van_la" record
c          dqf data is identified by a      "begin_dqf_co" record
c          or the iteration limit is        "max_iteratio" record

c readop returns:

c          jlaar = 1 if van laar data found (else 0).
c          idqf  > 0 if dqf data found (else 0)
c----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer len, ier, idim, jlaar

      character begin*12, tname*10

      integer length,iblank,icom
      character chars*1
      common/ cst51 /length,iblank,icom,chars(240)

      integer kstot,i,indq,idqf
      double precision dqf
      common/ cst222 /dqf(m3,m4),indq(m4),idqf
c----------------------------------------------------------------------

      jlaar = 0 
      idqf = 0 

      do 

         call readcd (n9,len,ier)

         write (begin,'(12a)') (chars(i),i=1,12)

         if (begin.eq.     'end_of_model') then 
            
            exit

         else if (begin.eq.'begin_model ') then
c                              found new model, current
c                              model does not of end_of_model keyword
            write (*,1000) tname,(chars(i),i=1,len)
            stop

         else if (begin.eq.'begin_van_la') then 
c                              read van laar data: 
            jlaar = 1
            call readvl (idim,kstot,tname)
            cycle 

         else if (begin.eq.'begin_dqf_co') then 
c                              read dqf data:
            call readdq (idim,tname)
            cycle

         else 

            write (*,1010) tname,(chars(i),i=1,len)
            write (*,1020)
            stop

         end if

      end do  

1000  format (/,' **error ver200** READOP missing "end_of_model"',
     *          ' keyword at end',' of solution model:',a,/)
      
1010  format (/,' **error ver210** READOP bad data, currently',
     *          ' reading solution model: ',a,' data was:',/,240a)

1020  format (/,' This error is most probably due to an out-of-date',
     *          ' solution model file.',//,
     *          ' Copy the current version from:',//,
     *          ' www.perplex.ethz.ch/perplex/datafiles/',
     *          'solution_model.dat',//)

      end 

      subroutine readvl (idim,kstot,tname)
c----------------------------------------------------------------------
c readvl - read van laar volumes for a solution models endmembers, assumes
c data on one line of less than 240 characters, the expected format

c        alpha(name) number number number

c end_of_data is either a "|" or the end of the record.
c----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer ibeg, len, ier, iscan, imax, match, idim, index

      character name*8, eod*3, tname*10

      integer length,iblank,icom
      character chars*1
      common/ cst51 /length,iblank,icom,chars(240)

      integer kstot,jend,i,ict,jsmod
      double precision vlaar
      common/ cst221 /vlaar(m3,m4),jsmod
c----------------------------------------------------------------------

      ict = 0 
 
      eod = ' '

      do while (eod.ne.'end')  

         call readcd (n9,len,ier)
         if (ier.ne.0) goto 90

         write (eod,'(3a)') (chars(i),i=1,3) 
c                                 find brackets
         ibeg = iscan (1,len,'(') + 1
         imax = iscan (1,len,')') - 1

         if (ibeg.gt.len.or.imax.gt.len) cycle
c                                 data found
         ict = ict + 1
         if (ict.gt.m4) goto 91
 
         jend = imax

         call readnm (ibeg,jend,imax,ier,name)
         if (ier.ne.0) goto 90

         index = match (idim,ier,name)  

         if (ier.ne.0) goto 90         

         ibeg = imax + 2
         jend = len

         do i = 1, m3

            call readfr (vlaar(i,index),ibeg,jend,len,ier)
     
            if (ier.ne.0) goto 90 
    
         end do 

      end do

      if (ict.lt.kstot) goto 91 

      return

90    write (*,1000) tname,(chars(i),i=1,len),vlaar(i,index)
      write (*,1001)
      stop

91    write (*,1010) tname
      stop
      
1000  format ('**error ver200** READVL bad data, currently ',
     *        'reading solution model: ',a,' data was:',/,240a,/,
     *        'last number (or real equivalent) was: ',g12.6,/)

1001  format (/,'usually this error is caused by a mispelled ',
     *          'endmember name.',/)

1010  format (' **error ver201** READVL bad data, currently',
     *        ' reading solution model: ',a,/,
     *        ' this model requires 1 size parameter for',
     *        ' each independent endmember, READVL found ',i2,
     *        ' parameters.',/)

      end 

      subroutine readdq (idim,tname)
c----------------------------------------------------------------------
c readvl - read dqf corrections for solution models endmembers, assumes
c data on one line of less than 240 characters, the expected format

c        dqf(name) number number number

c        output:

c          idqf           - the number of endmembers with dqf corrections
c          indq(idqf)     - pointer to corrected endmember in the phase name array
c          dqf(1..3,idqf) - the dqf parameters for the correction

c end_of_data is either a "|" or the end of the record.
c----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer ibeg, len, ier, iscan, imax, match, idim

      character name*8, eod*3, tname*10

      integer length,iblank,icom
      character chars*1
      common/ cst51 /length,iblank,icom,chars(240)

      integer jend,i,idqf,indq
      double precision dqf
      common/ cst222 /dqf(m3,m4),indq(m4),idqf
c----------------------------------------------------------------------

      eod = ' '

      do while (eod.ne.'end')  

         call readcd (n9,len,ier)
         if (ier.ne.0) goto 90

         write (eod,'(3a)') (chars(i),i=1,3) 
c                                 find brackets
         ibeg = iscan (1,len,'(') + 1
         imax = iscan (1,len,')') - 1

         if (ibeg.gt.len.or.imax.gt.len) cycle
c                                 data found
         idqf = idqf + 1
 
         jend = imax

         call readnm (ibeg,jend,imax,ier,name)
         if (ier.ne.0) goto 90

         indq(idqf) = match (idim,ier,name)  

         if (ier.ne.0) goto 90         

         ibeg = imax + 2
         jend = len

         do i = 1, m3

            call readfr (dqf(i,idqf),ibeg,jend,len,ier)
     
            if (ier.ne.0) goto 90 
    
         end do 

      end do

      return

90    write (*,1000) tname,(chars(i),i=1,len),dqf(i,idqf)
      write (*,1001)
      stop
      
1000  format ('**error ver200** READDQ bad data, currently',
     *        'reading solution model: ',a,' data was:',/,240a,/,
     *        'last number (or real equivalent) was: ',g12.6,/)
1001  format (/,'usually this error is caused by a mispelled ',
     *          'endmember name.',/)

      end 

      subroutine readr (coeffs,enth,inds,idim,nreact,tname)
c----------------------------------------------------------------------
c readr - read stoichiometric reaction data for a solution model, assumes
c data on one line of less than 240 characters, the expected format

c        name "=" (acoef(i), mame(i), i= 2..nreact) Enthalpy_value

c nreact >= 4 + nord for reciprocal reactions
c nreact = 3 for ordered species
c enthalpy_value is only read if on input nreact = 3

c end_of_data is either a "|" or the end of the record.
c----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer ibeg, iend, len, ier, iscan, i, nreact, inds(k7), 
     *        idim, match

      double precision coeffs(k7), enth, rnum

      character name*8, tname*10 

      character mname*8
      common/ cst18a /mname(m4)

      integer length,iblank,icom
      character chars*1
      common/ cst51 /length,iblank,icom,chars(240)
c----------------------------------------------------------------------
      ier = 0 

      call readcd (n9,len,ier)
      if (ier.ne.0) goto 90

      ibeg = 1
      iend = len
c                                 first name
      call readnm (ibeg,iend,len,ier,name)

      if (ier.ne.0) goto 90

      if (nreact.eq.3) then 
c                                 if nreact = 3, new name
         idim = idim + 1
         mname(idim) = name
         inds(1) = idim

      else 
c                                 reciprocal sol, get index
         inds(1) = match(idim,ier,name)
         if (ier.ne.0) goto 90
              
      end if 
c                                 find marker '='
      ibeg = iscan (1,len,'=') + 1

      iend = len

      i = 2

      do 
c                                 find a stoichiometric coeff
         call readfr (rnum,ibeg,iend,len,ier)

         coeffs(i) = rnum

         if (ier.ne.0) exit 
c                                 find the name
         call readnm (ibeg,iend,len,ier,name)

         if (ier.ne.0) goto 90

         if (i.gt.k7) call error (1,0d0,i,'k7')

         inds(i) = match(idim,ier,name)

         if (ier.ne.0) goto 90

         if (nreact.gt.0.and.i.eq.nreact) exit 
c                                 increment counter and find 
c                                 the next coeff+name
         i = i + 1
           
      end do

      if (nreact.eq.3.and.i.eq.3) then      
c                                 ordered compound, read
c                                 enthalpy, find marker '='
         ibeg = iscan (ibeg,len,'=') + 1

         call readfr (rnum,ibeg,iend,len,ier)

         enth = rnum

         if (ier.ne.0) goto 90

      else if (i.lt.3) then 
c                                 a reaction with only 2 species 
c                                 is unexpected, write error
         goto 90 

      else 

         nreact = i - 1

      end if 

      return      

90    write (*,1000) tname,(chars(i),i=1,len),name,rnum
      stop
      
1000  format ('**error ver200** READR bad data, currently ',
     *        'reading solution model: ',a,' data was:',/,240a,
     *        'last name read was: ',a,/,
     *        'last number (or real equivalent) was: ',g12.6,/)

      end 

      subroutine readz (coeffs,inds,ict,idim,tname,tag)
c----------------------------------------------------------------------
c readz - read site fraction data for a solution model, assumes
c data on one line of less than 240 characters, the expected format

c        comments "=" a0 (acoef(i), mame(i), i= 1...end_of_data)

c end_of_data is either a "|" or the end of the record.
c----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer ibeg, iend, len, ier, iscan, ict, inds(k7),
     *        match, idim, i, iscnlt

      double precision rnum, coeffs(k7)

      character name*8, tname*10, tag*3

      integer length,iblank,icom
      character chars*1
      common/ cst51 /length,iblank,icom,chars(240)
c----------------------------------------------------------------------
      ict = 0 

      call readcd (n9,len,ier)
      if (ier.ne.0) goto 90 
c                                 this first segment is only done for
c                                 the readlm routine:
      ibeg = 1
c                                 read the fist word
      call readnm (ibeg,iend,len,ier,name)
      read (name,'(a)') tag

      if (tag.eq.'end') then 
c                                 if called from readlm tag may be the
c                                 end of data marker
         return

      else 

         i = match(idim,ier,name)

         if (ier.eq.0) then 
c                                 the "comment" is a name for
c                                 readlm
            ict = ict + 1
            inds(ict) = i

         end if
 
      end if 
c                                 find start of data marker '='
      ibeg = iscan (iend,len,'=') + 1
      ict = ibeg
c                                 find a number
      call readfr (rnum,ibeg,iend,len,ier)
      if (ier.ne.0) goto 90 
c                                 find the next non-blank chracter
c                                 if it's text, then the expression
c                                 has no constant, else save the 
c                                 constant.
      if (chars(iscnlt(iend+1,240,'/')).lt.'A') then
c                                 assuming ascii collating sequence,
c                                 the next character is numeric, so 
c                                 the number read previously is the a0 constant
         coeffs(1) = rnum

      else 
c                                 no constant, reset character pointer.
         coeffs(1) = 0d0 
         ibeg = ict

      end if 
c                                 the rest of the data should
c                                 consist of coefficients followed
c                                 by names
      ict = 1 

      do while (ibeg.lt.len) 
c                                 find the number
         call readfr (rnum,ibeg,iend,len,ier)

         if (ier.ne.0) then 
c                                 if called from readlm may be the 
c                                 legitimate text string "delta"
            call readnm (ibeg,iend,len,ier,name)

            if (name.eq.'delta') then 

               ibeg = iscan (iend,len,'=') + 1
               call readfr (rnum,ibeg,iend,len,ier)
               if (ier.ne.0) goto 90
               coeffs(ict+1) = rnum
               exit 

            else 
c                                 invalid data 
               goto 90

            end if 

         end if

         if (ier.ne.0) goto 90
c                                 find the name
         call readnm (ibeg,iend,len,ier,name)
         if (ier.ne.0) goto 90

         ict = ict + 1
         coeffs(ict) = rnum 
         inds(ict) = match(idim,ier,name)

         if (ier.ne.0) then 
            write (*,1010) name,tname,(chars(i),i=1,len)
            stop
         end if 
           
      end do

      return

90    write (*,1000) tname,(chars(i),i=1,len),name,rnum
      stop
      
1010  format (/,'**error ver201** invalid name: ',a,' in an expression',
     *        ' for solution model: ',a,/,' data was:',/,240a)
1000  format (/,'**error ver200** READZ bad data, currently',
     *        ' reading solution model: ',a,' data was:',/,240a,/,
     *        'last name read was: ',a,/,
     *        'last number (or real equivalent) was: ',g12.6,/)

      end 

      subroutine smodel (tname)
c-----------------------------------------------------------------
c smodel reads models for configurational entropy
c of solutions with dependent site mixing or disordered
c endmembers, see documentation section 1.3.1, equation (8b)
c-----------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      character*10 tname

      integer i,j,knsp,k,l

      integer jsmod
      double precision vlaar
      common/ cst221 /vlaar(m3,m4),jsmod

      integer nsub,nttyp,nterm,nspm1,nsite
      double precision acoef,smult,a0
      common/ cst107 /a0(m10,m11),acoef(m10,m11,m0),smult(m10),
     *      nsite,nspm1(m10),nterm(m10,m11),nsub(m10,m11,m0,m12),
     *      nttyp(m10,m11,m0)

      integer iend,isub,imd,insp,ist,isp,isite,iterm,iord,istot,jstot,
     *        kstot
      double precision wg,xmn,xmx,xnc
      common/ cst108 /wg(m1,m3),xmn(mst,msp),xmx(mst,msp),xnc(mst,msp),
     *      iend(m4),isub(m1,m2,2),imd(msp,mst),insp(m4),ist(mst),
     *      isp(mst),isite,iterm,iord,istot,jstot,kstot
c-----------------------------------------------------------------

      if (nsite.gt.m10) call error (31,a0(1,1),isite,tname)
c
      if (nsite.lt.isite) call error (30,a0(1,1),isite,tname)
c                                 for each site
      do i = 1, nsite 
c                                 read # of species, and site 
c                                 multiplicty.
         read (n9,*,err=90) knsp,smult(i)
         nspm1(i) = knsp - 1
c                                 for each species, read
c                                 function to define the
c                                 site fraction of the species:
         do j = 1, nspm1(i)
c                                 read # of terms in the 
c                                 site fraction function and a0.
            read (n9,*,err=90) nterm(i,j), a0(i,j)
            if (nterm(i,j).gt.m0) call error (33,a0(1,1),m0,tname)
c                                 for each term:
            do k = 1, nterm(i,j)
c                                 read term type:
               read (n9,*,err=90) nttyp(i,j,k)
               if (nttyp(i,j,k).lt.m12) then
                  read (n9,*,err=90) acoef(i,j,k),(nsub(i,j,k,l),
     *                               l = 1, nttyp(i,j,k))            
               else
                  call error (29,a0(1,1),nttyp(i,j,k),tname)
               end if
            end do 

         end do 
      end do 

      return

90    call error (20,a0(1,1),i,tname)

      end 

      double precision function gsixtr (id)
c-----------------------------------------------------------------------
c gsixtr computes G from the EoS formulated by Sixtrude & Bukowski '90, 
c JGR 95:19311-19325.

c Sixtrude parameters:

c    F0    n  -v(J/bar) K0(bar) K0'   theta0 gamma0 q etaS0 Smag

c Perple_X parameters (1st index in array thermo):

c    1     2     3        4     5      6      7    8    9    10

c and for shear modulii

c    G0(bar)   G0'

c are in the Perple_X array emod(i,id) with i

c      1        2
c-----------------------------------------------------------------------
      implicit none
 
      include 'perplex_parameters.h'

      integer id, itic, izap, izap1

      double precision turd2, a0, v0, v, df, f, dv, root, nr9t0, nr9t,
     *                 gamma0, k00, plg, c1, c2, c3, f1, gvq, 
     *                 n, q, vq, v23, theta0, tol, k0p, a, ethv

      double precision nr9, qm1, d2f, tht, tht0, etht, etht0, ltht, df1,
     *                 ltht0, dtht, dtht0, d2tht, d2tht0, g, g0, dg, 
     *                 dg0, d2g, d2g0, dfc, d2fc, dft, d2ft, dft0, d2ft0
 
      double precision thermo, uf, us
      common/ cst1 /thermo(k4,k10),uf(2),us(h5)

      double precision smu
      common/ cst323 /smu

      character*8 names 
      common/ cst8   /names(k1)

      double precision p,t,xco2,u1,u2,tr,pr,r,ps
      common/ cst5 /p,t,xco2,u1,u2,tr,pr,r,ps

      integer iemod,kmod
      logical smod,pmod
      double precision emod
      common/ cst319 /emod(k15,k10),smod(h9),pmod(k10),iemod(k10),kmod

      save turd2, izap, izap1 

      data turd2, izap, izap1 /0.6666666666666666667d0, 0, 0/
c----------------------------------------------------------------------
c                                 assign local variables:
      a0     =  thermo(1,id)
      n      =  thermo(2,id)
      v0     = -thermo(3,id)
      k00    =  thermo(4,id)
      k0p    =  thermo(5,id)
      theta0 =  thermo(6,id)
      gamma0 =  thermo(7,id)
      q      =  thermo(8,id)

      nr9    = thermo(11,id)
      c1     = thermo(12,id)
      c2     = thermo(13,id)
      c3     = thermo(14,id)
      qm1    = q - 1d0
      nr9t   = nr9*t
      nr9t0  = thermo(20,id)
c                                 initial guess for volume:
c                                 taylor(diff(FTH,v),v=v0,1)
c                                 JADC Feb 26, 2008. 
c                                 the dfth0 could be loaded as a 
c                                 constant. 
      tht    = theta0/t
      tht0   = theta0/tr
      k00    = thermo(4,id)
      k0p    = thermo(5,id)

      dft   = nr9t*gamma0/v0*(3d0*plg(tht)/tht**3 
     *        - dlog(1d0-exp(-tht)))
      dft0  = nr9t0*gamma0/v0*(3d0*plg(tht0)/tht0**3 
     *        - dlog(1d0-exp(-tht0)))
c                                 taylor(diff(FC,v),v=v0,2)
c     v       = (k00-dft+dft0-p)/k00*v0
c                                 taylor(diff(FC,v),v=v0,3)
      root = k00*((2d0+2d0*k0p)*(p+dft-dft0) + k00)

      if (root.gt.0d0) then 
         v = ((2d0+k0p)-dsqrt(root)/k00)*v0/(1d0+k0p)
         if (v.lt.v0/2d0.or.v.gt.v0*2d0) v = v0
      else 
         v = v0
      end if 

      f1 = 1d9
      itic = 0 
c                                 change to use relative tolerance
c                                 JADC March 1, 2005. formerly 1d-1 bar.
      tol = 1d-6*p

      do while (dabs(f1).gt.tol)

         itic = itic + 1

         vq = (v/v0)**q
         gvq = gamma0*vq
         v23 = (v0/v)**turd2
         f = 0.5d0*v23 - 0.5d0
         df = -v23/v/3d0
         d2f = 5d0/9d0*v23/v**2

         tht  =  theta0*dexp(-gamma0*((v/v0)**q-1d0)/q)/t
         if (tht.lt.1d-10) goto 90 
         tht0 =  tht*t/tr
         etht  = dexp(-tht )
         etht0 = dexp(-tht0)
         ltht  = dlog(1d0 - etht )
         ltht0 = dlog(1d0 - etht0)
c                                 diff(theta/T,v)
         dtht  = -gvq/v*tht
         dtht0 = -gvq/v*tht0
c                                 diff(theta/T,v,v)
         d2tht  = gvq*tht /v**2*(gvq - qm1)
         d2tht0 = gvq*tht0/v**2*(gvq - qm1)

         g   = plg(tht )
         g0  = plg(tht0)
         dg  = tht **2*ltht *dtht
         dg0 = tht0**2*ltht0*dtht0
         d2g  = ((2d0*ltht  + tht *etht /(1d0-etht ))*dtht **2 + 
     *          tht *ltht *d2tht )*tht
         d2g0 = ((2d0*ltht0 + tht0*etht0/(1d0-etht0))*dtht0**2 + 
     *          tht0*ltht0*d2tht0)*tht0

         dfc = (c3*f+c1)*f*df
         d2fc = (2d0*c3*f+c1)*df**2+(c3*f+c1)*f*d2f

         dft  = nr9t /tht **3*(dg  -3d0/tht *g *dtht )
         dft0 = nr9t0/tht0**3*(dg0 -3d0/tht0*g0*dtht0)

         d2ft =  nr9t /tht **3*(3d0/tht *(dtht *(4d0/tht *g *dtht  
     *                        - 2d0*dg ) - g *d2tht ) + d2g )
         d2ft0 = nr9t0/tht0**3*(3d0/tht0*(dtht0*(4d0/tht0*g0*dtht0 
     *                        - 2d0*dg0) - g0*d2tht0) + d2g0)

         f1  = -dfc - dft + dft0 - p

         df1 = -d2fc - d2ft + d2ft0 

         dv = f1/df1
         v = v - dv

         if (v.le.0d0.or.v/v0.gt.2d1.or.
     *       itic.gt.100.or.dabs(f1).gt.1d40) goto 90
 
      end do
c                                 if everything is ok, now get 
c                                 helmoltz energy:
      goto 10 
c                                 if we get here, failed to converge
90    if (izap.lt.10) then
         write (*,1000) t,p,names(id)
         izap = izap + 1
         if (izap.eq.10) call warn (49,r,369,'GETLOC')
      end if 
c                                 destabilize the phase:
      gsixtr = 1d10

      return 
         
10    vq = (v/v0)**q
      f = 0.5d0*(v0/v)**turd2 - 0.5d0
      tht  =  theta0*dexp(-gamma0*(vq-1d0)/q)/t
      tht0 =  tht*t/tr 

      a = a0 + c1*f**2*(0.5d0 + c2*f) 
     *  + nr9*(t/tht**3*plg(tht ) -tr/tht0**3*plg(tht0))

      gsixtr = a + p*v - t*thermo(10,id)
c                                 thermal energy/v
      ethv = (dft0-dft)/gamma0/vq
c                                 etas0 = thermo(9,id)
c                                 g0 = emod(1,id)
c                                 g0p = emod(2,id)
c                                 etas = thermo(9,id)*v/v0
c                                 adiabatic shear modulus
      smu = (1d0 + 2d0*f)**(2.5d0)*
     *      (emod(1,id)*(1d0 - 5d0*f) + f*emod(2,id)*3d0*k00)
     *    -  thermo(9,id)*v/v0*ethv

      if (tht.gt.5d0.or.tht0.gt.5d0.and.izap1.lt.10) then
         write (*,1020) id,tht0,tht
         izap1 = izap1 + 1
         if (izap1.eq.10) call warn (49,r,370,'GSTX')
      end if 
                   
1000  format (/,'**warning ver369** failed to converge at T= ',f8.2,' K'
     *       ,' P=',f9.1,' bar',/,'Using Sixtrude EoS.',
     *        ' Phase ',a,' will be destabilized.',/)
1020  format (/,'**warning ver370** danger will robinson, danger, ',
     *          'danger!!',/,i6,2(1x,g13.6))

      end 
      
      double precision function gstxlq (id)
c-----------------------------------------------------------------------
c gstxlq computes G from the liquid EoS formulated by Sixtrude et al 2009

c Stxrude parameters:

c   thermo(1)  = F0 
c   thermo(2)  = S0 - Cv  
c   thermo(3)  = V0   
c   thermo(4)  = Cv  
c   thermo(5)  = 4.5d0*K0*V0  
c   thermo(6)  = 4.5d0*K0*V0*(K'-4)    
c   thermo(7)  = y0 - y'   
c   thermo(8)  = y'    
c   thermo(9)  = T0
c   --- dependent ---
c   thermo(10) = (S0-Cv-Cv*y0)*T0
c   thermo(11) = Cv*(y0+ln(T0))-S0+Cv
c   thermo(12) = ln(v0)
  
c-----------------------------------------------------------------------
      implicit none
 
      include 'perplex_parameters.h'

      integer id, itic, izap

      logical bad

      double precision a5, a6, a7, a8, a9, a10, a11, v0, v, v2, df, f, 
     *                 d2a, f23, v23, tol, f59, d2f, df2, da, a1
 
      double precision thermo, uf, us
      common/ cst1 /thermo(k4,k10),uf(2),us(h5)

      character*8 names 
      common/ cst8   /names(k1)

      double precision p,t,xco2,u1,u2,tr,pr,r,ps
      common/ cst5 /p,t,xco2,u1,u2,tr,pr,r,ps

      save f23, f59, izap

      data f23, f59, izap /0.66666666666666666667d0,
     *                     0.55555555555555555556d0,0/
c----------------------------------------------------------------------
c                                 assign local variables:
      v0 = thermo(3,id)

      a10 = thermo(4,id)*(thermo(9,id)-t)*thermo(7,id)
      a7  = (thermo(11,id)-thermo(4,id)*dlog(t))*t+thermo(10,id) 
     *      - a10*thermo(12,id)
      a8  = thermo(5,id)
      a9  = thermo(6,id)
      a11 = thermo(4,id)*(thermo(9,id)-t)*thermo(8,id)/v0
      a6  = 3d0*a9
      a5  = 2d0*a8
c                                 initial guess for volume, taylor(diff(a,v),v=v0,3)
      a1 = (p+a11)*v0
      v = v0 + (9d0*(3d0*a8+a9)/(a5+a1*9d0)**2*(a1+a10) - 1d0)
     *         *9d0*v0*(a10+a1)/(a5+a1*9d0) 

      if (v.lt.v0/2d0.or.v.gt.v0*2d0) v = v0

      itic = 0 
      tol = 1d-6*p

      do 

         itic = itic + 1
c                                 f, and derivatives
         v23 = (v0/v)**f23
         v2  = v**2
         f   = 0.5d0*v23 - 0.5d0
         df  = -v23/v/3d0
         df2 = df*df
         d2f = f59*v23/v2
c                                 a 1st and 2nd derivatives
c                                 da is actually diff(a,v) + p
         da  = (a5 + a6*f)*f*df + a10/v + a11 + p
         d2a = (df2 + f*d2f)*a5 + (2d0*df2 + f*d2f)*a6*f - a10/v2

         v = v - da/d2a

         if (v.le.0d0.or.itic.gt.100.or.dabs(da).gt.1d40) then 
            bad = .true.
            exit 
         else if (dabs(da).lt.tol) then
            bad = .false.
            exit 
         end if 
 
      end do

      if (bad) then  
c                                 if we get here, failed to converge
         if (izap.lt.10) then
            write (*,1000) t,p,names(id)
            izap = izap + 1
            if (izap.eq.10) call warn (49,r,369,'GSTXLQ')
         end if 
c                                 destabilize the phase.
         gstxlq  = 1d10

      else 
c                                 everything ok, final f:
         f = 0.5d0*(v0/v)**f23 - 0.5d0 
c                                 g = helmholtz enery + pv
         gstxlq  = (a8 + a9*f)*f**2 + a7 + a10*dlog(v) + a10 + a11*v 
     *             + p*v + thermo(1,id)

      end if  
                   
1000  format (/,'**warning ver369** failed to converge at T= ',f8.2,' K'
     *       ,' P=',f9.1,' bar',/,'Using Sixtrude Liq EoS.',
     *        ' Phase ',a,' will be destabilized.',/)

      end 

      double precision function gstxgi (id)
c-----------------------------------------------------------------------
c gstxgi computes G from the EoS formulated by Sixtrude & Lithgow-B

c Stxrude parameters:

c    F0    -n  -v(J/bar) K0(bar) K0'   theta0 gamma0 q etaS0 Smag

c Perple_X parameters (1st index in array thermo):

c    1     2     3        4     5      6      7    8    9    10

c and for shear modulii

c    G0(bar)   G0'

c are in the Perple_X array emod(i,id) with i

c      1        2
c-----------------------------------------------------------------------
      implicit none
 
      include 'perplex_parameters.h'

      integer id, itic, izap, izap1

      logical bad

      double precision v0, v, df, f, dv, gamma0, k00, k0p,
     *           plg, c1, c2, c3, f1, aiikk, aiikk2, nr9t,
     *           root, aii, etas, a, ethv, gamma, da, nr9t0,
     *           fpoly, fpoly0, letht, letht0, z, aii2, f23,
     *           v23, tol, t1, t2, a2f, f59

      double precision nr9, d2f, tht, tht0, etht, etht0, df1,
     *                 dtht, dtht0, d2tht, d2tht0, 
     *                 dfc, d2fc, dfth, d2fth, dfth0, d2fth0
 
      double precision thermo, uf, us
      common/ cst1 /thermo(k4,k10),uf(2),us(h5)

      double precision smu
      common/ cst323 /smu

      character*8 names 
      common/ cst8   /names(k1)

      double precision p,t,xco2,u1,u2,tr,pr,r,ps
      common/ cst5 /p,t,xco2,u1,u2,tr,pr,r,ps

      integer iemod,kmod
      logical smod,pmod
      double precision emod
      common/ cst319 /emod(k15,k10),smod(h9),pmod(k10),iemod(k10),kmod

      save f23,f59, izap, izap1 

      data f23, f59, izap, izap1 /0.66666666666666666667d0,
     *                            0.55555555555555555556d0,0, 0/
c----------------------------------------------------------------------
c                                 assign local variables:
      v0     = -thermo(3,id)
      nr9    = thermo(11,id)
      c1     = thermo(12,id)
      c2     = thermo(13,id)
      c3     = thermo(14,id)
      aii    = thermo(15,id)
      aiikk  = thermo(16,id)
      aiikk2 = thermo(18,id)
      aii2   = thermo(19,id)
      nr9t0  = thermo(20,id) 

      t1     = thermo(6,id)/t
      t2     = t/tr
      nr9t   = nr9*t
c                                 initial guess for volume:
c                                 taylor(diff(FTH,v),v=v0,1)
c                                 JADC Feb 26, 2008. 
c                                 the dfth0 could be loaded as a 
c                                 constant. 
      tht    = t1
      tht0   = tht*t2
      gamma0 = thermo(7,id)
      k00    = thermo(4,id)
      k0p    = thermo(5,id)

      dfth   = nr9t*gamma0/v0*(3d0*plg(tht)/tht**3 
     *         - dlog(1d0-exp(-tht)))
      dfth0  = nr9t0*gamma0/v0*(3d0*plg(tht0)/tht0**3 
     *         - dlog(1d0-exp(-tht0)))
c                                 taylor(diff(FC,v),v=v0,2)
c     v       = (k00-dfth+dfth0-p)/k00*v0
c                                 taylor(diff(FC,v),v=v0,3)
      root = k00*((2d0+2d0*k0p)*(p+dfth-dfth0) + k00)

      if (root.gt.0d0) then 
         v = ((2d0+k0p)-dsqrt(root)/k00)*v0/(1d0+k0p)
         if (v.lt.v0/2d0.or.v.gt.v0*2d0) v = v0
      else 
         v = v0
      end if 

      itic = 0 
c                                 change to use relative tolerance
c                                 JADC March 1, 2005. formerly 1d-1 bar.
      tol = 1d-6*p

      do 

         itic = itic + 1
c                                 f, and derivatives
         v23 = (v0/v)**f23
         f = 0.5d0*v23 - 0.5d0
         df = -v23/v/3d0
         d2f = f59*v23/v**2
c                                 cold part derivatives
         dfc = (c3*f+c1)*f*df
         d2fc = (2d0*c3*f+c1)*df**2+(c3*f+c1)*f*d2f
c                                 debye T/T (tht)
         z  = 1d0+(aii+aiikk2*f)*f

         if (z.lt.0d0) then
            bad = .true.
            exit 
         end if 

         root = dsqrt(z)

         tht   = t1*root
         tht0  =  tht*t/tr
c                                 tht derivatives
         a2f   = aii2+aiikk2*f
         da    = a2f/root
         dtht  = t1*da*df
         d2tht = t1*((aiikk2/root-a2f**2/z**1.5d0)*df**2
     *               + da*d2f) 

         dtht0 = dtht*t2
         d2tht0 = d2tht*t2
c                                 polylog functions:
         fpoly   = 3d0*plg(tht )/tht**3
         fpoly0  = 3d0*plg(tht0)/tht0**3
c                                 thermal part derivatives:
         etht  = dexp(-tht )

         if (1d0-etht.lt.0d0) then
            bad = .true.
            exit 
         end if 

         letht = dlog(1d0-etht)

         dfth = (letht-fpoly)*nr9t*dtht/tht
         d2fth = ((4d0*dtht**2/tht-d2tht)*(fpoly-letht)
     *         + dtht**2*etht/(1d0-etht))*nr9t/tht

         etht0 = dexp(-tht0)

         if (1d0-etht0.lt.0d0) then
            bad = .true.
            exit 
         end if 
 
         letht0 = dlog(1d0-etht0)

         dfth0 = (letht0-fpoly0)*nr9t0*dtht0/tht0
         d2fth0 = ((4d0*dtht0**2/tht0-d2tht0)*(fpoly0-letht0)
     *          + dtht0**2*etht0/(1d0-etht0))*nr9t0/tht0

         f1  = -dfc - dfth + dfth0 - p

         df1 = -d2fc - d2fth + d2fth0 

         dv = f1/df1

         if (dabs(dv).gt.1d-2) dv = 1d-2*dv/dabs(dv)

         v = v - dv

         if (v.le.0d0.or.itic.gt.100.or.dabs(f1).gt.1d40) then 
            bad = .true.
            exit 
         else if (dabs(f1).lt.tol) then
            bad = .false.
            exit 
         end if 
 
      end do

      if (bad) then  
c                                 if we get here, failed to converge
         if (izap.lt.10) then
            write (*,1000) t,p,names(id)
            izap = izap + 1
            if (izap.eq.10) call warn (49,r,369,'GSTX')
         end if 
c                                 destabilize the phase.
         gstxgi  = 1d10

      else 

c                                 everything is ok, now get 
c                                 helmoltz energy:
         f = 0.5d0*(v0/v)**f23 - 0.5d0 
         z = 1d0+(aii+aiikk2*f)*f
         root = dsqrt(z)
c                                 final estimate for tht
         tht   = t1*root
         tht0  = tht*t2
c                                 helmholtz enery
         a = thermo(1,id) + c1*f**2*(0.5d0 + c2*f) 
     *     + nr9*(t/tht**3*plg(tht ) -tr/tht0**3*plg(tht0))

         gstxgi = a + p*v - t*thermo(10,id)
c                                 z = (theta/theta0)^2
         gamma = (2d0*f+1d0)*(aii+aiikk*f)/6d0/z
         etas = - gamma - thermo(17,id)/z*(2d0*f + 1d0)**2
c                                 thermal energy/V, based on
c                                 previous v estimate
         if (gamma.ne.0d0) then
            ethv = (dfth0-dfth)/gamma
         else 
            ethv = 0d0
         end if 
c                                 adiabatic shear modulus
         smu = (1d0 + 2d0*f)**(2.5d0)*(
     *         emod(1,id) + f*(thermo(21,id) + thermo(22,id)*f))
     *       - etas*ethv    
     
         if (tht.gt.5d0.or.tht0.gt.5d0.and.izap1.lt.10) then
            write (*,1020) id,tht0,tht
            izap1 = izap1 + 1
            if (izap1.eq.10) call warn (49,r,370,'GSTX')
         end if                  

      end if  
                   
1000  format (/,'**warning ver369** failed to converge at T= ',f8.2,' K'
     *       ,' P=',f9.1,' bar',/,'Using Sixtrude EoS.',
     *        ' Phase ',a,' will be destabilized.',/)
1020  format (/,'**warning ver370** danger will robinson, danger, ',
     *          'danger!!',/,i6,2(1x,g13.6))

      end 

      double precision function plg (t)
c-----------------------------------------------------------------------
c 29th order series expansion of polylog terms in sixtrude's EoS about
c t = 0, good to 0.0001 accuracy to t = 5.
c f := int((ln(1-exp(-t))*t^2),t=0..TD);
c gg := convert(series(f,TD=0,29),polynom);
c-----------------------------------------------------------------------
      implicit none

      double precision c2, t

      save c2 

      data c2 /0.1111111111111111111d0/

c                              13th order expansion good to t ~ 3
c       c1 = 1/3
c     plg  = t**3*((dlog(t)*c1-c2) - t/8d0 + t**2/120d0     
c    *     - t**4/20160d0 + t**6/1632960d0 - t**8/106444800d0)

      plg  = (t**3*((dlog(t)/3d0-c2) - t/8d0 + t**2/120d0     
     *     - t**4/20160d0 + t**6/1632960d0 - t**8/106444800d0
     *     + t**10/6227020800d0 - 0.2935661189d-11*t**12 
     *     + 0.562291451d-13*t**14 - 0.1115026413d-14*t**16
     *     + 0.2271444989d-16*t**18 - 0.4727975432d-18*t**20
     *     + 0.1001636878d-19*t**22 - 0.2153466772d-21*t**24))

      end 

      double precision function vdpbm3 (vt,k,kprime)
c-----------------------------------------------------------------------
c vdpbm3 computes the vdp integral of a compound identified by id
c that is described by Birch-Murnaghan 3rd order EoS.
c    vt - is the volume at Pr & T
c    k  - is the bulk modulus at Pr & T
c    kprime - is -K' at Pr and T
c-----------------------------------------------------------------------
      implicit none
 
      include 'perplex_parameters.h'

      integer itic, jerk

      double precision turd2, k, vt, turd, rat, rat2, c0, c1, c2, 
     *                 c3, c4, c5, a0, a1, v, df, f, dv, kprime

      double precision p,t,xco2,u1,u2,tr,pr,r,ps
      common/ cst5 /p,t,xco2,u1,u2,tr,pr,r,ps

      save turd, turd2, jerk 

      data turd, turd2, jerk /0.3333333333333333333d0,
     *                      0.6666666666666666667d0, 0/
c----------------------------------------------------------------------
c                                 constants:
      a0 = 0.375d0 * vt * k
      a1 = -0.125d0 * vt**2 * k
      c0 = (-28d0 -6d0 * kprime) * vt * a0
      c1 = (12d0 + 3d0 * kprime) * vt**2 * a0
      c2 = (16d0 + 3d0 * kprime) * a0
      c3 = a1 * vt * (-196d0 - 42d0 * kprime)
      c4 = a1 * (80d0 + 15d0 * kprime)
      c5 = a1 * vt * (108d0 + 27d0 * kprime)
c                                 initial guess for volume:
      v = k * vt / (p + k)
      dv = 1d0
      itic = 0 

      do while (dabs(dv).gt.1d-5)

         itic = itic + 1
         rat = (vt/v)**turd
         rat2 = rat**2
         f = p  + ((c0*v*rat+c1+c2*v**2*rat2)/v**3)
         df = (c3/rat2+c4*v/rat+c5)/v**4
         dv = f/df
         v = v - dv

         if (v.le.0d0.or.v.gt.1d6.or.itic.gt.20) then

            if (jerk.lt.10) then 
               jerk = jerk + 1
               write (*,1000) t,p
               if (jerk.eq.10) call warn (49,r,369,'GGHI')
            end if 

            if (k*(k-2d0*p*(1d0+kprime)).gt.0d0) then 

               v = 0.5d0/((3d0+kprime)*k+2d0*p)*((2d0+kprime)*2d0*k
     *             +2d0*dsqrt(k*(k-2d0*p*(1d0+kprime))))*vt 

            else 

               v = k * vt / (p + k)

            end if 

            exit

         end if 

      end do
c                                 and the vdp integral is:
      f = 0.5d0*((vt/v)**turd2-1d0)
c                                 checked in BM3_integration.mws
      vdpbm3 = p*v - vt*(pr-4.5d0*k*f**2*(1d0-f*(4d0+kprime))) 

1000  format (/,'**warning ver369** failed to converge at T= ',f8.2,' K'
     *       ,' P=',f9.1,' bar',/,'Using Birch-Murnaghan ',
     *        'EoS, probably for Ghiorso et al. MELTS/PMELTS endmember',
     *        ' data.',/,
     *        'Volume estimated using 3rd order taylor series.',/)

      end 

      subroutine cartes (ksite,sname,ids)
c---------------------------------------------------------------------
c subroutine to cartesian or transform subdivision on site ksite of 
c solution ids (or sname). called by subdiv.
c---------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer mres
 
      parameter (mres=3000)

      integer mode, i, ind(ms1), iy(ms1), jsp, ksite, indx, iexit, 
     *        ieyit, j, ids

      double precision tol, y(ms1,mres), ycum, ymax, dy, ync, res, ylmn,
     *                 ylmx, yloc, x, unstch, strtch, yreal

      logical odd

      character sname*10

      integer ntot,npairs
      double precision yy,xy
      common/ cst86 /xy(mdim,k1),yy(ms1,mst,k1),ntot,npairs

      integer iend,isub,imd,insp,ist,isp,isite,iterm,iord,istot,jstot,
     *        kstot
      double precision wg,xmn,xmx,xnc
      common/ cst108 /wg(m1,m3),xmn(mst,msp),xmx(mst,msp),xnc(mst,msp),
     *      iend(m4),isub(m1,m2,2),imd(msp,mst),insp(m4),ist(mst),
     *      isp(mst),isite,iterm,iord,istot,jstot,kstot
c                                 interval limits conformal transformation
      integer intv
      double precision yint, yfrc
      common/ cst47 /yint(5,ms1,mst,h9),yfrc(4,ms1,mst,h9),intv(4)
c                                 x coordinate description
      integer istg, ispg, imlt, imdg
      common/ cxt6i /istg(h9),ispg(h9,mst),imlt(h9,mst),imdg(ms1,mst,h9)

      character fname*10
      common/ csta7 /fname(h9)

      logical good(h9)

      save tol, good

      data tol, good/1d-5,h9*.true./
c----------------------------------------------------------------------
      ycum = 0d0
      jsp = isp(ksite) - 1

      if (jsp.eq.0) then 
c                                 a relict site with only one species
c                                 left over from reform, i have know idea
c                                 if this works
         y(1,1) = xmn(ksite,1)
         npairs = 1
         return 
      end if 

      do i = 1, jsp
c                                 generate coordinates for i'th component
         iy(i) = 1
         y(i,1) = xmn(ksite,i)
         ync = xnc(ksite,i)

         if (ync.eq.0d0) cycle

         mode = imdg(i,ksite,ids)
c                                 avoid impossible compositions 'cause a min > 0
         if (i.gt.1) then 

            ycum = ycum + xmn(ksite,i-1)
c                                 1-ycum is the smallest fraction possible
            if (1d0-ycum.lt.0) then 
c                                 inconsistent limits
               call error (999,ycum,jsp,'cartes')

            else
c                                 the smallest fraction possible is lt
c                                 than xmax
               ymax = xmx(ksite,i)

            end if 
         else 
            ymax = xmx(ksite,i)
         end if 
c                                 two means of extracting y-range, cartesian
c                                 imod = 0 and transformation imod = 1
         if (mode.eq.0) then 
c                                 check limit
            if (ync.lt.tol.and.good(ids)) then
               good(ids) = .false.
               write (*,1000) fname(ids)
            end if
               
c                                 cartesian
            do while (y(i,iy(i)).lt.ymax)
               iy(i) = iy(i) + 1
               if (iy(i).gt.mres) call error (999,ync,mres,sname)
               y(i,iy(i)) = y(i,iy(i)-1) + ync
               if (dabs(y(i,iy(i))-ymax).lt.tol) then
                  y(i,iy(i)) = ymax
               else if (y(i,iy(i)).gt.ymax) then
                  y(i,iy(i)) = ymax
               end if 
            end do

         else 
c                                 conformal x is the cartesian coordinate
c                                 y is the real coordinate.
            if (mode.lt.4) then 
               odd = .false.
            else
               odd = .true.
            end if 

            res = 0d0
c                                 there are as many as intv(mode)
c                                 intervals to cycle through
            do j = 1, intv(mode)
c                                 odd or even interval?
               odd = .not.odd
c                                 interval limits              
               ylmn = yint(j,i,ksite,ids)
               ylmx = yint(j+1,i,ksite,ids)
c                                 which interval are we starting from?
               if (y(i,iy(i)).gt.ylmx-tol) cycle
c
               dy = ylmx - ylmn
c                                 pathological case y = ylmn
               if (dabs(y(i,iy(i))-ylmn).lt.tol) y(i,iy(i)) = ylmn + tol

               if (res.eq.0d0) then 
c                                 the current value is in interval j
c                                 convert to raw y (varies from 0 ->1 
c                                 over the local interval)
                  yloc = (y(i,iy(i))-ylmn) / dy
c                                 convert to conformal x
                  if (odd) then 
                     x = unstch(yloc)
                  else 
                     x = 1d0 - unstch(1d0-yloc)
                  end if 

               else
c                                 have jumped from an earlier interval
                  x = res - ync / yfrc(j-1,i,ksite,ids)
c                 if (x.lt.0d0) x = 0d0

               end if                 
c                                 now generate all compositions in
c                                 local interval
               do while (x.le.1d0) 
c                                 increment conformal x
                  x = x + ync / yfrc(j,i,ksite,ids)
c                                 compute yreal
                  if (x.le.1d0) then 
                     if (odd) then 
                        yreal = ylmn + strtch(x) * dy
                     else
                        yreal = ylmx - strtch(1d0-x) * dy
                     end if 
c                                 cycle if below tolerance
                     if (yreal-y(i,iy(i)).lt.tol.and.good(ids)) then
                        good(ids) = .false.
                        write (*,1010) fname(ids)
                     end if 
 
                     iy(i) = iy(i) + 1
                     if (iy(i).gt.mres) call error (999,ync,mres,sname)
c                                 check if in bounds
                     if (dabs(yreal-ymax).lt.tol.or.yreal.gt.ymax) then
                        res = 0d0
                        y(i,iy(i)) = ymax
                        exit
                     else 
                        y(i,iy(i)) = yreal
                     end if 

                  else if (x.gt.1d0.and.j.eq.intv(mode)) then
c                                 at the last interval
                     iy(i) = iy(i) + 1
                     y(i,iy(i)) = ymax                
                     exit

                  else 
c                                the point is in the next interval
                     res = x - 1d0 
                     exit 

                  end if 
c                                 coordinate generating end do 
               end do 
c                                 if y is at ymax exit
               if (y(i,iy(i)).ge.ymax) exit
c                                 interval loop end do 
            end do 

         end if 
c                                 add last point if necessary, can it be? 
c                                 certainly not for conformal. 
         if (y(i,iy(i)).lt.ymax) then
            iy(i) = iy(i) + 1
            if (iy(i).gt.mres) call error (999,ync,mres,sname)
            y(i,iy(i)) = ymax
         end if          
 
      end do
c                                  
      do i = 1, jsp
         ind(i) = 1
      end do 
c                                 assign the first point
      npairs = 1

      do i = 1, jsp
         xy(i,1) = y(i,ind(i))
      end do
c                                 now make the array index run over all
c                                 values increasing the last index fastest
      iexit = 0 
      ieyit = 0 
      dy = 0d0

      do while (iexit.eq.0)
c                                 figure out which index to increment
         do i = jsp, 1, -1
            if (ind(i).lt.iy(i).and.ieyit.eq.0) then
c                                 this is the one to increment
               ind(i) = ind(i) + 1
               indx = i 
               exit 
            else if (i.gt.1) then 
c                                 saturated the index
               ind(i) = 1
               ieyit = 0 
               
            else
c                                 saturated first index, done.
                return 

            end if 
         end do 
c                                 ok now we have the indices, check
c                                 the composition
         ycum = 0d0

         do i = 1, jsp 
            ycum = ycum + y(i,ind(i))  
         end do 

         if (ycum.gt.1d0) then

            ieyit = 1
c                                 here is where it gets messy:
            if (indx.eq.1) then
c                                 we're at the first point, and already
c                                 over the top
               iexit = 1
               cycle

            else if ( y(indx,ind(indx)) - y(indx,ind(indx)-1)
     *               - ycum + 1d0    .gt. tol ) then          
c                                 reset the current variable
c                                 and max loop index
               dy =  1d0 - ycum 

            else
c                                 must have just hit on the last increment
               cycle 

            end if 
         end if 

         npairs = npairs + 1

         if (npairs.gt.k1) call error (180,ycum,k1,
     *                      'CARTES increase parameter k1')

         do i = 1, jsp
            xy(i,npairs) = y(i,ind(i))
         end do

         xy(indx,npairs) = xy(indx,npairs) + dy

         dy = 0d0 

      end do 

1000  format (/,'Warning: a composition of solution ',a,' has been ',
     *          'refined to a level that',/,'may destabilize ',
     *          'calculations. If excessive failure occurs, use less ',
     *        /,'extreme iteration parameters.',/)
1010  format (/,'Warning: a composition of solution ',a,' has been ',
     *          'refined to a level that',/,'may destabilize ',
     *          'calculations. If excessive failure occurs use less ',
     *        /,'extreme iteration parameters or ',
     *          'increase the stretching factor.',/)
      end


      subroutine blanko (text,chars,nchar,ilen)
c------------------------------------------------------------------- 
c unblnk - find the last non-blank character in text, 
c     text - character string 
c-------------------------------------------------------------------
      implicit none

      integer nchar, i, ilen

      character text*(*), chars(*)*1
 
      read (text,1000) (chars(i),i=1,ilen)
c                                 scan for blanks:
      do nchar = ilen, 1, -1
         if (chars(nchar).gt.' ') exit
      end do 

1000  format (400a1)

      end

      subroutine makecp (inames,mnames,first)
c----------------------------------------------------------------------
c makecp reads the thermodynamic to compute the composition vector of 
c made phases, called by vertex. programs without composition checking
c use smakcp.

c output to console if first = .true.
c----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer inames, i, j, k,ict, id, incomp(k0), jct 

      logical inph(k16*k17), inmk(k16), eof, good, first

      double precision mcp(k16*k17,k0)
      character name*8, mnames(k16*k17)*8

      integer cl
      character cmpnt*5, dname*80
      common/ csta5 /cl(k0),cmpnt(k0),dname

      double precision mcomp
      character mknam*8
      integer nmak
      logical mksat
      common / cst333 /mcomp(k16,k0),nmak,mksat(k16),mknam(k16,k17)

      double precision mkcoef, mdqf
      integer mknum, mkind
      common / cst334 /mkcoef(k16,k17),mdqf(k16,k17),mkind(k16,k17),
     *                 mknum(k16)

      integer idh2o,idco2,ikind,icmpn,icout,ieos
      double precision comp,tot
      common/ cst43 /comp(k0),tot,icout(k0),idh2o,idco2,
     *               ikind,icmpn,ieos
c----------------------------------------------------------------------
c                                 make a list of all definition names:
      inames = 0 

      do i = 1, nmak

         inmk(i) = .true.

         do j = 1, mknum(i)

            do k = 1, inames
               if (mnames(k).eq.mknam(i,j)) exit
            end do 

            if (k.le.inames) cycle

            inames = inames + 1
            mnames(inames) = mknam(i,j) 

         end do 

      end do 
c                                 array to find valid makes:
      do i = 1, inames
         inph(i) = .false.
      end do 
c                                 now get the composition vectors for 
c                                 the mnames phases:
      eof = .false.

      do 

         call getphi (name,eof)

         if (eof) exit

         do i = 1, inames
            if (name.eq.mnames(i)) then 

               do j = 1, icmpn
                  mcp(i,j) = comp(j)
               end do 

               inph(i) = .true.

               exit
            end if 
         end do 

      end do 
c                                 find valid makes:
      do i = 1, nmak

         do j = 1, mknum(i)

            do k = 1, inames

               if (mnames(k).eq.mknam(i,j).and.(.not.inph(k))) then 
                  inmk(i) = .false.
                  call warn (51,tot,icmpn,mknam(i,mknum(i)+1))
                  exit 
               else if (mnames(k).eq.mknam(i,j)) then 
                  mkind(i,j) = k
               end if 

            end do

            if (.not.inmk(i)) exit

         end do 

      end do 
c                                 compute the composition for each 
c                                 made entitity and check if it's 
c                                 valid
      ict = 0 

      do i = 1, nmak

         if (inmk(i)) then

            name = mknam(i,mknum(i)+1)

            do j = 1, icmpn
               mcomp(i,j) = 0d0
            end do 
 
            do j = 1, mknum(i)
               id = mkind(i,j)
               do k = 1, icmpn
                  mcomp(i,k) = mcomp(i,k) + mkcoef(i,j)*mcp(id,k)
               end do 
            end do 
c                                 test the composition vector
c                                 is it a normal phase (i.e.,
c                                 non-zero thermodynamic components)
            do k = 1, icmpn
               comp(k) = mcomp(i,k) 
            end do 

            call chkphi (1,name,good)

            if (good) then 
               
               mksat(i) = .false.

            else 
c                                 no thermo componnents, sat comps?
               call chkphi (0,name,good)

               mksat(i) = .true.

               if (.not.good) then

                  inmk(i) = .false.

c                 call warn (52,tot,icmpn,mknam(i,mknum(i)+1))

                  cycle

               end if 

            end if 

         end if 
      end do 
c                                 clean up arrays:
      ict = 0

      do i = 1, icmpn
         incomp(i) = 0
      end do 
   

      do i = 1, nmak

         if (inmk(i)) then

            ict = ict + 1

            mksat(ict) = mksat(i)

            mknum(ict) = mknum(i)

            do j = 1, mknum(ict)+1
               mknam(ict,j) = mknam(i,j)
            end do 

            do j = 1, mknum(ict)
               mkcoef(ict,j) = mkcoef(i,j)
            end do 

            do j = 1, k17
               mdqf(ict,j) = mdqf(i,j)
            end do 

            do j = 1, icmpn
               mcomp(ict,j) = mcomp(i,j)
c                                get list of used components
               if (mcomp(ict,j).ne.0d0.and.incomp(j).eq.0) incomp(j) = j

            end do 

         end if

      end do  

      jct = 0 
      do j = 1, icmpn
         if (incomp(j).ne.0) then 
            jct = jct + 1
            incomp(jct) = incomp(j)
         end if
      end do 

      nmak = ict

      if (nmak.gt.0.and.first) 
     *               write (*,1010) (cmpnt(incomp(j)),j=1,jct)
c                                remake list of phases required for 
c                                makes:
      inames = 0 

      do i = 1, nmak

         do j = 1, mknum(i)

            do k = 1, inames
               if (mnames(k).eq.mknam(i,j)) exit
            end do 

            if (k.le.inames) cycle 

            inames = inames + 1
            mnames(inames) = mknam(i,j) 
   
         end do
c                                write list of valid makes:
         if (first) write (*,1000) mknam(i,mknum(i)+1),
     *                            (mcomp(i,incomp(j)),j=1,jct)

      end do 

      if (nmak.gt.0.and.first) write (*,'(/)')

1000  format (a,1x,15(f5.2,1x))
1010  format (/,'Summary of valid make definitions:',//,10x,15(a,1x)) 

      end

      subroutine sattst (ifer,good)
c----------------------------------------------------------------------
c sorts phases into the appropriate saturated phase list called by 
c input2. returns good if data is valid            
c----------------------------------------------------------------------
      implicit none
 
      include 'perplex_parameters.h'
 
      integer j,ifer,idc

      logical good

      character name*8
      common/ csta6 /name

      integer icomp,istct,iphct,icp
      common/ cst6 /icomp,istct,iphct,icp

      integer iff,idss,ifug,ifyn,isyn
      common/ cst10  /iff(2),idss(h5),ifug,ifyn,isyn

      integer ic
      common/ cst42 /ic(k0)

      integer cl
      character cmpnt*5, dname*80
      common/ csta5 /cl(k0),cmpnt(k0),dname

      integer idh2o,idco2,ikind,icmpn,icout,ieos
      double precision comp,tot
      common/ cst43 /comp(k0),tot,icout(k0),idh2o,idco2,
     *               ikind,icmpn,ieos

      integer ids,isct,icp1,isat,io2
      common/ cst40 /ids(h5,h6),isct(h5),icp1,isat,io2
c-----------------------------------------------------------------------

      good = .false.

      if (ifyn.eq.0) then
c                               check for fluid species data
         if (name.eq.cmpnt(idco2)) then
            j = 2
            ifer = ifer + 1
         else if (name.eq.cmpnt(idh2o)) then
            j = 1
            ifer = ifer + 1
         else
            goto 70
         end if
 
         good = .true.
         call loadit (j,.false.)
         return

      end if
 
70    if (isyn.eq.0) then 
c                               check for saturated phases:
c                               reject the phase if it contains
c                               a thermodynamic component:
         do j = 1, icp
            if (comp(ic(j)).ne.0d0) return
         end do
c                               now load the phase if it has
c                               the saturated component idc:
         do j = isat, 1, -1
            idc = icp + j
            if (comp(ic(idc)).ne.0d0) then
               isct(j) = isct(j) + 1 
               if (isct(j).gt.h6) call error (17,1d0,h6,'SATTST')
               iphct = iphct + 1
               if (iphct.gt.k1) call error (180,1d0,k1,
     *                            'SATTST increase parameter k1')
               ids(j,isct(j)) = iphct
               call loadit (iphct,.false.)
               good = .true.
               return
            end if
         end do 
      end if 

      end 

      double precision function gmake (id)
c-----------------------------------------------------------------------
c gmake computes and sums the component g's for a make definition.
c the component g's may be calculated redundantly because gmake is
c called by gcpd, which in turn may be called by routines that call
c for a single g (e.g., gphase). 
c-----------------------------------------------------------------------
      implicit none
 
      include 'perplex_parameters.h'

      integer i, id, jd

      double precision g, dg

      double precision p,t,xco2,u1,u2,tr,pr,r,ps
      common/ cst5 /p,t,xco2,u1,u2,tr,pr,r,ps

      integer mknum, mkind
      double precision mkcoef, mdqf
      common / cst334 /mkcoef(k16,k17),mdqf(k16,k17),mkind(k16,k17),
     *                 mknum(k16)

      integer make
      common / cst335 /make(k10)
c-----------------------------------------------------------------------

      jd = make(id)

      g = 0d0
c                                compute the sum of the component g's
      do i = 1, mknum(jd)

         call gcpd (mkind(jd,i),dg)
         g = g + mkcoef(jd,i)*dg 

      end do 
c                                add the dqf correction
      gmake = g + mdqf(jd,1) + t*mdqf(jd,2) + p*mdqf(jd,3)

      end 

      subroutine smakcp (inames,mnames)
c----------------------------------------------------------------------
c smakcp reads the thermodynamic data file to compute the composition 
c vector of made phases without composition checking. vertex uses
c makecp
c----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer inames, i, j, k, ict, id, incomp(k0), jct 

      logical inph(k16*k17), inmk(k16), eof

      double precision mcp(k16*k17,k0)

      character name*8, mnames(k16*k17)*8

      integer cl
      character cmpnt*5, dname*80
      common/ csta5 /cl(k0),cmpnt(k0),dname

      double precision mcomp
      character mknam*8
      integer nmak
      logical mksat
      common / cst333 /mcomp(k16,k0),nmak,mksat(k16),mknam(k16,k17)

      double precision mkcoef, mdqf
      integer mknum, mkind
      common / cst334 /mkcoef(k16,k17),mdqf(k16,k17),mkind(k16,k17),
     *                 mknum(k16)

      integer idh2o,idco2,ikind,icmpn,icout,ieos
      double precision comp,tot
      common/ cst43 /comp(k0),tot,icout(k0),idh2o,idco2,
     *               ikind,icmpn,ieos
c----------------------------------------------------------------------
c                                 make a list of all definition names:
      inames = 0 

      do i = 1, nmak

         inmk(i) = .true.

         do j = 1, mknum(i)

            do k = 1, inames
               if (mnames(k).eq.mknam(i,j)) exit
            end do 

            if (k.le.inames) cycle

            inames = inames + 1
            mnames(inames) = mknam(i,j) 

         end do 

      end do 
c                                 array to find valid makes:
      do i = 1, inames
         inph(i) = .false.
      end do 
c                                 now get the composition vectors for 
c                                 the mnames phases:
      eof = .false.

      do 

         call getphi (name,eof)

         if (eof) exit

         do i = 1, inames
            if (name.eq.mnames(i)) then 

               do j = 1, icmpn
                  mcp(i,j) = comp(j)
               end do 

               inph(i) = .true.
 
               exit
            end if 
         end do 

      end do 
c                                 find valid makes:
      do i = 1, nmak

         do j = 1, mknum(i)

            do k = 1, inames

               if (mnames(k).eq.mknam(i,j).and.(.not.inph(k))) then 
                  inmk(i) = .false.
                  call warn (51,tot,icmpn,mknam(i,mknum(i)+1))
                  exit
               else if (mnames(k).eq.mknam(i,j)) then 
                  mkind(i,j) = k
               end if 

            end do

            if (.not.inmk(i)) exit 

         end do 

      end do 
c                                 compute the composition for each 
c                                 made entitity and check if it's 
c                                 valid
      ict = 0 

      do i = 1, nmak

         if (inmk(i)) then

            do j = 1, icmpn
               mcomp(i,j) = 0d0
            end do 
 
            do j = 1, mknum(i)
               id = mkind(i,j)
               do k = 1, icmpn
                  mcomp(i,k) = mcomp(i,k) + mkcoef(i,j)*mcp(id,k)
               end do 
            end do 
c                                 test the composition vector
c                                 is it a normal phase (i.e.,
c                                 non-zero thermodynamic components)
            do k = 1, icmpn
               comp(k) = mcomp(i,k) 
            end do 

         end if 
      end do 
c                                 clean up arrays:
      ict = 0

      do i = 1, icmpn
         incomp(i) = 0
      end do 
   

      do i = 1, nmak

         if (inmk(i)) then

            ict = ict + 1

            mknum(ict) = mknum(i)

            do j = 1, mknum(ict)+1
               mknam(ict,j) = mknam(i,j)
            end do 

            do j = 1, mknum(ict)
               mkcoef(ict,j) = mkcoef(i,j)
            end do 

            do j = 1, k17
               mdqf(ict,j) = mdqf(i,j)
            end do 

            do j = 1, icmpn
               mcomp(ict,j) = mcomp(i,j)
c                                get list of used components
               if (mcomp(ict,j).ne.0d0.and.incomp(j).eq.0) incomp(j) = j

            end do 

         end if

      end do  

      jct = 0 
      do j = 1, icmpn
         if (incomp(j).ne.0) then 
            jct = jct + 1
            incomp(jct) = incomp(j)
         end if
      end do 

      nmak = ict

      if (nmak.gt.0) write (*,1010) (cmpnt(incomp(j)),j=1,jct)
c                                remake list of phases required for 
c                                makes:
      inames = 0 

      do i = 1, nmak

         do j = 1, mknum(i)

            do k = 1, inames
               if (mnames(k).eq.mknam(i,j)) exit
            end do 

            if (k.le.inames) cycle

            inames = inames + 1
            mnames(inames) = mknam(i,j) 
   
         end do
c                                write list of valid makes:
         write (*,1000) mknam(i,mknum(i)+1),(mcomp(i,incomp(j)),j=1,jct)

      end do 

      write (*,1020)

1000  format (a,1x,15(f5.2,1x))
1010  format (/,'Summary of valid make definitions:',//,10x,15(a,1x)) 
1020  format (/)

      end

c       the x-files library for adaptive minimization

c local variables:
 
c insp(jstot/jstot+1) - pointer to original index of first kstot independent
c         endmembers, followed by jstot-kstot dependent endmembers, followed
c         by the ordered species, if present (jstot+1).
c istot - total number of endmembers (excluding ordered species) used
c         to formulate the solution model in the input file
c jmsol(jstot,msp) - chemical species present on m'th site of jstot'th
c          endmember, original indexing.
c jstot - total number of endmembers (excluding ordered species) used
c         in the computation (i.e., excluding missing endmembers), but
c         including dependent endmembers.
c kdsol(istot/istot+1) - endmember index, 0 if missing, -2 if dependent,
c          -1 if ordered species (istot+1/jstot+1), original indexing.
c kstot - total number of endmembers (excluding ordered species) 
c         used in the computation (i.e., excluding missing endmembers)

c global variables

c indx(i,j,k,l) - for solution i, pointer to the l'th original endmember
c                 index with species k on site j. 
c mstot(i) - istot globally
c jgsol(i,j,k) - k species indices of endmember j in solution i (jmsol globally) 

      subroutine reform (sname,im,first)
c---------------------------------------------------------------------
c reform - counts the number of species that can be respresented for a 
c solution given the present endmembers.
c---------------------------------------------------------------------
      implicit none
  
      include 'perplex_parameters.h'

      character*10 sname

      logical first

      integer kill,ikill,jkill,kill1,i,j,kosp(mst,msp),kill2,
     *        k,im,idsp,ksp(mst)

      integer jmsol,kdsol
      common/ cst142 /jmsol(m4,mst),kdsol(m4)

      integer iend,isub,imd,insp,ist,isp,isite,iterm,iord,istot,jstot,
     *        kstot
      double precision wg,xmn,xmx,xnc
      common/ cst108 /wg(m1,m3),xmn(mst,msp),xmx(mst,msp),xnc(mst,msp),
     *      iend(m4),isub(m1,m2,2),imd(msp,mst),insp(m4),ist(mst),
     *      isp(mst),isite,iterm,iord,istot,jstot,kstot
c----------------------------------------------------------------------
      kill = 1

      if (first.and.isite.gt.1) call warn (50,wg(1,1),isite,sname)

      do while (kill.lt.99) 

         do i = 1, isite
            ksp(i) = 1
            do j = 1, isp(i)
               kosp(i,j) = 0
            end do 
            do j = 1, isite
c                                 the number of endmembers that
c                                 should be present to represent
c                                 site i if all endmembers are present. 
               if (i.ne.j) ksp(i) = ksp(i)*isp(j)
            end do 
         end do
c                                 count the number of species
c                                 missing on each site
         do i = 1, istot
            if (kdsol(i).eq.0) then
               do j = 1, isite 
                  kosp(j,jmsol(i,j)) = kosp(j,jmsol(i,j)) + 1
               end do 
            end if 
         end do 
c                                 find the species that is missing
c                                 the most from the model
         kill = 99 
         kill1 = 0 

         do i = 1, isite
            if (isp(i).gt.1) then 
               do j = 1, isp(i)
c                                 idsp is the the number of species
c                                 possible - the number of missing
c                                 endmembers
                  idsp = ksp(i) -kosp(i,j)
                 
                  if (idsp.lt.kill) then 
                     ikill = i
                     jkill = j 
                     kill = idsp
                  else if (idsp.eq.kill.and.kosp(i,j).gt.0) then
c                                 kill the species that will kill the
c                                 most dependent endmembers
                     kill2 = 0 

                     do k = 1, istot
c                                 count the number that will be killed
                        if (jmsol(k,ikill).eq.jkill.and.kdsol(k).eq.-2) 
     *                     kill2 = kill2 + 1
                     end do

                     if (kill2.gt.kill1) then 
c                                 this is more than before (kill1)
                        kill1 = kill2 
                        ikill = i
                        jkill = j 
                        kill = idsp
                     end if 
                  end if 
               end do 
            end if 
         end do      
c                                 kill the species jkill on site ikill
c                                 and reformulate the model (this is 
c                                 inefficient, but we don't care here). 
         call killsp (ikill,jkill)
c                                 check exit conditions
         if (istot.lt.2) then
c                                 failed, rejected too many endmembers
            kill = 99 

            im = im - 1
            if (first) call warn (25,wg(1,1),jstot,sname)
            jstot = 0

         else if (istot.eq.jstot) then  
c                                 succeeded
            kill = 99 
c                                 reorder the insp array so that the 
c                                 the first kstot endmembers are 
c                                 independent, followed by the 
c                                 dependent endmember, followed by
c                                 the ordered species. 
         end if 

      end do 

      end 


      subroutine killsp (ikill,jkill)
c---------------------------------------------------------------------
c killsp - eliminates species jkill from site ikill in a solution model
c and reformulates the model accordingly
c---------------------------------------------------------------------
      implicit none
  
      include 'perplex_parameters.h'

      logical skip, bad, dead

      integer jsp,jtic,morder,
     *        i,j,ikill,jkill,kill,kdep,jdqf,ktic,jold,
     *        iwas(m4),i2ni(m4),kwas(m4),
     *        k,l,itic,ijkill(m4),
     *        j2oj(msp),j2nj(msp),i2oi(m4),maxord,mord
c                                 dqf variables
      integer indq,idqf
      double precision dqf
      common/ cst222 /dqf(m3,m4),indq(m4),idqf

      logical depend,laar,order,fluid,macro,specil,recip
      common/ cst160 /depend,laar,order,fluid,macro,specil,recip
c                                 local input variables
      integer iddeps,norder
      double precision depvnu,denth
      common/ cst141 /depvnu(2,j3),denth(j3),iddeps(2,j3),norder

      integer jsmod
      double precision vlaar
      common/ cst221 /vlaar(m3,m4),jsmod

      integer jmsol,kdsol
      common/ cst142 /jmsol(m4,mst),kdsol(m4)

      integer nsub,nttyp,nterm,nspm1,nsite
      double precision acoef,smult,a0
      common/ cst107 /a0(m10,m11),acoef(m10,m11,m0),smult(m10),
     *      nsite,nspm1(m10),nterm(m10,m11),nsub(m10,m11,m0,m12),
     *      nttyp(m10,m11,m0)

      integer iend,isub,imd,insp,ist,isp,isite,iterm,iord,istot,jstot,
     *        kstot
      double precision wg,xmn,xmx,xnc
      common/ cst108 /wg(m1,m3),xmn(mst,msp),xmx(mst,msp),xnc(mst,msp),
     *      iend(m4),isub(m1,m2,2),imd(msp,mst),insp(m4),ist(mst),
     *      isp(mst),isite,iterm,iord,istot,jstot,kstot

      integer iorig,jnsp,iy2p
      common / cst159 /iorig(m4),jnsp(m4),iy2p(m4)

      integer mdep,idep,jdep,ndph
      double precision nu,y2p
      common/ cst146 /nu(m15,j4),y2p(m4,m15),mdep,jdep(m15),
     *                idep(m15,j4),ndph(m15)

      double precision yin
      common/ cst50 /yin(ms1,mst)

      integer limn,limt,limid,jimid,jimt
      double precision limc,jimc
      common/ cxt30 /limc(j6+2,j5,j3),limid(m0,j5,j3),jimid(j3,j5,j3),
     *               limn(j3),limt(j5,j3),jimc(j3,j5,j3),jimt(j5,j3)
c----------------------------------------------------------------------
      do i = 1, isite

         if (i.ne.ikill) then
c                                 nothing happens  
            do j = 1, isp(i)  
              j2oj(j) = j 
            end do
         else 
c                                 on a site where we kill a species
            jsp = isp(i) - 1
c                                 should also check and store subdivsion
c                                 model here (i.e., some ternary model
c                                 choices are not valid as binary):

c                                 make a pointer from the new species
c                                 index to the old index
            jtic = 0 

            do j = 1, isp(i)
               if (j.ne.jkill) then 
                  jtic = jtic + 1 
c                              pointer from new j to old j
                  j2oj(jtic) = j
c                              pointer from old j to new j
                  j2nj(j) = jtic
               end if 
            end do
c                              now reload
            isp(i) = jsp

            if (jsp.gt.1) then   
c                              now shift subdivision ranges
               do j = 1, jsp - 1
                  xmn(i,j) = xmn(i,j2oj(j))
                  xmx(i,j) = xmx(i,j2oj(j))
                  xnc(i,j) = xnc(i,j2oj(j))
                  imd(j,i) = imd(j2oj(j),i)

                  if (imd(j,i).gt.0) yin(j,i) = yin(j2oj(j),i)

               end do
            else 
               xmn(i,j) = 1d0
               xmx(i,j) = 1d0
               xnc(i,j) = 1d0                 
            end if
         end if 
      end do 

      kdep = 0 

      do i = 1, istot

         if (depend.and.kdsol(i).eq.-2) then 
c                                create an array which gives the
c                                original locations of the dependent
c                                endmembers, need this to be able to
c                                reorder the y2p array:
            kdep = kdep + 1
            iwas(kdep) = i 
         end if 
c                                 kill endmembers with the species
c                                 to be deleted:
         if (jmsol(i,ikill).eq.jkill) kdsol(i) = -3

      end do 
c                                 check for dependent endmembers
      call redep (-3)
c                                 at this point all ordered endmembers to 
c                                 be killed are flagged by kdsol = -3.

c                                 now check the ordered species
      morder = 0 

      if (order) then 
c                                 first check if the ordered endmember
c                                 may be stable 
         do k = 1, norder      
c                                 check if a missing constituent 
            bad = .false.

            do j = 1, 2
               if (kdsol(iddeps(j,k)).eq.-3) then 
                  bad = .true.
                  exit 
               end if 
            end do

            if (bad) then 
c                                 add species to the kill list
               kdsol(istot+k) = -3
            
            else 

               morder = morder + 1
               kdsol(istot+k) = -1
               kwas(morder) = k

            end if 

         end do  

      end if 
c                                figure out which dependent endmembers have
c                                been killed:
      if (depend) then 

         if (kdep.ne.mdep) call error (54,dqf(1,1),mdep,'KILLSP')

         mdep = 0 

         do i = 1, kdep
            if (kdsol(iwas(i)).ne.-3) then 
               mdep = mdep + 1
c                                 iwas is now the original index of the 
c                                 dependent endmember, and mdep is the reset
c                                 value of the dependent endmember counter
               iwas(mdep) = i                
            end if
         end do 

      end if 
 
      itic = 0 
      jtic = 0
      ktic = 0
      kill = 0 
      
      do i = 1, istot + norder 

         if (kdsol(i).ge.-2) then 
c                                 replacement for istot (itic)
            itic = itic + 1
c                                 pointers from new to old endmember index (i2oi)
            i2oi(itic) = i
c                                 pointers from new to old endmember index (i2ni)
            i2ni(i) = itic                                
c                                 pointer to original species index
            iorig(itic) = iorig(i)
c                                 number of missing endmembers (jtic)
            if (kdsol(i).eq.0) jtic = jtic + 1
c                                reset the kdsol array
            kdsol(itic) = kdsol(i)

            if (i.gt.istot) cycle
c                                 reset the species pointers (jmsol) 
            do j = 1, isite
               if (j.eq.ikill) then
                  jmsol(itic,j) = j2nj(jmsol(i,j))
               else
                  jmsol(itic,j) = jmsol(i,j)
               end if 
            end do
         else 
c                                 kill records the killed endmembers
            kill = kill + 1
            ijkill(kill) = i

         end if 
      end do  
c                                reset total and present counters
      istot = itic - morder 
c            
      jstot = itic - jtic - morder
c                                --------------------------------------
c                                excess terms:
      itic = 0 
      maxord = 0 
    
      do i = 1, iterm 
c                                check for forbidden terms (i.e., terms
c                                with a missing endmember
         skip = .false. 
c                                 macroscopic formulation
         do j = 1, kill
c                                 check if subscript points to a killed 
c                                 endmember
            do k = 1, iord
               if (isub(i,k,1).eq.ijkill(j)) then
                  skip = .true.
                  exit 
               end if 
            end do 

            if (skip) exit

         end do 

         if (skip) cycle 
c                               the term is acceptable
         itic = itic + 1

         mord = iord

         do j = 1, iord
            isub(itic,j,1) = i2ni(isub(i,j,1))
         end do 
c                                save the coefficient
         do j = 1, m3
            wg(itic,j) = wg(i,j)
         end do 
c                                find highest order term
         if (mord.gt.maxord) maxord = mord

      end do     
c                                reset counters, iord is not reset
      iterm = itic
      iord = maxord                         
c                                --------------------------------------
c                                van laar volume functions
      if (laar) then
         do i = 1, istot + morder 
            do j = 1, m3
               vlaar(j,i) = vlaar(j,i2oi(i))
            end do 
         end do  
      end if 
c                                 --------------------------------------
c                                 dqf corrections, this is sloppy since
c                                 uses istot instead of kstot
      if (idqf.gt.0) then 

         jdqf = 0 
c                                 check if a retained species has a dqf
c                                 correction
         do j = 1, idqf
c                                 the itoi index must be in the inner loop
c                                 in case the values of indq are not sequential
            do i = 1, istot
               if (indq(j).eq.i2oi(i)) then 
c                                 found a dqf'd endmember
                  jdqf = jdqf + 1
                  indq(jdqf) = i
                  do k = 1, m3
                     dqf(k,jdqf) = dqf(k,j)
                  end do 
                  exit 
               end if
            end do 

            if (jdqf.eq.idqf) exit
 
         end do 

         idqf = jdqf 

      end if 
c                                 --------------------------------------
c                                 configurational entropy model

c                                 site fractions as a function of bulk
c                                 y's and dependent species y:
      do i = 1, nsite 
c                                 for each species, read function to define 
c                                 the site fraction of the species and eliminate
c                                 killed species

c                                 species counter is incremented in advance
c                                 and must be decremented before saving the 
c                                 final value:
         jtic = 1 

         do j = 1, nspm1(i)

            ktic = 0 
c                                 for each term:
            do k = 1, nterm(i,j)
c                                 macroscopic formulation:
c                                 note: 4th index (nttyp) is only used
c                                 for bragg-williams models.
               dead = .false.
               do l = 1, kill 
                  if (nsub(i,j,k,1).eq.ijkill(l)) then 
                     dead = .true.
                     exit 
                  end if 
               end do 

               if (.not.dead) then
c                                 the term has survived (and therefore 
c                                 also the species):
c                                 don't save nttyp since this is always
c                                 1 for the macroscopic formulation
                  ktic = ktic + 1
c                                 but my dear peanut brained friend, do 
c                                 not forget to move the pointer:
                  nsub(i,jtic,ktic,1) = i2ni(nsub(i,j,k,1)) 
                  acoef(i,jtic,ktic) = acoef(i,j,k)
               end if  
            end do 
c                                 ktic is the number of terms representing
c                                 the jth species, we won't count species 
c                                 with no terms because the endmember configurational
c                                 entropy is assumed to be implicit. 
         if (ktic.gt.0) then 
c                                 increment the species counter
            nterm(i,jtic) = ktic 
            a0(i,jtic) = a0(i,j)
            jtic = jtic + 1
         end if 

      end do

      nspm1(i) = jtic - 1

      end do 
c                                 ---------------------------------------
c                                 ordered species:
      if (order) then 

         norder = morder

         if (morder.eq.0) then 
c                                 there are no ordered species left
            order = .false.

            if (depend) then
               jsmod = 7
            else 
               jsmod = 2
            end if 

         else 
c                                 shift the ordered species pointers 
c                                 and data to eliminate kill ordered
c                                 species.    
            do j = 1, morder 

               jold = kwas(j)
               denth(j) = denth(jold)

               do i = 1, 2
                  iddeps(i,j) = i2ni(iddeps(i,jold))
                  depvnu(i,j) = depvnu(i,jold)
               end do

               itic = 1 

               do i = 1, limn(jold)
c                                 eliminate absent species from 
c                                 stoichiometric p0 limits
                  ktic = 0 

                  do k = 1, limt(i,jold)

                     skip = .false.

                     do l = 1, kill
c                                 check if limid points to a killed 
c                                 endmember
                        if (limid(k,i,jold).eq.ijkill(l)) then
                           skip = .true.
                           exit 
                        end if
  
                     end do  

                     if (skip) cycle

                     ktic = ktic + 1

                     limid(ktic,itic,j) = i2ni(limid(k,i,jold))
                     limc(ktic,itic,j) = limc(k,i,jold)

                  end do 

                  if (ktic.eq.0) cycle

                  limc(ktic+1,itic,j) = limc(k,i,jold)
                  limc(ktic+2,itic,j) = limc(k+1,i,jold)
                  limt(itic,j) = ktic
c                                 now check the p terms, this assumes
c                                 there are no p terms if there are no
c                                 p0 terms, which maynot be true?
                  ktic = 0 

                  do k = 1, jimt(i,jold)

                     skip = .false.

                     do l = 1, kill
c                                 check if limid points to a killed 
c                                 endmember
                        if (jimid(k,i,jold).eq.ijkill(l)) then
                           skip = .true.
                           exit 
                        end if
  
                     end do  

                     if (skip) cycle

                     ktic = ktic + 1

                     jimid(ktic,itic,j) = i2ni(jimid(k,i,jold))
                     jimc(ktic,itic,j) = jimc(k,i,jold)

                  end do 

                  jimt(itic,j) = ktic

                  itic = itic + 1

               end do 

               limn(j) = itic - 1

            end do 

         end if  

      end if 
c                                 --------------------------------------
c                                 dependent endmember properties, the
      if (depend) then 
c                                 dependent endmembers have been reordered
c                                 in redep, but are still expressed in
c                                 terms of the old indices, so reset the 
c                                 indices:
         do i = 1, mdep
            jdep(i) = i2ni(jdep(i))
            do j = 1, ndph(i)
               idep(i,j) = i2ni(idep(i,j))
            end do 
         end do 

      end if 

      end

      subroutine cmodel (im,idsol,tname,ibuild,x1,x2,first)
c---------------------------------------------------------------------
c cmodel - checks to see if solution models contain valid endmembers.
c modified to allow saturated phase/component endmembers, 10/25/05.
c---------------------------------------------------------------------
      implicit none
  
      include 'perplex_parameters.h'

      logical first
 
      character*10 tname,missin(m4)*8,x1*8,x2*8

      integer imiss,im,idsol,ibuild,i,j,h
 
      integer isoct
      common/ cst79 /isoct  

      integer jmsol,kdsol
      common/ cst142 /jmsol(m4,mst),kdsol(m4)

      integer jsmod
      double precision vlaar
      common/ cst221 /vlaar(m3,m4),jsmod

      integer ipoint,imyn
      common/ cst60 /ipoint,imyn

      character*8 names
      common/ cst8 /names(k1)

      character fname*10
      common/ csta7 /fname(h9)

      character mname*8
      common/ cst18a /mname(m4)

      integer iend,isub,imd,insp,ist,isp,isite,iterm,iord,istot,jstot,
     *        kstot
      double precision wg,xmn,xmx,xnc
      common/ cst108 /wg(m1,m3),xmn(mst,msp),xmx(mst,msp),xnc(mst,msp),
     *      iend(m4),isub(m1,m2,2),imd(msp,mst),insp(m4),ist(mst),
     *      isp(mst),isite,iterm,iord,istot,jstot,kstot

      integer mdep,idep,jdep,ndph
      double precision nu,y2p
      common/ cst146 /nu(m15,j4),y2p(m4,m15),mdep,jdep(m15),
     *                idep(m15,j4),ndph(m15)

      integer ikp
      common/ cst61 /ikp(k1)
c----------------------------------------------------------------------
      jstot = 0
c                              if called by build (ibuild = 1) skip the
c                              name check:
      if (ibuild.eq.1) goto 60
c                              check that solution name matches a 
c                              name requested in input from n1
      do i = 1, isoct

         if (tname.eq.fname(i)) then 
c                              got a match, goto 60:
            idsol = i 
            im = im + 1
            goto 60 
         end if 
c
      end do 
c                              didn't find a match, read a new name:
      return 
c                              check that the endmembers match with data
c                              from n2:   
60    do 70 i = 1, istot

         kdsol(i) = 0

         if (jsmod.eq.5.or.jsmod.eq.7.or.jsmod.eq.8) then
c                              solution with dependent endmembers, if endmember i
c                              is dependent endmember flag it by setting kdsol(i) = -2
            do j = 1, mdep
               if (jdep(j).eq.i) then
                  kdsol(i) = -2
                  goto 70
               end if 
            end do 
         end if 

         do h = 1, ipoint
c                                 in build, check for forbidden choices:
            if (ibuild.eq.1) then
               if (mname(i).eq.x1.or.mname(i).eq.x2) then
                  write (*,1010) tname, x1, x2
                  jstot = 0
                  return
               end if
            end if

            if (names(h).eq.mname(i)) then
c                                 got a valid endmember, count and                     
               jstot = jstot + 1 
               kstot = jstot
c                                 create arrays of convenience, where j = 1, jstot
               kdsol(i) = h                                 
c                                 set kill flag: 
c                                 don't reset ikp if it has been set for 
c                                 another model.
               if (iend(i).ne.0.and.ikp(h).eq.0) ikp(h) = -1
c                                 found all endmembers:
               if (jstot.eq.istot) return

               goto 70
            end if 
         end do
70    continue

      call redep (0)
c                                done if nothing is missing:
      if (jstot.eq.istot) return
c                                missing endmember warnings:
      if (jstot.lt.2) then
         im = im - 1
         if (first) call warn (25,wg(1,1),jstot,tname)
         jstot = 0 
      else 
         imiss = 0 
         do i = 1, istot
            if (kdsol(i).eq.0) then
               imiss = imiss + 1
               missin(imiss) = mname(i)
            end if 
         end do 
         if (first) write (*,1000) tname,(missin(i), i = 1, imiss)
      end if 

1000  format (/,'**warning ver114** the following endmembers',
     *          ' are missing for ',a,/,4(8(2x,a),/),/)
1010  format (/,'**warning ver113** ',a,' is not a valid model',
     *        ' because component ',a,' or ',a,/,
     *        ' is constrained or missing.',/)
      end

      subroutine redep (jkill)
c----------------------------------------------------------------------
c redep does reordering of dependent endmembers

c jkill is the value of kdsol that indicates invalid (missing) endmembers,
c this is 0 from cmodel and -3 from reform.
c----------------------------------------------------------------------
      implicit none
  
      include 'perplex_parameters.h'

      integer i,j,l,ndep,k,jkill

      logical depend,laar,order,fluid,macro,specil,recip
      common/ cst160 /depend,laar,order,fluid,macro,specil,recip
 
      integer jmsol,kdsol
      common/ cst142 /jmsol(m4,mst),kdsol(m4)

      integer jsmod
      double precision vlaar
      common/ cst221 /vlaar(m3,m4),jsmod

      integer iend,isub,imd,insp,ist,isp,isite,iterm,iord,istot,jstot,
     *        kstot
      double precision wg,xmn,xmx,xnc
      common/ cst108 /wg(m1,m3),xmn(mst,msp),xmx(mst,msp),xnc(mst,msp),
     *      iend(m4),isub(m1,m2,2),imd(msp,mst),insp(m4),ist(mst),
     *      isp(mst),isite,iterm,iord,istot,jstot,kstot

      integer iddeps,norder 
      double precision depvnu,denth
      common/ cst141 /depvnu(2,j3),denth(j3),iddeps(2,j3),norder

      integer mdep,idep,jdep,ndph
      double precision nu,y2p
      common/ cst146 /nu(m15,j4),y2p(m4,m15),mdep,jdep(m15),
     *                idep(m15,j4),ndph(m15)
c----------------------------------------------------------------------
c                                check for dependent endmembers, necessary?
      if (depend) then

         ndep = 0  

         do 100 i = 1, mdep

            do j = 1, ndph(i)

               if (idep(i,j).le.istot) then
c                                looking for a dependent endmember component: 
                  if (kdsol(idep(i,j)).eq.jkill.and.
     *                kdsol(jdep(i)).ne.-3) then
c                                a component is missing in cmodel, reset kdsol to 0
                     kdsol(jdep(i)) = 0
                     goto 100 
                  end if 

               else
c                                looking for an ordered species
                  do l = 1, norder 
                     do k = 1, 2
                        if (kdsol(iddeps(k,l)).eq.jkill) then
                           kdsol(jdep(i)) = 0 
                           goto 100
                        end if 
                     end do 
                  end do 

               end if 
            end do 
c                                dependent endmember is ok
            ndep = ndep + 1
            jdep(ndep) = jdep(i)
            ndph(ndep) = ndph(i)

            do j = 1, ndph(i)
               idep(ndep,j) = idep(i,j)
               nu(ndep,j) = nu(i,j)
            end do 

            jstot = jstot + 1

100      continue 

         mdep = ndep

         if (mdep.eq.0) then

            depend = .false.

            if (jsmod.eq.7.or.jsmod.eq.5) then
               jsmod = 2
               if (laar) jsmod = 3
            else 
               jsmod = 6
            end if 
         end if  

      end if 

      end 

      subroutine rmodel (tname,bad)
c---------------------------------------------------------------------
c rmodel - reads solution models from LUN n9.
c---------------------------------------------------------------------
      implicit none
  
      include 'perplex_parameters.h'
 
      character*10 tname, tag*3, char*1

      integer nreact,i,j,k,l,m,jlaar,idim

      logical bad

      double precision coeffs(k7),rnums(100),enth

      integer ijk(mst),inds(k7),ict

      integer jmsol,kdsol
      common/ cst142 /jmsol(m4,mst),kdsol(m4)

      integer jsmod
      double precision vlaar
      common/ cst221 /vlaar(m3,m4),jsmod

      integer nsub,nttyp,nterm,nspm1,nsite
      double precision acoef,smult,a0
      common/ cst107 /a0(m10,m11),acoef(m10,m11,m0),smult(m10),
     *      nsite,nspm1(m10),nterm(m10,m11),nsub(m10,m11,m0,m12),
     *      nttyp(m10,m11,m0)

      integer iend,isub,imd,insp,ist,isp,isite,iterm,iord,istot,jstot,
     *        kstot
      double precision wg,xmn,xmx,xnc
      common/ cst108 /wg(m1,m3),xmn(mst,msp),xmx(mst,msp),xnc(mst,msp),
     *      iend(m4),isub(m1,m2,2),imd(msp,mst),insp(m4),ist(mst),
     *      isp(mst),isite,iterm,iord,istot,jstot,kstot

      logical depend,laar,order,fluid,macro,specil,recip
      common/ cst160 /depend,laar,order,fluid,macro,specil,recip

      integer iorig,jnsp,iy2p
      common / cst159 /iorig(m4),jnsp(m4),iy2p(m4)

      integer iddeps,norder 
      double precision depvnu,denth
      common/ cst141 /depvnu(2,j3),denth(j3),iddeps(2,j3),norder

      integer mdep,idep,jdep,ndph
      double precision nu,y2p
      common/ cst146 /nu(m15,j4),y2p(m4,m15),mdep,jdep(m15),
     *                idep(m15,j4),ndph(m15)

      double precision yin
      common/ cst50 /yin(ms1,mst)
c----------------------------------------------------------------------

      mdep = 0 
      istot = 0
      ist(1) = 0 
c                               set logical variables
      specil = .false.
      macro = .false.
      order = .false.
      laar = .false.
      depend = .false.
      fluid = .false.
      recip = .false.
      bad = .false.

      do 
          read (n9, '(3(a,1x))', iostat = i) tname
          if (i.ne.0) return
          read (tname,'(a1)') char
          if (char.eq.' '.or.char.eq.'|') cycle
          if (tname.ne.'begin_mode') exit
      end do 

      call readda (rnums,1,tname)
c                               model type flag
      jsmod = idint(rnums(1))   
c                               correct jsmod for old versions    
      if (jsmod.eq.3) jsmod = 2  
      if (jsmod.eq.0) fluid = .true.
      if (jsmod.eq.1) call error (68,enth,jsmod,tname)
      if (jsmod.eq.6.or.jsmod.eq.8) order = .true.
      if (jsmod.eq.5.or.jsmod.eq.7.or.jsmod.eq.8) depend = .true. 
      if (jsmod.eq.7.or.jsmod.eq.8) recip = .true. 
      if (jsmod.gt.20) specil = .true.  
c                               read number of independent sites:
      if (recip) then 
         call readda (rnums,1,tname)    
         isite = idint(rnums(1)) 
      else
         isite = 1
      end if 
c                               read number of species on each site:
      call readda (rnums,isite,tname)  
      do i = 1, isite
         isp(i) = idint(rnums(i))
      end do 
c                               total number of endmembers:
      istot = 1
      do i = 1, isite
         istot = istot*isp(i)
      end do 
c                               counter for character read routines
      idim = istot
c                               read endmember names:
      call readn (idim,tname)
c                               compound formation models
      norder = 0 

      if (order) then 
c                               get the number of ordered species
         call readda (rnums,1,tname)    
         norder = idint(rnums(1)) 

         if (norder.gt.j3) call error (5,rnums(1),norder,tname)
c                               nreact can only be 3 for ordered
c                               species:
         nreact = 3
c                               get ordering reaction and name
c                               of ordered species:   
         do i = 1, norder   

            call readr (coeffs,enth,inds,idim,nreact,tname)

            denth(i) = enth
  
            do j = 1, 2
               depvnu(j,i) = coeffs(j+1)
               iddeps(j,i) = inds(j+1)
            end do

         end do  
c                               read the limit equations for the 
c                               amount of the ordered endmembers
         call readlm (tname,bad)

      end if 
c                               read dependent endmembers
      if (depend) then
c                               number of dependent endmembers
         call readda (rnums,1,tname)    
         mdep = idint(rnums(1))
         if (mdep.gt.m15) call error (1,xmn(1,1),mdep,'m15')

         do i = 1, mdep
c                               nreact is returned by readr
            nreact = 0 

            call readr (coeffs,enth,inds,idim,nreact,tname)

            jdep(i) = inds(1)
            ndph(i) = nreact - 1
            if (ndph(i).gt.j4) call error (1,xmn(1,1),ndph(i),'j4')

            do j = 1, ndph(i)
               nu(i,j) = coeffs(j+1)
               idep(i,j) = inds(j+1)
            end do 

         end do 
      end if 
c                               read endmember flags:
      call readda (rnums,istot,tname)  

      do i = 1, istot
         iend(i) = idint(rnums(i))
      end do 
c                               read composition limits, subdivision type:
      m = 0

      do i = 1, isite
c                               number of ranges to be read
         m = m + isp(i) - 1
      end do 
c                               get the numbers

      l = 1

      do i = 1, isite
         
         do j = 1, isp(i) - 1

            call readda (rnums,4,tname)

            xmn(i,j) = rnums(1)
            xmx(i,j) = rnums(2)
            xnc(i,j) = rnums(3)
            imd(j,i) = idint(rnums(4))

            if (imd(j,i).eq.3) then
c                                 read extra parm
               call readda (rnums,1,tname)
               yin(j,i) = rnums(1)
            else if (imd(j,i).gt.4) then
               call error (169,rnums(1),imd(j,i),tname)
            end if 

         end do 

      end do
c                                create bragg-williams indexes
      do i = 2, isite
         ijk(i) = 1
      end do 
 
      ijk(1) = 0  

      do 20 l = 1, istot

         do m = 1, isite

            if (ijk(m).lt.isp(m)) then 

               ijk(m) = ijk(m) + 1
c                                increment only one index per endmember
               do i = 1, isite
                  jmsol(l,i) = ijk(i)
               end do 

               if (ijk(m).eq.isp(m).and.l.lt.istot-isp(1)+1) then
c                                saturated counter, increment first
c                                unsaturated counter and reset all
c                                lower site counters to first index,
                  do j = 2, isite
                     if (ijk(j).lt.isp(j)) then
                        ijk(j) = ijk(j) + 1
                        do k = 2, j-1
                           ijk(k) = 1
                        end do 
                        ijk(1) = 0
                        goto 20 
                     end if
                  end do  
               end if 

               goto 20
            end if
         end do 
20    continue 
c                              read excess function
      call readx (idim,tname)
c                              expansion for S(configurational)
      call readda (rnums,1,tname)    

      nsite = idint(rnums(1))

      if (nsite.gt.m10) call error (31,a0(1,1),isite,tname)
c                                 for each site
      do i = 1, nsite 
c                                 read # of species, and site 
c                                 multiplicty.
         call readda (rnums,2,tname) 

         smult(i) = rnums(2)
c                                 if multiplicity is 0, the model 
c                                 site has variable multiplicity 
c                                 and molar site population expressions
c                                 are read rather than site fractions
c                                 in which case we need as many expressions
c                                 as species. nspm1 is the counter for the
c                                 number of expressions
         if (smult(i).gt.0) then 
            nspm1(i) = idint(rnums(1)) - 1
         else 
            nspm1(i) = idint(rnums(1))
         end if 
c                                 for each species, read
c                                 function to define the
c                                 site fraction of the species:
c
         do j = 1, nspm1(i)
c                                 read expression for site
c                                 fraction of species j on 
c                                 site i.
            call readz (coeffs,inds,ict,idim,tname,tag)

            a0(i,j) = coeffs(1)
            nterm(i,j) = ict - 1
            if (nterm(i,j).gt.m0) call error (33,a0(1,1),m0,tname)
c                                 for each term:
            do k = 2, ict
c                                 all terms 1 order type, this
c                                 saved for compatability with 
c                                 old versions:
               nttyp(i,j,k-1)   = 1
               acoef(i,j,k-1)   = coeffs(k)
               nsub(i,j,k-1,1) = inds(k)
            end do 
         end do 
      end do 
c                              look for van laar and/or dqf parameters
c                              or the end of model marker
      call readop (idim,jlaar,istot-mdep,tname)

      if (jlaar.ne.0) then

         laar = .true.
c                                 high order terms not allowed for
c                                 van laar.
         if (iord.gt.2.and.laar) call error (999,coeffs(1),800,'RMODEL')
c                                 re-set jsmod flag only for jsmod 2
         if (jsmod.eq.2) jsmod = 3

      end if 
c                                 save original indices, need this for 
c                                 melt models etc that have species specific
c                                 equations of state.
      do i = 1, istot + norder
         iorig(i) = i 
      end do

      end 

      subroutine nmodel 
c---------------------------------------------------------------------
c nmodel - creates some counters and conversion arrays and stores
c local solution model parameters in global arrays. 
c---------------------------------------------------------------------
      implicit none
  
      include 'perplex_parameters.h'
 
      integer itic,i,j,k

      logical depend,laar,order,fluid,macro,specil,recip
      common/ cst160 /depend,laar,order,fluid,macro,specil,recip

      integer iend,isub,imd,insp,ist,isp,isite,iterm,iord,istot,jstot,
     *        kstot
      double precision wg,xmn,xmx,xnc
      common/ cst108 /wg(m1,m3),xmn(mst,msp),xmx(mst,msp),xnc(mst,msp),
     *      iend(m4),isub(m1,m2,2),imd(msp,mst),insp(m4),ist(mst),
     *      isp(mst),isite,iterm,iord,istot,jstot,kstot

      integer jmsol,kdsol
      common/ cst142 /jmsol(m4,mst),kdsol(m4)

      integer iorig,jnsp,iy2p
      common / cst159 /iorig(m4),jnsp(m4),iy2p(m4)

      integer mdep,idep,jdep,ndph
      double precision nu,y2p
      common/ cst146 /nu(m15,j4),y2p(m4,m15),mdep,jdep(m15),
     *                idep(m15,j4),ndph(m15)

      integer iddeps,norder 
      double precision depvnu,denth
      common/ cst141 /depvnu(2,j3),denth(j3),iddeps(2,j3),norder
c----------------------------------------------------------------------
c                                 make the insp arrays, 

c                                 insp orders endmembers; first independent
c                                 then dependent, last ordered species.
 
c                                 jnsp points only to independent+ordered
c                                 species (used for reciprocal solutions 
c                                 with ordering).

c                                 iy2p points from an endmember in the y
c                                 array (1..istot+norder) to the endmember
c                                 in the p array (1..kstot+norder)

      if (depend) then       

         itic = 0 

         do i = 1, istot
            if (kdsol(i).gt.0) then 
               itic = itic + 1
               insp(itic) = i 
               jnsp(itic) = i 
               iy2p(i) = itic
            end if 
         end do 

         do i = 1, mdep 
            insp(itic+i) = jdep(i)
         end do 

         do i = 1, norder 
            insp(istot+i) = istot + i
            jnsp(itic+i) = istot + i 
            iy2p(istot+i) = itic + i 
         end do 

      else 

         do i = 1, istot + norder
            insp(i) = i 
            jnsp(i) = i 
            iy2p(i) = i 
         end do 

      end if 

      if (depend) then 
c                                 make y2p array       
         do i = 1, kstot + norder 

            do j = 1, mdep

               y2p(i,j) = 0d0

               do k = 1, ndph(j)
                  if (idep(j,k).eq.jnsp(i)) y2p(i,j) = nu(j,k)
               end do 

            end do
         end do

      end if

      end 

      subroutine gphase (id,gph)
c-----------------------------------------------------------------------
c gphase computes the gibbs free energy of a compound identified by index id.
c gphase does not assume that the properties of a pseudocompound endmembers
c are known (unlike gall) it is thus less efficient than gall.
c-----------------------------------------------------------------------
      implicit none
 
      include 'perplex_parameters.h'

      integer k,id,ids

      double precision gph,gzero,dg,x0

      double precision p,t,xco2,u1,u2,tr,pr,r,ps
      common/ cst5 /p,t,xco2,u1,u2,tr,pr,r,ps

      integer ipoint,imyn
      common/ cst60 /ipoint,imyn

      integer ikp
      common/ cst61 /ikp(k1)

      integer ifp
      common/ cxt32 /ifp(k1)

      integer ixp
      double precision sxs,exces
      common/ cst304 /sxs(k13),exces(m3,k1),ixp(k1)

      integer jend
      common/ cxt23 /jend(h9,k12)
c                                 working arrays
      double precision z, pa, p0a, x, w, y
      common/ cxt7 /x(m4),y(m4),pa(m4),p0a(m4),z(mst,msp),w(m1)
c                                 new global arrays, 10/25/05:
c                                 bookkeeping variables
      integer lstot,mstot,nstot,ndep,nord
      common/ cxt25 /lstot(h9),mstot(h9),nstot(h9),ndep(h9),nord(h9)
c                                 model type
      logical lorder, lexces, llaar, lrecip
      common/ cxt27 /lorder(h9),lexces(h9),llaar(h9),lrecip(h9)
c----------------------------------------------------------------------
      ids = ikp(id)
 
      if (id.le.ipoint) then
c                                 phase is an endmember compound
         call gcpd (id,gph)

      else if (lorder(ids).and.lrecip(ids)) then 
c                                 reciprocal solution speciation model 
c                                 with nord order parameters
c                                 load x's from sxs array.                              
         do k = 1, nstot(ids) 
            p0a(k) = sxs(ixp(id)+k)
            pa(k) = p0a(k)
         end do 
c                                 compute margules coefficients
         call setw (ids)
c                                 get the speciation energy effect
         call specis (gph,ids)
c                                 get endmember dqf's
         call gexces (id,dg) 

         gph = gph + dg 
c                                 get gmech
         do k = 1, lstot(ids)
            call gcpd (jend(ids,2+k),dg)
            gph = gph + dg * p0a(k) 
         end do 

      else if (lorder(ids)) then
c                                 initialize gph and get any dqf corrections
         call gexces (id,gph)
c                                 get gmech
         do k = 1, lstot(ids)
            p0a(k) = sxs(ixp(id)+k)
            pa(k) = p0a(k)
            call gcpd (jend(ids,2+k),dg)
            gph = gph + dg*p0a(k)
         end do 
c                                 compute margules coefficients
         call setw (ids) 
c                                 get the speciation energy effect
         call specis (dg,ids)
c                                 add in entropy effect pseudocompound version
         gph = gph + dg

      else 
c                              a pseudocompound without speciation:
         if (ifp(id).eq.1) then
c                              get the excess and/or ideal mixing effect
c                              and/or dqf corrections:
            call fexces (id,gph)
c                              excess props don't include vdp:
            do k = 1, nstot(ids) 
               gph = gph + gzero(jend(ids,2+k))*sxs(ixp(id)+k)
            end do 

         else if (ifp(id).ne.27) then 
c                              get the excess and/or ideal mixing effect
c                              and/or dqf corrections:
            if (ifp(id).eq.23) then 

               call toop(id,gph)

            else if (ifp(id).eq.26) then 

               call hcneos (gph,sxs(ixp(id)+1),
     *                      sxs(ixp(id)+2),sxs(ixp(id)+3))

            else

               call gexces (id,gph)

            end if 
c                              compute mech mix G for 
c                              all models except fluid 
            do k = 1, nstot(ids) 
               call gcpd (jend(ids,2+k),dg)
               gph = gph + dg*sxs(ixp(id)+k)
            end do 

         else 

            gph = 0d0
c                              ideal gas mix (ifp(id).eq.27)
            do k = 1, nstot(ids) 
               x0 = sxs(ixp(id)+k)
               if (x0.le.0d0) cycle
               call gcpd (jend(ids,2+k),dg)
               gph = gph +  x0 *(dg + r*t*dlog(x0))
            end do 

         end if 
c                              for van laar get fancier excess function         
         if (llaar(ids)) then

            call setw(ids) 
            call gvlaar (ikp(id),id,gph)

         end if 

      end if 

      end

      double precision function dgdp (id)
c----------------------------------------------------------------------
c subroutine to compute the G derivative of solution id with respect to 
c the concentration of the 1st ordered species. assumes the excess function 
c is not higher than second order.
c----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer i,i1,i2,id

      double precision gex,dgex,dsconf,tphi,dtphi

      double precision r,v,tr,pr,ps
      common/ cst5   /v(l2),tr,pr,r,ps
c                                 working arrays
      double precision z, pa, p0a, x, w, y
      common/ cxt7 /y(m4),z(m4),pa(m4),p0a(m4),x(mst,msp),w(m1)

      double precision alpha,dt
      common/ cyt0  /alpha(m4),dt(j3)
c                                 excess energy variables
      integer jterm, jord, jsub
      common/ cxt2i /jterm(h9),jord(h9),jsub(m2,m1,h9)

      double precision dvnu,deph,dydy
      common/ cxt3r /dvnu(m4,j3,h9),deph(j3,h9),dydy(m4,j3,h9)
c                                 model type
      logical lorder, lexces, llaar, lrecip
      common/ cxt27 /lorder(h9),lexces(h9),llaar(h9),lrecip(h9)

      integer lstot,mstot,nstot,ndep,nord
      common/ cxt25 /lstot(h9),mstot(h9),nstot(h9),ndep(h9),nord(h9)
c----------------------------------------------------------------------
c                                 get derivative of excess function
      dgex = 0d0

      if (lexces(id)) then 

         if (.not.llaar(id)) then 
c                                 regular excess function
            do i = 1, jterm(id)
               i1 = jsub(1,i,id)
               i2 = jsub(2,i,id)
               dgex = dgex + w(i)*( pa(i1)*dydy(i2,1,id) 
     *                            + pa(i2)*dydy(i1,1,id))
            end do
         else 
c                                 h&p van laar
            tphi = 0d0
            dtphi = 0d0

            do i = 1, nstot(id)
               tphi = tphi + alpha(i)* y(i) 
               dtphi = dtphi + alpha(i)*dydy(i,1,id)
            end do 

            gex = 0d0 

            do i = 1, jterm(id)
c                                 assume holland powell form, all terms regular
              i1 = jsub(1,i,id)
              i2 = jsub(2,i,id)

              gex = gex + w(i) * y(i1) * y(i2)   
              dgex = dgex + w(i) * (y(i1)*dydy(i2,1,id) 
     *                            + y(i2)*dydy(i1,1,id))

            end do 
c                                note the excess energy is gex/tphi
            dgex = (dgex - dtphi*gex/tphi)/tphi

         end if 

      end if 
c                                 now get dg/dy(jd)
      dgdp = deph(1,id) + dgex - v(2)*dsconf(id)

      end

      double precision function dsconf (id)
c----------------------------------------------------------------------
c subroutine to the derivative of the configurational entropy of a 
c solution with respect to the proportion of a dependent species.

c THIS DOES NOT INCLUDE ENDMEMBER CONFIGURATION ENTROPY DERIVATIVES!
c----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer i,j,k,id

      double precision dlnz,dscon,zt,q,dzdy,z,dd
c                                 working arrays
      double precision zz, pa, p0a, x, w, y
      common/ cxt7 /zz(m4),y(m4),pa(m4),p0a(m4),x(mst,msp),w(m1)
c                                 configurational entropy variables:
      integer msite, ksp, lterm, ksub
      common/ cxt1i /msite(h9),ksp(m10,h9),lterm(m11,m10,h9),
     *               ksub(m0,m11,m10,h9)

      double precision qmult, d0, dcoef, scoef      
      common/ cxt1r /qmult(m10,h9),d0(m11,m10,h9),dcoef(m0,m11,m10,h9),
     *               scoef(m4,h9)

      double precision dppp,d2gx,sdzdp
      common/ cxt28 /dppp(j3,j3,m1,h9),d2gx(j3,j3),sdzdp(j3,m11,m10,h9)
c----------------------------------------------------------------------
      dscon = 0d0
c                                 for each site
      do i = 1, msite(id)

         zt = 0d0
         dd = 0d0 
         q = qmult(i,id)
c                                 get site fractions
         do j = 1, ksp(i,id)

            z = d0(j,i,id)
c                                 for each term:
            do k = 1, lterm(j,i,id)
               z = z + dcoef(k,j,i,id) * pa(ksub(k,j,i,id))
            end do 

            zt = zt + z
c                                 sdzdp is (dz(i,j)/dp(k))
            dzdy = sdzdp(1,j,i,id)

            if (dzdy.eq.0d0) cycle

            if (z.gt.0d0) then 
               dlnz = 1d0 + dlog(z)
            else 
c                                 the term should goto -Inf
               dlnz = 1d0
            end if 

            dscon = dscon - q * dzdy * dlnz

            dd = dd + dzdy

         end do 

         z = 1d0 - zt 

         if (z.gt.0d0) then 
            dlnz = 1d0 + dlog(z)
         else 
            dlnz = 1d0
         end if 

         dscon = dscon - q * sdzdp(1,j,i,id) * dlnz

      end do 

      dsconf = dscon

      end

      subroutine gvlaar (jd,id,dg)
c-----------------------------------------------------------------------
c gvlaar evaluates the contribution to the gibbs energy of a pseudocompound
c arising from van laar excess properties. 
c
c now redundant with function gex except gvlaar uses sxs instead of y
c
c input:
c      jd - solution pointer
c      id - compound pointer
c      dg - ideal free energy
c output:
c      dg - ideal free energy + excess energy     
c-----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer i,id,jd,i1,i2

      double precision phi(m4), tphi, dg

      integer ixp
      double precision sxs,exces
      common/ cst304 /sxs(k13),exces(m3,k1),ixp(k1)
c                                 excess energy variables
      integer jterm, jord, jsub
      common/ cxt2i /jterm(h9),jord(h9),jsub(m2,m1,h9)

      double precision z, pa, p0a, x, w, y
      common/ cxt7 /y(m4),x(m4),pa(m4),p0a(m4),z(mst,msp),w(m1)

      double precision alpha,dt
      common/ cyt0  /alpha(m4),dt(j3)

      integer lstot,mstot,nstot,ndep,nord
      common/ cxt25 /lstot(h9),mstot(h9),nstot(h9),ndep(h9),nord(h9)
c-----------------------------------------------------------------------
c                                 first compute "volumes"
      tphi = 0d0

      do i = 1, nstot(jd)


c                                 these phi's are the numerator of
c                                 holland & powells "phi's"
         phi(i) =  alpha(i)* sxs(ixp(id)+i)
c                                 tphi is the denominator of holland & powell's
c                                 phi's
         tphi = tphi + phi(i) 
      end do 
c                                 rearrange tphi
      tphi = 2d0/tphi
c                                 dg is initialized as gph in the calling 
c                                 program
      do i = 1, jterm(jd)
c                                 assume holland powell form, all terms regular
         i1 = jsub(1,i,jd)
         i2 = jsub(2,i,jd)
         dg = dg + w(i)  
     *           * tphi * phi(i1) * phi(i2) / (alpha(i1) + alpha(i2))   

      end do  

      end 

      double precision function hpmelt (im)
c----------------------------------------------------------------------
c evaluates the configurational entropy of Holland & Powell's haplogranite 
c melt model, dlnw is S/R.

c modified to use global arrays, 10/26/05.
c----------------------------------------------------------------------

      implicit none

      include 'perplex_parameters.h'

      integer i, im

      double precision dlnw, ytot, yh2o, yfo, yfa
c                                 global arrays:
      double precision t, p, xco2, u1, u2, tr, pr, r, ps
      common/ cst5   /p,t,xco2,u1,u2,tr,pr,r,ps
c                                 bookkeeping variables
      integer lstot,mstot,nstot,ndep,nord
      common/ cxt25 /lstot(h9),mstot(h9),nstot(h9),ndep(h9),nord(h9)
c                                 special model endmember indexing
      integer ispec

      common/ cxt8 /ispec(h9,m4)
c                                 working arrays
      double precision z, pa, p0a, x, w, y
      common/ cxt7 /y(m4),x(m4),pa(m4),p0a(m4),z(mst,msp),w(m1)
c----------------------------------------------------------------------  
      dlnw = 0d0

      if (ispec(im,1).eq.1) then

         yh2o = y(1)
c                                 the quadratic water term
         if (yh2o.ne.0d0) dlnw = -2d0 * yh2o * dlog(yh2o)

      else 
 
         yh2o = 0d0 

      end if 
c                                 the basic entropy
      do i = ispec(im,4), mstot(im)

         if (y(i).le.0d0) cycle
         dlnw = dlnw - y(i) * dlog(y(i)*(1d0-yh2o))
 
      end do 
c                                 the fe-mg fudge factor
      yfo = 0d0
      yfa = 0d0
      if (ispec(im,2).ne.0) yfo = y(ispec(im,2))   
      if (ispec(im,3).ne.0) yfa = y(ispec(im,3))
      ytot = yfo + yfa

      if (ytot.ne.0d0) then 
         if (yfo.ne.0d0) dlnw = dlnw - 4d0 * yfo * dlog(yfo/ytot)
         if (yfa.ne.0d0) dlnw = dlnw - 4d0 * yfa * dlog(yfa/ytot)
      end if 

      hpmelt = dlnw*r

      end 

      double precision function gmelt (im)
c----------------------------------------------------------------------
c evaluates the configurational entropy of Ghiorso's pMELTS/MELTS model, 
c dlnw is S.
c----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer i, im
      double precision dlnw, yh2o
c                                 global arrays:
      double precision t, p, xco2, u1, u2, tr, pr, r, ps
      common/ cst5   /p,t,xco2,u1,u2,tr,pr,r,ps
c                                 bookkeeping variables
      integer lstot,mstot,nstot,ndep,nord
      common/ cxt25 /lstot(h9),mstot(h9),nstot(h9),ndep(h9),nord(h9)
c                                 special model endmember indexing
      integer ispec
      common/ cxt8 /ispec(h9,m4)
c                                 working arrays
      double precision z, pa, p0a, x, w, y
      common/ cxt7 /y(m4),x(m4),pa(m4),p0a(m4),z(mst,msp),w(m1)
c----------------------------------------------------------------------
      dlnw = 0d0

      if (ispec(im,1).eq.1) then

         yh2o = y(1)
c                                 the quadratic water term, cf hp model. 
         if (yh2o.ne.0d0) dlnw = -(yh2o * dlog(yh2o) 
     *                             + (1d0-yh2o)*dlog(1d0-yh2o))
      else 

         yh2o = 0d0  
       
      end if 
c                                 i wouldn't expect to count water here yet again, but that
c                                 is what eqs 1 & 2 of Ghiorso et al. (2002) imply

c                                 in any event equation 1 in Ghiorso et al. 2002
c                                 is almost certainly wrong, so the entropy here
c                                 is computed as in ghiorso & sack 1995 (melts).
c                                 this correction made Nov 4, 2005. This model seems
c                                 to be consistent with Nicholls 1980 CMP 74:211 

c                                 the basic entropy
      do i = 1, mstot(im)

         if (y(i).le.0d0) cycle
         dlnw = dlnw - y(i) * dlog(y(i))
 
      end do 

      gmelt = r*dlnw

      end  

      double precision function slvmlt ()
c----------------------------------------------------------------------
c evaluates the configurational entropy of high T fo-fa-SiO2 melts,
c to use this model, all species (fo, fa, sio2) must be involed in the
c calculation, i.e., y1 is assumed to be fo, etc. 
c----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      double precision dlnw, yol, xmg, yq
c                                 global arrays:
      double precision t, p, xco2, u1, u2, tr, pr, r, ps
      common/ cst5   /p,t,xco2,u1,u2,tr,pr,r,ps
c                                 bookkeeping variables
      integer lstot,mstot,nstot,ndep,nord
      common/ cxt25 /lstot(h9),mstot(h9),nstot(h9),ndep(h9),nord(h9)
c                                 working arrays
      double precision z, pa, p0a, x, w, y
      common/ cxt7 /y(m4),x(m4),pa(m4),p0a(m4),z(mst,msp),w(m1)
c----------------------------------------------------------------------
      dlnw = 0d0
c                                 fraction of olivine species
      yol = y(1) + y(2)

      if (yol.ne.0d0) then 
         xmg = y(1)/yol
c                                 entropy within the olivine species
         if (xmg.ne.0d0.and.xmg.ne.1d0) dlnw = -2d0*yol*
     *                  (xmg * dlog(xmg) + (1d0-xmg)*dlog(1d0-xmg)) 
c                                 mixing of the olvine and sio2 species
         yq = 1d0 - yol
         if (yq.gt.1d-15) dlnw = dlnw - 
     *                  (yol * dlog(yol) + (yq)*dlog(yq))              

      end if 

      slvmlt = r*dlnw

      end 

      subroutine ytox (ids)
c----------------------------------------------------------------------
c subroutine to convert endmember fractions (y) to geometric coordinates 
c (x) for solution model ids.
c----------------------------------------------------------------------
      implicit none 

      include 'perplex_parameters.h'

      integer ids, i, j
c                                 convert y -> x array
      integer indx

      common/ cxt5i /indx(h9,mst,msp)
c                                 working arrays
      double precision z, pa, p0a, x, w, y

      common/ cxt7 /y(m4),z(m4),pa(m4),p0a(m4),x(mst,msp),w(m1)

c                                 x coordinate description
      integer istg, ispg, imlt, imdg

      common/ cxt6i /istg(h9),ispg(h9,mst),imlt(h9,mst),imdg(ms1,mst,h9)
c----------------------------------------------------------------------
      do i = 1, istg(ids)
c                                 this conditional is necessary
c                                 because reform can generate a 
c                                 one species site. 
         if (ispg(ids,i).gt.1) then 
c                                 initialize
            do j = 1, ispg(ids,i)
               x(i,j) = 0d0
            end do 
  
            do j = 1, ispg(ids,i)
               x(i,j) = x(i,j) + y(indx(ids,i,j))
            end do 
         else 
c                                 one species site. 
            x(i,1) = 1d0
         end if 
      end do
     
      end 

      subroutine getolx (ids,id)
c----------------------------------------------------------------------
c subroutine to recover geometric reciprocal solution compositions (x(i,j))
c from the xcoor (reciprocal) or sxs (single site) arrays loaded in soload
c----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer i, j, id, ids, jcoor
c                                 working arrays
      double precision z, pa, p0a, x, w, y
      common/ cxt7 /y(m4),z(m4),pa(m4),p0a(m4),x(mst,msp),w(m1)
c                                 x coordinate description
      integer istg, ispg, imlt, imdg
      common/ cxt6i /istg(h9),ispg(h9,mst),imlt(h9,mst),imdg(ms1,mst,h9)
c                                 stored x coordinate
      double precision xcoor
      integer icoor
      common/ cxt10 /xcoor(k18),icoor(k1)
c                                 single site solution coordinates:
      integer ixp
      double precision sxs,exces
      common/ cst304 /sxs(k13),exces(m3,k1),ixp(k1)

      integer lstot,mstot,nstot,ndep,nord
      common/ cxt25 /lstot(h9),mstot(h9),nstot(h9),ndep(h9),nord(h9)

      logical lorder, lexces, llaar, lrecip
      common/ cxt27 /lorder(h9),lexces(h9),llaar(h9),lrecip(h9)
c----------------------------------------------------------------------
      if (lrecip(ids)) then 

         jcoor = icoor(id)

         do i = 1, istg(ids)
            do j = 1, ispg(ids,i)
               jcoor = jcoor + 1
               x(i,j) = xcoor(jcoor)
            end do 
         end do 

      else 
c                                 the use if istg(ids) as the site
c                                 index is a hack for reformulated
c                                 reciprocal solutions
         if (ispg(ids,1).gt.1) then 
            i = 1
         else 
            i = 2
         end if 

         do j = 1, nstot(ids)
            x(i,j) = sxs(ixp(id)+j) 
         end do 

      end if 

      end 

      subroutine xtoy (ids)
c----------------------------------------------------------------------
c subroutine to convert geometric reciprocal solution compositions (x(i,j))
c to geometric endmember fractions (y) for solution model ids.
c----------------------------------------------------------------------
      implicit none 

      include 'perplex_parameters.h'
c                                 -------------------------------------
c                                 local variables:
      integer ids, l, m
c                                 -------------------------------------
c                                 global variables:
c                                 bookkeeping variables
      integer lstot,mstot,nstot,ndep,nord
      common/ cxt25 /lstot(h9),mstot(h9),nstot(h9),ndep(h9),nord(h9)
c                                 working arrays
      double precision z, pa, p0a, x, w, y
      common/ cxt7 /y(m4),z(m4),pa(m4),p0a(m4),x(mst,msp),w(m1)
c                                 x coordinate description
      integer istg, ispg, imlt, imdg
      common/ cxt6i /istg(h9),ispg(h9,mst),imlt(h9,mst),imdg(ms1,mst,h9)

      integer ksmod, ksite, kmsol, knsp
      common/ cxt0  /ksmod(h9),ksite(h9),kmsol(h9,m4,mst),knsp(m4,h9)
c----------------------------------------------------------------------

      do l = 1, mstot(ids)

         y(l) = 1d0

         do m = 1, istg(ids)
            y(l) = y(l)*x(m,kmsol(ids,l,m))
         end do

      end do   

      end 

      double precision function gsol1 (id)
c-----------------------------------------------------------------------
c gsol computes the total (excess+ideal) free energy of solution 
c for a solution identified by index ids and composition y(m4) input
c from cxt7, the composition y is the independent endmember fractions
c for all model types except reciprocal solutions, in which case it is 
c the y's for the full reciprocal model.

c gsol assumes the endmember g's have not been calculated by gall and is
c      only called by WERAMI.
c gsol1 is identical to gsol but can only been called after gall and is 
c      only called by VERTEX and MEEMUM. 
c-----------------------------------------------------------------------
      implicit none
 
      include 'perplex_parameters.h'

      integer k,id

      double precision omega, hpmelt, slvmlt, gmelt, gfluid, gzero, gg,
     *                 dg, gex

      integer jend
      common/ cxt23 /jend(h9,k12)

      double precision g
      common/ cst2 /g(k1)

      double precision r,tr,pr,ps,p,t,xco2,u1,u2
      common/ cst5   /p,t,xco2,u1,u2,tr,pr,r,ps
c                                 bookkeeping variables
      integer ksmod, ksite, kmsol, knsp
      common/ cxt0  /ksmod(h9),ksite(h9),kmsol(h9,m4,mst),knsp(m4,h9)

      integer lstot,mstot,nstot,ndep,nord
      common/ cxt25 /lstot(h9),mstot(h9),nstot(h9),ndep(h9),nord(h9)
c                                 working arrays
      double precision z, pa, p0a, x, w, y
      common/ cxt7 /y(m4),z(m4),pa(m4),p0a(m4),x(mst,msp),w(m1)
c                                 model type
      logical lorder, lexces, llaar, lrecip
      common/ cxt27 /lorder(h9),lexces(h9),llaar(h9),lrecip(h9)

      integer ispec
      common/ cxt8 /ispec(h9,m4)
c----------------------------------------------------------------------
         gg = 0d0
c                                 evaluate margules coefficients
         call setw (id)
c                                 evaluate dqf coefficients
         call setdqf(id)

         if (ksmod(id).eq.2.or.ksmod(id).eq.3) then 
c                                 -------------------------------------
c                                 macroscopic formulation for normal solutions.
            call gdqf (id,gg,y) 

            gg = gg - t * omega(id,y) + gex(id,y)
c                                 get mechanical mixture contribution
            do k = 1, mstot(id) 
               gg = gg + y(k) * g(jend(id,2+k))
            end do 

         else if (lrecip(id).and.lorder(id)) then 
c                                 -------------------------------------
c                                 initialize p's
            call y2p0 (id)
c                                 get the speciation, excess and entropy effects.
            call specis (gg,id)
c                                 decompose the ordered species into 
c                                 the independent disordered species
c                                 i.e., the p0a array becomes the p's if the 
c                                 abundance of the ordered species is 0.
            do k = 1, lstot(id)
c                                 compute mechanical g from these z's, 
c                                 specip adds a correction for the ordered species.
               gg = gg + g(jend(id,2+k)) * p0a(k)
            end do 
c                                 get the dqf, this assumes the independent reactants
c                                 are not dqf'd. gex not neccessary as computed in specip
            call gdqf (id,gg,p0a)

         else if (lorder(id)) then 
c                                 -------------------------------------
c                                 macroscopic formulation for ordering solutions.

c                                 get mechanical mixture contribution
            do k = 1, lstot(id)  
               pa(k) = y(k)
               p0a(k) = y(k)
               gg = gg + y(k) * g(jend(id,2+k))
            end do 
c                                 get the speciation energy effect
            call specis (dg,id)

            gg = gg + dg 
c                                 get dqf corrections
            call gdqf (id,gg,p0a) 

         else if (lrecip(id)) then 
c                                 -------------------------------------
c                                 macroscopic reciprocal solution
c                                 initialize p's
            call y2p0 (id)

            do k = 1, lstot(id)
               gg = gg + g(jend(id,2+k)) * p0a(k) 
            end do 
c                                 get the dqf, this assumes the independent reactants
c                                 are not dqf'd
            call gdqf (id,gg,p0a)

            gg = gg - t * omega(id,p0a) + gex(id,p0a)

         else if (ksmod(id).eq.23) then 

             write (*,*) 'toop samis model not coded'

         else if (ksmod(id).eq.24) then 
c                                 -------------------------------------
c                                 hp melt model         
            call gdqf (id,gg,y) 

            gg = gg - t * hpmelt(id) + gex(id,y)
c                                 get mechanical mixture contribution
            do k = 1, mstot(id)  
               gg = gg + y(k) * g(jend(id,2+k))
            end do 

         else if (ksmod(id).eq.25) then 
c                                 -------------------------------------
c                                 ghiorso pmelt model 
            call gdqf (id,gg,y) 

            gg = gg - t * gmelt(id) + gex(id,y)
c                                 get mechanical mixture contribution
            do k = 1, mstot(id)  
               gg = gg + y(k) * g(jend(id,2+k))
            end do 

         else if (ksmod(id).eq.26) then 
c                                 ------------------------------------
c                                 andreas salt model
            call hcneos (gg,y(1),y(2),y(3))

            do k = 1, 3
               gg = gg + y(k) * g(jend(id,2+k))
            end do 

         else if (ksmod(id).eq.27) then 
c                                 ------------------------------------
c                                 ideal gas
            do k = 1, mstot(id)  
               if (y(k).gt.0d0) 
     *            gg = gg + y(k) * (g(jend(id,2+k)) + r*t*dlog(y(k)))
            end do 

         else if (ksmod(id).eq.28) then 
c                                 -------------------------------------
c                                 high T fo-fa-sio2 model  
            call gdqf (id,gg,y) 

            gg = gg - t * slvmlt() + gex(id,y)
c                                 get mechanical mixture contribution
            do k = 1, mstot(id)  
               gg = gg + y(k) * g(jend(id,2+k)) 
            end do 


         else if (ksmod(id).eq.0) then 
c                                 ------------------------------------
c                                 internal fluid eos
            gg = gfluid(y(ispec(id,1)))
            
            do k = 1, 2
               gg = gg + gzero(jend(id,2+k))*y(k)
            end do 

         else 

            write (*,*) 'what the **** am i doing here?'
            stop

         end if 

      gsol1 = gg 

      end

      subroutine zchk (y,ids,bad)
c----------------------------------------------------------------------
c subroutine to site fractions computed from equations entered by 
c user for configurational entropy (macroscopic form).
c----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      logical bad, badz

      double precision y(m4),z,zt,n(m10)

      integer i,j,k,ids
c                                 configurational entropy variables:
      integer msite, ksp, lterm, ksub
      common/ cxt1i /msite(h9),ksp(m10,h9),lterm(m11,m10,h9),
     *               ksub(m0,m11,m10,h9)

      double precision qmult, d0, dcoef, scoef      
      common/ cxt1r /qmult(m10,h9),d0(m11,m10,h9),dcoef(m0,m11,m10,h9),
     *               scoef(m4,h9)
c----------------------------------------------------------------------
      bad = .false.
c                                 for each site
      do i = 1, msite(ids)

         zt = 0d0
          
         if (qmult(i,ids).ne.0d0) then 
c                                 get site fractions
            do j = 1, ksp(i,ids)

               z = d0(j,i,ids)
c                                 for each term:
               do k = 1, lterm(j,i,ids)
                  z = z + dcoef(k,j,i,ids) * y(ksub(k,j,i,ids))
               end do 

               if (badz(z)) goto 90

               zt = zt + z
            
            end do
 
            z = 1d0 - zt

            if (badz(z)) goto 90

         else if (ksp(i,ids).gt.1) then 
c                                 variable multiplicity model
            do j = 1, ksp(i,ids)
c                                 molar site population
               n(j) = d0(j,i,ids)
c                                 for each term:
               do k = 1, lterm(j,i,ids)
                  n(j) = n(j) + dcoef(k,j,i,ids) * y(ksub(k,j,i,ids))
               end do

               zt = zt + n(j)
 
            end do 

            do j = 1, ksp(i,ids)

               if (badz(n(j)/zt)) goto 90
            
            end do

         end if 

      end do 

      return

90    bad = .true.

      end

      double precision function omega (id,y)
c----------------------------------------------------------------------
c subroutine to evaluate the configurational entropy of a solution
c with composition y, including the correction for endmember 
c configurational negentropies. reciprocal end-member composition version.

c note this version doesn't evaluate ordered endmember S, this is fine
c so long as the ordered and its stoichiometrically equivalent disordered 
c endmembers have the same S (as is currently the case for HP models, 
c 10/20/05).
c----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      double precision z,zt,dlnw,dlnz,y(m4),n(m10)

      integer i,j,k,id
c                                 configurational entropy variables:
      integer msite, ksp, lterm, ksub
      common/ cxt1i /msite(h9),ksp(m10,h9),lterm(m11,m10,h9),
     *               ksub(m0,m11,m10,h9)

      double precision qmult, d0, dcoef, scoef      
      common/ cxt1r /qmult(m10,h9),d0(m11,m10,h9),dcoef(m0,m11,m10,h9),
     *               scoef(m4,h9)

      integer lstot,mstot,nstot,ndep,nord
      common/ cxt25 /lstot(h9),mstot(h9),nstot(h9),ndep(h9),nord(h9)

      double precision v,tr,pr,r,ps
      common / cst5 /v(l2),tr,pr,r,ps
c----------------------------------------------------------------------
      dlnw = 0d0
c                                 for each site
      do i = 1, msite(id)

         zt = 0d0
         dlnz = zt

         if (qmult(i,id).ne.0d0) then 
c                                 standard model with fixed site multiplicity
c                                 get site fractions
            do j = 1, ksp(i,id)
               z = d0(j,i,id) 
c                                 for each term:
               do k = 1, lterm(j,i,id)
                  z = z + dcoef(k,j,i,id) * y(ksub(k,j,i,id))
               end do 

               zt = zt + z
               if (z.gt.0d0) dlnz = dlnz - z * dlog (z)
            
            end do 

            z = 1d0 - zt
            if (z.gt.0d0) dlnz = dlnz - z * dlog(z)
            dlnw = dlnw + qmult(i,id)*dlnz
 
         else if (ksp(i,id).gt.1) then
c                                 variable site multiplicities   
c                                 get site fractions
            do j = 1, ksp(i,id)
               n(j) = d0(j,i,id) 
c                                 for each term:
               do k = 1, lterm(j,i,id)
c                                 n(j) is molar site population
                  n(j) = n(j) + dcoef(k,j,i,id) * y(ksub(k,j,i,id))
               end do 
c                                 zt is the multiplicity
               zt = zt + n(j)
            
            end do   

            do j = 1, ksp(i,id)
c                                 z is site fraction
               z = n(j)/zt
               if (z.gt.0d0) dlnz = dlnz - z * dlog(z)
            
            end do                  

            dlnw = dlnw + r*zt*dlnz

         end if 

      end do 
c                                 endmember corrections
      do i = 1, nstot(id)
         dlnw = dlnw - y(i)*scoef(i,id)
      end do 

      omega = dlnw 

      end

      subroutine snorm (id,tname)
c------------------------------------------------------------------------
c compute endmember configurational entropies
c site fractions expressed as a function of end-member proportions.
c see deleted snorm0 for bragg-williams site fraction version.
c------------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      character*10 tname

      logical bad

      integer h,id,j

      double precision omega
c                                 working arrays
      double precision z, pa, p0a, x, w, y
      common/ cxt7 /y(m4),z(m4),pa(m4),p0a(m4),x(mst,msp),w(m1)

      integer lstot,mstot,nstot,ndep,nord
      common/ cxt25 /lstot(h9),mstot(h9),nstot(h9),ndep(h9),nord(h9)

      double precision qmult, d0, dcoef, scoef      
      common/ cxt1r /qmult(m10,h9),d0(m11,m10,h9),dcoef(m0,m11,m10,h9),
     *               scoef(m4,h9)
c----------------------------------------------------------------------
c                                 get normalization constants
c                                 for each endmember
      do h = 1, nstot(id) 
c                                 zero y-array
         do j = 1, nstot(id) 
            y(j) = 0d0 
         end do

         y(h) = 1d0        
c                                 check y's
         call zchk (y,id,bad)

         if (bad) call error (125,z(1),1,tname)
c                                 evaluate S
         scoef(h,id) = omega(id,y)

      end do 

      end 

      subroutine setdqf (id)
c---------------------------------------------------------------------
c setdqf - evaluates dqf coefficients at p and t
c---------------------------------------------------------------------
      implicit none
  
      include 'perplex_parameters.h'

      integer i, id

      double precision t, p, xco2, u1, u2, tr, pr, r, ps
      common/ cst5   /p,t,xco2,u1,u2,tr,pr,r,ps
c                                 dqf corrections
      integer jndq, jdqf, iq
      double precision dqfg, dq 
      common/ cxt9 /dqfg(m3,m4,h9),dq(m4),jndq(m4,h9),jdqf(h9),iq(m4)
c----------------------------------------------------------------------

      do i = 1, jdqf(id)
c                                 index points to the endmember in the full
c                                 model:
         iq(i) = jndq(i,id)

         dq(i) = dqfg(1,i,id) + t*dqfg(2,i,id) + p*dqfg(3,i,id)
         
      end do 

      end 

      subroutine gdqf (id,g,y)
c----------------------------------------------------------------------
c subroutine to evaluate the excess G of solution id with macroscopic
c composition y. assumes a previous call to setdqf. When setdqf is 
c not called use 
c-----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer i, id
c                                 working arrays
      double precision g, y(m4)
c                                 dqf corrections
      integer jndq, jdqf, iq

      double precision dqfg, dq 

      common/ cxt9 /dqfg(m3,m4,h9),dq(m4),jndq(m4,h9),jdqf(h9),iq(m4)
c----------------------------------------------------------------------
      do i = 1, jdqf(id)

         g = g + y(iq(i))*dq(i)

      end do  

      end 

      double precision function gproj (id)
c-----------------------------------------------------------------------
c gproj computes the projected molar free energy of the
c phase with index id.
c-----------------------------------------------------------------------
      implicit none
 
      include 'perplex_parameters.h'

      integer j,id

      double precision gph

      double precision thermo,uf,us
      common/ cst1 /thermo(k4,k10),uf(2),us(h5)

      integer icomp,istct,iphct,icp
      common/ cst6 /icomp,istct,iphct,icp

      double precision cp
      common/ cst12 /cp(k5,k1)

      integer iff,idss,ifug,ifyn,isyn
      common/ cst10  /iff(2),idss(h5),ifug,ifyn,isyn

      integer ifct,idfl
      common/ cst208 /ifct,idfl

      integer ids,isct,icp1,isat,io2
      common/ cst40 /ids(h5,h6),isct(h5),icp1,isat,io2

c-----------------------------------------------------------------------
      call gphase (id,gph)
c                                 this is a screw up solution
c                                 necessary cause uf(1) and uf(2)
c                                 are allocated independent of ifct!
      if (ifct.gt.0) then 
         do j = 1, 2
            if (iff(j).ne.0) gph = gph - cp(iff(j),id)*uf(j)
          end do 
      end if 

      do j = 1, isat
         gph = gph - cp(icp+j,id) * us(j)
      end do 

      gproj = gph

      end

      subroutine setw (id)
c---------------------------------------------------------------------
c setw - evaluates margules coeffiecients and, for laar models, size
c parameters for solution model id at p and t
c---------------------------------------------------------------------
      implicit none
  
      include 'perplex_parameters.h'

      integer i, k, l, i1, i2, id

      double precision p,t,xco2,u1,u2,tr,pr,r,ps
      common/ cst5 /p,t,xco2,u1,u2,tr,pr,r,ps
c                                 excess energy variables
      integer jterm, jord, jsub
      common/ cxt2i /jterm(h9),jord(h9),jsub(m2,m1,h9)

      double precision wgl,vlar
      common/ cxt2r /wgl(m3,m1,h9),vlar(m3,m4,h9)
c                                 working arrays
      double precision z, pa, p0a, x, w, y
      common/ cxt7 /y(m4),z(m4),pa(m4),p0a(m4),x(mst,msp),w(m1)
c                                 local alpha
      double precision alpha,dt
      common/ cyt0  /alpha(m4),dt(j3)

      double precision dvnu,deph,dydy
      common/ cxt3r /dvnu(m4,j3,h9),deph(j3,h9),dydy(m4,j3,h9)
c                                 model type
      logical lorder, lexces, llaar, lrecip
      common/ cxt27 /lorder(h9),lexces(h9),llaar(h9),lrecip(h9)
c                                 bookkeeping variables
      integer lstot,mstot,nstot,ndep,nord
      common/ cxt25 /lstot(h9),mstot(h9),nstot(h9),ndep(h9),nord(h9)

      double precision dppp,d2gx,sdzdp
      common/ cxt28 /dppp(j3,j3,m1,h9),d2gx(j3,j3),sdzdp(j3,m11,m10,h9)
c----------------------------------------------------------------------
      do i = 1, jterm(id)
         w(i) = wgl(1,i,id) + t*wgl(2,i,id) + p*wgl(3,i,id)
      end do

      if (llaar(id)) then 

         do i = 1, nstot(id) 

            alpha(i) = vlar(1,i,id) 
     *               + t * vlar(2,i,id) + p * vlar(3,i,id)

         end do

         do i = 1, jterm(id)
            i1 = jsub(1,i,id)
            i2 = jsub(2,i,id)
            w(i) = 2d0 * w(i)
     *                 * alpha(i1)*alpha(i2) / (alpha(i1) + alpha(i2))
         end do

      end if 

      if (lorder(id)) then 
c                                 set higher order derivatives for 
c                                 speciation
         do k = 1, nord(id) 
            dt(k) = 0d0
            do l = 1, nord(id)
               d2gx(l,k) = 0d0
            end do  
         end do
c                                 for both laar and regular need
c                                 the d(gex)/dy(k)/dy(l)
         do i = 1, jterm(id)

            i1 = jsub(1,i,id)
            i2 = jsub(2,i,id)

            do k = 1, nord(id) 
               do l = 1, nord(id)
                  d2gx(l,k) = d2gx(l,k) + w(i) * dppp(l,k,i,id)
               end do  
            end do 
         end do


         if (llaar(id)) then 
c                                 for laar also need:
            do i = 1, nstot(id)
               do k = 1, nord(id)  
c                                 dt, derivative of sum(phi)
                  dt(k) = dt(k) + alpha(i)*dydy(i,k,id)
               end do 
            end do 

         end if 

      end if 

      end 

      double precision function gex (ids,y)
c-----------------------------------------------------------------------
c evaluate the excess function for solution model ids. assuming no prior
c call to set coefficients (as in function gexces). 
c input:
c      ids - solution pointer
c      y - composition array

c------------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer i,j,ids

      double precision y(m4), tphi, xpr

      double precision z, pa, p0a, x, w, yy
      common/ cxt7 /yy(m4),z(m4),pa(m4),p0a(m4),x(mst,msp),w(m1)
c                                 bookkeeping variables
      integer lstot,mstot,nstot,ndep,nord
      common/ cxt25 /lstot(h9),mstot(h9),nstot(h9),ndep(h9),nord(h9)
c                                 excess energy variables
      integer jterm, jord, jsub
      common/ cxt2i /jterm(h9),jord(h9),jsub(m2,m1,h9)
c                                 model type
      logical lorder, lexces, llaar, lrecip
      common/ cxt27 /lorder(h9),lexces(h9),llaar(h9),lrecip(h9)
c                                 local alpha
      double precision alpha,dt
      common/ cyt0  /alpha(m4),dt(j3)
c----------------------------------------------------------------------
      gex = 0d0 
 
      if (lexces(ids)) then 

         if (llaar(ids)) then 
c                                 holland & powells version of the van laar
c                                 first compute "volumes"
            tphi = 0d0

            do i = 1, nstot(ids)
c                                 tphi is the sum of holland & powell's
c                                 phi's
               tphi = tphi + alpha(i) * y(i)

             end do 
c                                 dg is initialized as gph in the calling 
c                                 program
            do i = 1, jterm(ids)
c                                 holland powell form, all terms regular
               gex = gex + w(i) * y(jsub(1,i,ids)) * y(jsub(2,i,ids))  

            end do 

            gex = gex/tphi 

         else 
c                                 macroscopic margules formulation by default
            do i = 1, jterm(ids)

               xpr = 1d0

               do j = 1, jord(ids)
                  if (jsub(j,i,ids).eq.0d0) exit
                  xpr = xpr * y(jsub(j,i,ids))
               end do 

               gex = gex + xpr * w(i) 

            end do  

         end if 
      end if 

      end 

      subroutine endcp (jd,id,ids)
c------------------------------------------------------------------------
c compute the composition of endmember id, for solution ids and load it
c into the jd'th position of the x3 array.
c------------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer jd, h, i, j, id, ids
c                                 bookkeeping variables
      integer lstot,mstot,nstot,ndep,nord
      common/ cxt25 /lstot(h9),mstot(h9),nstot(h9),ndep(h9),nord(h9)
c                                 x coordinate description
      integer istg, ispg, imlt, imdg
      common/ cxt6i /istg(h9),ispg(h9,mst),imlt(h9,mst),imdg(ms1,mst,h9)

      integer jend
      common/ cxt23 /jend(h9,k12)

      double precision x3
      common/ cxt16 /x3(k21,mst,msp)

      integer ksmod, ksite, kmsol, knsp
      common/ cxt0  /ksmod(h9),ksite(h9),kmsol(h9,m4,mst),knsp(m4,h9)
c----------------------------------------------------------------------
c                                 figure out which endmember we
c                                 are looking at:
      do h = 1, mstot(ids)
         if (id.eq.jend(ids,2+h)) exit
      end do          
c                                 zero x-array
      do i = 1, istg(ids)
         do j = 1, ispg(ids,i)
            x3(jd,i,j) = 0d0
         end do
c                                 now assign endmember fractions
         x3(jd,i,kmsol(ids,knsp(h,ids),i)) = 1d0 
      end do   

      end 

      subroutine gmodel (im,tname)
c---------------------------------------------------------------------
c qmodel - stores ALL solution model parameters in global arrays
c---------------------------------------------------------------------
      implicit none
  
      include 'perplex_parameters.h'

      character tname*10, sname*10

      logical add

      integer im,nloc,i,j,ind,id,jd,k,l,itic,ii,imatch, killct,
     *        killid(20)

      double precision dinc,xsym,dzt,dx

      integer ineg
      common/ cst91 /ineg(h9,m15)

      integer icomp,istct,iphct,icp
      common/ cst6  /icomp,istct,iphct,icp  

      double precision dcp,soltol
      common/ cst57 /dcp(k5,h8),soltol
                             
      integer jmsol,kdsol
      common/ cst142 /jmsol(m4,mst),kdsol(m4)

      integer jsmod
      double precision vlaar
      common/ cst221 /vlaar(m3,m4),jsmod

      integer nsub,nttyp,nterm,nspm1,nsite
      double precision acoef,smult,a0
      common/ cst107 /a0(m10,m11),acoef(m10,m11,m0),smult(m10),
     *      nsite,nspm1(m10),nterm(m10,m11),nsub(m10,m11,m0,m12),
     *      nttyp(m10,m11,m0)

      integer iend,isub,imd,insp,ist,isp,isite,iterm,iord,istot,jstot,
     *        kstot
      double precision wg,xmn,xmx,xnc
      common/ cst108 /wg(m1,m3),xmn(mst,msp),xmx(mst,msp),xnc(mst,msp),
     *      iend(m4),isub(m1,m2,2),imd(msp,mst),insp(m4),ist(mst),
     *      isp(mst),isite,iterm,iord,istot,jstot,kstot

      integer iddeps,norder 
      double precision depvnu,denth
      common/ cst141 /depvnu(2,j3),denth(j3),iddeps(2,j3),norder

      integer mdep,idep,jdep,ndph
      double precision nu,y2p
      common/ cst146 /nu(m15,j4),y2p(m4,m15),mdep,jdep(m15),
     *                idep(m15,j4),ndph(m15)

      double precision t, p, xco2, u1, u2, tr, pr, r, ps
      common/ cst5   /p,t,xco2,u1,u2,tr,pr,r,ps

      integer iorig,jnsp,iy2p
      common / cst159 /iorig(m4),jnsp(m4),iy2p(m4)

      logical depend,laar,order,fluid,macro,specil,recip
      common/ cst160 /depend,laar,order,fluid,macro,specil,recip
c                                 GLOBAL SOLUTION PARAMETERS:
      integer ksmod, ksite, kmsol, knsp
      common/ cxt0  /ksmod(h9),ksite(h9),kmsol(h9,m4,mst),knsp(m4,h9)

      integer lstot,mstot,nstot,ndep,nord
      common/ cxt25 /lstot(h9),mstot(h9),nstot(h9),ndep(h9),nord(h9)
c                                 configurational entropy variables:
      integer msite, ksp, lterm, ksub
      common/ cxt1i /msite(h9),ksp(m10,h9),lterm(m11,m10,h9),
     *               ksub(m0,m11,m10,h9)

      double precision qmult, d0, dcoef, scoef      
      common/ cxt1r /qmult(m10,h9),d0(m11,m10,h9),dcoef(m0,m11,m10,h9),
     *               scoef(m4,h9)
c                                 excess energy variables
      integer jterm, jord, jsub
      common/ cxt2i /jterm(h9),jord(h9),jsub(m2,m1,h9)

      double precision wgl,vlar
      common/ cxt2r /wgl(m3,m1,h9),vlar(m3,m4,h9)

      double precision dppp,d2gx,sdzdp
      common/ cxt28 /dppp(j3,j3,m1,h9),d2gx(j3,j3),sdzdp(j3,m11,m10,h9)

      integer ideps,icase
      common/ cxt3i /ideps(2,j3,h9),icase(h9)

      double precision dvnu,deph,dydy
      common/ cxt3r /dvnu(m4,j3,h9),deph(j3,h9),dydy(m4,j3,h9)
      
      double precision y2pg
      common/ cxt4  /y2pg(m15,m4,h9)
c                                 convert y -> x array
      integer indx
      common/ cxt5i /indx(h9,mst,msp)
c                                 endmember pointers
      integer jend
      common/ cxt23 /jend(h9,k12)
c                                 x coordinate description
      integer istg, ispg, imlt, imdg
      double precision xmng, xmxg, xncg, xmno, xmxo
      common/ cxt6r /xmng(h9,mst,msp),xmxg(h9,mst,msp),xncg(h9,mst,msp),
     *               xmno(h9,mst,msp),xmxo(h9,mst,msp)
      common/ cxt6i /istg(h9),ispg(h9,mst),imlt(h9,mst),imdg(ms1,mst,h9)
c                                 special model endmember indexing
      integer ispec
      common/ cxt8 /ispec(h9,m4)

      double precision cp
      common/ cst12 /cp(k5,k1)
c                                 dqf parameters
      integer idqf,indq
      double precision dqf
      common/ cst222 /dqf(m3,m4),indq(m4),idqf

      integer jndq, jdqf, iq
      double precision dqfg, dq 
      common/ cxt9 /dqfg(m3,m4,h9),dq(m4),jndq(m4,h9),jdqf(h9),iq(m4)

      integer iemod,kmod
      logical smod,pmod
      double precision emod
      common/ cst319 /emod(k15,k10),smod(h9),pmod(k10),iemod(k10),kmod

      integer iopt
      logical lopt
      double precision nopt
      common/ opts /nopt(i10),iopt(i10),lopt(i10)

      integer ncoor
      common/ cxt24 /ncoor(h9)

      integer isec,icopt,ifull,imsg,io3p
      common/ cst103 /isec,icopt,ifull,imsg,io3p
c                                 temporary stretching coordinate
c                                 paramters
      double precision yin
      common/ cst50 /yin(ms1,mst)
c                                 parameters for autorefine
      logical stable,limit,relax
      double precision xlo,xhi
      common/ cxt11 /xlo(m4,mst,h9),xhi(m4,mst,h9),stable(h9),limit(h9),
     *               relax(h9)

      logical refine
      common/ cxt26 /refine
c                                 interval limits conformal transformation
      integer intv
      double precision yint, yfrc
      common/ cst47 /yint(5,ms1,mst,h9),yfrc(4,ms1,mst,h9),intv(4)
c                                 model type
      logical lorder, lexces, llaar, lrecip
      common/ cxt27 /lorder(h9),lexces(h9),llaar(h9),lrecip(h9)

      integer limn,limt,limid,jimid,jimt
      double precision limc,jimc
      common/ cxt30 /limc(j6+2,j5,j3),limid(m0,j5,j3),jimid(j3,j5,j3),
     *               limn(j3),limt(j5,j3),jimc(j3,j5,j3),jimt(j5,j3)

      integer ln,lt,lid,jt,jid
      double precision lc, l0c, jc
      common/ cxt29 /lc(j6,j5,j3,h9),l0c(2,j5,j3,h9),lid(j6,j5,j3,h9),
     *               ln(j3,h9),lt(j5,j3,h9),jc(j3,j5,j3,h9),
     *               jid(j3,j5,j3,h9),jt(j5,j3,h9)

      integer ifp
      common/ cxt32 /ifp(k1)

      integer ndim,mxsp
      logical cart
      double precision scoors
      common/ cxt86 /scoors(k24),ndim(mdim),mxsp,cart(mst,h9)
c----------------------------------------------------------------------
c                                 auto_refine changes
      if (refine) then
c                                 check for consistent auto-refine data
         read (n10,'(a)') sname
         if (tname.ne.sname) call error (63,r,i,'GMODEL')

      end if 
c                                 initialize autorefine arrays
      stable(im) = .false.
      limit(im) = .false.
      relax(im) = .true.

      do i = 1, isite 
c                                 cart is a flag indicating whether the 
c                                 subdivision schem for site i is truly
c                                 cartesian
         cart(i,im) = .true.

         do j = 1, isp(i) - 1

            xlo(j,i,im) = 1d0
            xhi(j,i,im) = 0d0

         end do 
      end do  
c                                 initialize compositional distances
      do i = 1, icp
         dcp(i,im) = 0d0
      end do 
c                                 endmember counters:
      if (im.gt.h9) call error (52,dq(1),idqf,'GMODEL')
c                                 number of endmembers
      mstot(im) = istot
c                                 number of independent + ordered endmebers
      nstot(im) = kstot + norder 
c                                 number of independent disordered endmembers
      lstot(im) = kstot 
c                                 chemical mixing sites
      istg(im) = isite
c                                 number of ordered species
      nord(im) = norder 
c                                 number of species and multiplicity and
c                                 site ranges
      ncoor(im) = 0 

      do i = 1, isite 

         ispg(im,i) = isp(i)
         imlt(im,i) = ist(i)
         ncoor(im) = ncoor(im) + isp(i)

         do j = 1, isp(i) - 1
c                                 subdivision override (iopt(13))
            if (iopt(13).eq.1) then
c                                 make linear
               imd(j,i) = 0

            else if (iopt(13).eq.2) then 
c                                 make all stretch (if not already)
               if (imd(j,i).eq.0) imd(j,i) = 2

            end if 
          
           if (nopt(13).gt.0d0.and.icopt.le.3) then 
c                                 use default initial resolution, perturbed
c                                 by a per-mil scale increment to reduce 
c                                 compositional degeneracies. 
               xnc(i,j) = (1d0 + nopt(15)*float(im-5)) * nopt(13)
            else if (nopt(13).gt.0d0) then 
               xnc(i,j) = nopt(13)
            end if 
c                                 save solution model values as hard limits for 
            xmno(im,i,j) = xmn(i,j)
            xmxo(im,i,j) = xmx(i,j)
c                                 ------------------------------------
c                                 auto_refine segment
            if (refine) then 
c                                 new values from autorefine file
               read (n10,*) xmn(i,j),xmx(i,j)

               if (icopt.lt.4) then 
c                                 set slop to the initial spacing
                  dinc = xnc(i,j)
                
                  if (icopt.eq.1) then
c                                 Schreinemakers use refine factor III
                     xnc(i,j) = xnc(i,j)/nopt(17)
                  else  
c                                 non-adaptive use refine factor II
                     xnc(i,j) = xnc(i,j)/nopt(17)
                  end if 

               else 
c                                 use fractional slop, with a minimum 
c                                 corresponding to the initial compositional
c                                 resolution
                  dinc = nopt(10)/1d1 + (xmx(i,j) - xmn(i,j)) * nopt(3)
c                                 adaptive use refine factor I
                  xnc(i,j) = xnc(i,j)/nopt(17) 

               end if 

               if (xmn(i,j).eq.xmx(i,j)) then 

                  if (xmx(i,j).eq.0d0) then 

                     xmx(i,j) = xmx(i,j) + dinc

                  else if (xmx(i,j).eq.1d0) then 

                     xmn(i,j) = xmn(i,j) - dinc

                  else 

                     xmn(i,j) = xmn(i,j) - dinc
                     if (xmn(i,j).lt.0d0) xmn(i,j) = 0d0
                     xmx(i,j) = xmx(i,j) + dinc
                     if (xmn(i,j).lt.0d0) xmn(i,j) = 0d0

                  end if 
               end if 
            end if 
c                                 -------------------------------------
c                                 stretching stuff
            if (imd(j,i).gt.0) then 

               cart(i,im) = .false.
c                                 check for old subdivision schemes
               if (imd(j,i).gt.0) then
                  if (xnc(i,j).le.0d0.or.xnc(i,j).gt.1d0)
     *               call error (62,nopt(13),imd(j,i),tname)
               end if

               xsym = (xmxo(im,i,j)+xmno(im,i,j))/2d0

               dinc = xmx(i,j) - xmn(i,j)
c                                 rescale the increment if the limits 
c                                 are reduced
               xnc(i,j) = xnc(i,j)/(xmxo(im,i,j) - xmno(im,i,j))
c                                 get the intervals
               yint(1,j,i,im) = xmn(i,j)    
   
               if (imd(j,i).eq.1.or.imd(j,i).eq.4) then 
c                                 one interval
                  yfrc(1,j,i,im) = 1d0

                  yint(2,j,i,im) = xmx(i,j)

               else if (imd(j,i).eq.2.and.(.not.refine)) then 
c                                 two intervals, symmetry 
c                                 at (xmx(i,j) + xmn(i,j))/2d0.
                  yfrc(1,j,i,im) = (xsym-xmno(im,i,j))/dinc
                  yfrc(2,j,i,im) = 1d0 - yfrc(1,j,i,im)

                  yint(2,j,i,im) = xsym                 
                  yint(3,j,i,im) = xmx(i,j)

               else if (imd(j,i).eq.2) then 
c                                 in autorefine cycle, check if limits 
c                                 are on one-side of original symmetry 
c                                 axis:
                  if (xmx(i,j).le.xsym) then 
c                                 change to assymetric stretch toward xmax
                     imd(j,i) = 1
                     yfrc(1,j,i,im) = 1d0
                     yint(2,j,i,im) = xmx(i,j)

                  else if (xmn(i,j).ge.xsym) then 
c                                 change to assymetric stretch toward xmin
                     imd(j,i) = 4
                     yfrc(1,j,i,im) = 1d0
                     yint(2,j,i,im) = xmx(i,j)

                  else 
c                                 compositions span axis, recompute 
c                                 fractional lengths of intervals:
c                                 modified from:
c                    yfrc(1,j,i,im) = (xsym-xmno(im,i,j))/dinc
c                    yfrc(2,j,i,im) = 1d0 - yfrc(1,j,i,im)  
c                                 10/20/08

                     yfrc(1,j,i,im) =(xsym-xmn(i,j))/(xsym-xmno(im,i,j))
                     yfrc(2,j,i,im) =(xmx(i,j)-xsym)/(xmxo(im,i,j)-xsym) 
 
                     yint(2,j,i,im) = xsym          
                     yint(3,j,i,im) = xmx(i,j)                     

                  end if 

               else 
c                                 four intervals
                  yint(3,j,i,im) = yin(ms1,mst)
                  yint(5,j,i,im) = xmx(i,j)
                  yint(2,j,i,im) = (yint(1,j,i,im)+yint(3,j,i,im))/2d0
                  yint(4,j,i,im) = (yint(5,j,i,im)+yint(3,j,i,im))/2d0

                  yfrc(1,j,i,im) = (yint(3,j,i,im)-yint(1,j,i,im))/2d0
                  yfrc(2,j,i,im) = yfrc(1,j,i,im) 
                  yfrc(3,j,i,im) = (yint(5,j,i,im)-yint(3,j,i,im))/2d0
                  yfrc(4,j,i,im) = yfrc(3,j,i,im)

               end if 
            end if 

            imdg(j,i,im) = imd(j,i)
            xmng(im,i,j) = xmn(i,j)
            xmxg(im,i,j) = xmx(i,j)
            xncg(im,i,j) = xnc(i,j)

         end do 
c                                 if pure cartesian, save maximum dimension
         if (cart(i,im).and.isp(i)-1.gt.mxsp) mxsp = isp(i) - 1

      end do 
c                                 -------------------------------------
c                                 classify the model
      ksmod(im) = jsmod
c                                 -------------------------------------
c                                 save the excess terms.                              
      jterm(im) = iterm
      jord(im) = iord

      do i = 1, iterm 
         do j = 1, m3
            wgl(j,i,im) = wg(i,j)
         end do 

         do j = 1, iord
c                                 isub points to the position in the list
c                                 of endmembers potentially including dependent 
c                                 species. use iy2p to convert to independent
c                                 endmember pointers.
            if (isub(i,j,1).eq.0) then 
               jsub(j,i,im) = 0 
            else 
               jsub(j,i,im) = iy2p(isub(i,j,1))
            end if 

         end do 
      end do 
c                                 ----------------------------------------------
c                                 configurational entropy models

c                                 site fractions as a function of bulk
c                                 y's and dependent species y:
      nloc = 0

      do i = 1, nsite 
c                                 eliminate sites with 1 species
         if (nspm1(i).eq.0) cycle 

         nloc = nloc + 1
c                                 # of species, and site r*multiplicty.
         qmult(nloc,im) = r*smult(i)
         ksp(nloc,im) = nspm1(i) 
c                                 for each species, read
c                                 function to define the
c                                 site fraction of the species:
         do j = 1, nspm1(i)
c                                 # of terms in the 
c                                 site fraction function and a0.
            lterm(j,nloc,im) = nterm(i,j)
            d0(j,nloc,im) = a0(i,j)
c                                 for each term:
            do k = 1, nterm(i,j)
c                                 term coefficient amd species index:
               dcoef(k,j,nloc,im) = acoef(i,j,k) 
               ksub(k,j,nloc,im) = nsub(i,j,k,1)

            end do 
         end do
      end do  
c                                 number of distinct identisites for entropy
      msite(im) = nloc

      do i = 1, mstot(im) + nord(im)
c                                 insp points to the original position 
c                                 of endmember i in the solution model input:
         knsp(i,im) = insp(i)

      end do 
c                                 -------------------------------------
c                                 kmsol points to the species on the j'th site
c                                 of the i'th endmember, used for the xtoy
c                                 conversion      
      do i = 1, mstot(im)
         do j = 1, isite
            kmsol(im,i,j) = jmsol(i,j)
         end do 
      end do 
c                                 --------------------------------------
c                                 van laar volumes, and pointers for "in" endmembers
      do i = 1, nstot(im)
c                                 if the solution is van laar save
c                                 the "volume" function.
         if (laar) then  
            do l = 1, m3
               vlar(l,i,im) = vlaar(l,jnsp(i))
            end do 
         end if 
c                                 initialize scoef's to zero for config 
c                                 entropy calculation (done by snorm).
         scoef(i,im) = 0d0

      end do   
c                                 -------------------------------------
      if (depend) then 
c                                 save y -> p array 
         ndep(im) = mdep

         do i = 1, nstot(im)
            do j = 1, mdep

               y2pg(j,i,im) = y2p(i,j)
               if (jsmod.eq.5.and.y2p(i,j).lt.0d0) 
     *                                         ineg(im,j) = knsp(i,im)

            end do
         end do
c                                 for reasons of stupidity, convert the z(y) 
c                                 expressions to z(p). 
         call y2p4z (im)

      end if 
c                                 -------------------------------------
c                                 dqf parameters
      jdqf(im) = idqf

      do i = 1, idqf 
c                                 shift pointer from y array to p array
         jndq(i,im) = iy2p(indq(i))
         do j = 1, m3
            dqfg(j,i,im) = dqf(j,i)
         end do 
      end do 
c                                 -------------------------------------
c                                 if nsite ne 0 get "normalization" constants (endmember
c                                 configurational entropies) for entropy model:
      if (nsite.ne.0) call snorm (im,tname)
c                                 -------------------------------------
      if (order) then 
c                                 models with speciation: 
         do j = 1, norder 

            deph(j,im) = denth(j) 

            do i = 1, 2
               ideps(i,j,im) = iy2p(iddeps(i,j))
            end do 
c                                 stoichiometric limits on ordered species
            if (limn(j).gt.0) then

               ln(j,im) = limn(j)
 
               do k = 1, limn(j)
c                                 for each limit, number of p0 terms
                  lt(k,j,im) = limt(k,j)

                  do i = 1, limt(k,j)
c                                 for each p0 term
                     lc(i,k,j,im) = limc(i,k,j)
c                                 convert index from y to p pointer and save
                     lid(i,k,j,im) = iy2p(limid(i,k,j))

                  end do 
c                                 the constant and delta
                  l0c(1,k,j,im) = limc(i,k,j)
                  l0c(2,k,j,im) = limc(i+1,k,j)
c                                 and the number of p terms...
                  jt(k,j,im) = jimt(k,j)

                  do i = 1, jimt(k,j)
c                                 for each p0 term
                     jc(i,k,j,im) = jimc(i,k,j)
c                                 convert index from y to p pointer and save
                     jid(i,k,j,im) = iy2p(jimid(i,k,j))

                  end do 

               end do 

            end if 

         end do 
c                                 classify multiple species models according
c                                 to whether the disordered reactants are 
c                                 partially or completely correlated, assume
c                                 anti-correlation and no correlation are not 
c                                 possible cases.
         icase(im) = 0

         if (norder.gt.1) then 

            imatch = 0

            do j = 1, 2 

               id = ideps(j,1,im)
     
               do i = 1, 2          
                  if (id.eq.ideps(i,2,im)) then
                     imatch = imatch + 1
                     exit
                  end if 
               end do 

            end do 
 
            if (imatch.eq.1) then 
c                                 if match = 1 one species didn't match
c                                 assume partial correlation
               icase(im) = 2
            else if (imatch.eq.2) then 
               icase(im) = 1
            end if 

         end if  
c                                first create derivatives of endmember
c                                fractions with respect to the ordered
c                                species:
         do j = 1, norder 

            do i = 1, nstot(im)
               dydy(i,j,im) = 0d0
            end do
c                                derivative of the ordered species with
c                                respect to itself:
            dydy(kstot+j,j,im) = 1d0
c                                each ordered species decomposes to
c                                two disordered species iddeps(1-2,j)
c                                depvnu is the stoichiometric coefficient
c                                of the disordered species in the ordered
c                                species.

c                                derivatives of the consituent species 
c                                with respect to the ordered species
            do i = 1, 2
               dydy(ideps(i,j,im),j,im) = dydy(ideps(i,j,im),j,im) 
     *                                  - depvnu(i,j)
            end do

         end do 
c                                evaluate the second derivative of each
c                                pi*pj term in the excess function with
c                                respect to kth species
         do i = 1, iterm 
            do j = 1, norder
               do k = 1, norder

                  dppp(k,j,i,im) =  dydy(jsub(1,i,im),k,im)
     *                             *dydy(jsub(2,i,im),j,im)
     *                           + 
     *                              dydy(jsub(2,i,im),k,im)
     *                             *dydy(jsub(1,i,im),j,im)  
               end do                     
            end do 
         end do 

         if (depend) then 
c                                make an array to get the the fractions
c                                of the disordered species in the ordered
c                                species. this is essentially identical to 
c                                the dydy array formed above.                                 
            do i = 1, kstot

               do k = 1, norder

                  dvnu(i,k,im) = 0d0

                  do j = 1, 2
                     if (i.ne.ideps(j,k,im)) cycle
                     dvnu(i,k,im) = dvnu(i,k,im) + depvnu(j,k)
                  end do

               end do  
            end do  

         end if
c                                 site fractions as a function of bulk
c                                 y's and dependent species y:
         do i = 1, msite(im)
c                                 for each species, read
c                                 function to define the
c                                 site fraction of the species:
            do k = 1, norder
               sdzdp(k,ksp(i,im)+1,i,im) = 0d0 
            end do 

            do j = 1, ksp(i,im)
c                                 # of terms in the 
c                                 site fraction function and a0.
               do l = 1, norder
                  sdzdp(l,j,i,im) = 0d0
               end do 
c                                 for each term:
               do k = 1, lterm(j,i,im)
c                                 endmember indexes  
                  ind = ksub(k,j,i,im) 
c                                 get derivatives, of species fractions
c                                 with respect to ordered species
                  do l = 1, norder 
                     itic = 0 
                     do ii = 1, 2
                        if (ind.eq.ideps(ii,l,im)) then
                           sdzdp(l,j,i,im) = sdzdp(l,j,i,im) 
     *                     + dydy(ideps(ii,l,im),l,im)*dcoef(k,j,i,im)  
                           itic = itic + 1
c                                 high order terms not allowed
                           if (itic.gt.1) 
     *                        call error (999,r,801,'GMODEL')
                        end if                       
                     end do
c                                 the derivative of a term with the 
c                                 ordered species.
                     if (ind.eq.kstot+l) 
     *                  sdzdp(l,j,i,im) = sdzdp(l,j,i,im) 
     *                                  + dcoef(k,j,i,im) 

                  end do   
               end do 
            end do 
         end do
c                                 multiply each dzdp by qmult (R*site
c                                 multiplicity) to reduce operation 
c                                 count in evaluating derivatives. 
         do k = 1, norder 
            do i = 1, nsite 

               dzt = 0d0 

               do j = 1, ksp(i,im) 
                  if (dabs(sdzdp(k,j,i,im)).lt.1d-5) 
     *                     sdzdp(k,j,i,im) = 0d0
                  dzt = dzt + sdzdp(k,j,i,im)
               end do 

               if (dabs(dzt).lt.1d-5) dzt = 0d0
               sdzdp(k,j,i,im) = -dzt

            end do 
         end do 

      end if 
c                                 ----------------------------------------------
c                                 models with special endmember indexing:  
      if (jsmod.eq.24.or.jsmod.eq.25) then 
c                                 hp & ghiroso models:
         do i = 1, 3
            ispec(im,i) = 0 
         end do 
c                                 set start index assuming no water:
         ispec(im,4) = 1  

         if (iorig(1).eq.1) then 
c                                 h2o is present:
            ispec(im,1) = 1
c                                 set start index to avoid h2o:
            ispec(im,4) = 2
            if (iorig(2).eq.2) then
               ispec(im,2) = 2
               if (iorig(3).eq.3) ispec(im,3) = 3
            else if (iorig(2).eq.3) then 
               ispec(im,3) = 2
            end if 
         else if (iorig(1).eq.2) then
c                                 h2o absent, fo (in hp) is first endmember
            ispec(im,2) = 1
            if (iorig(2).eq.3) ispec(im,3) = 2
         else if (iorig(1).eq.3) then 
c                                 h2o and fo absent, fa (in hp) is first endmember
            ispec(im,3) = 1
         end if     

      else if (jsmod.eq.0) then
c                                 fluid eos, make pointer to co2
         do i = 1, 2
            id = kdsol(insp(i))
            if (cp(2,id).ne.0d0) then
               ispec(im,1) = i
               exit
            end if 
         end do 

      end if 
c                                 -------------------------------------
c                                 create a y -> x array, this array is 
c                                 to be used to convert endmember fractions (y's)
c                                 back to geometric coordinates (x's).
      do i = 1, isite
         do j = 1, isp(i)
c                                 now find all endmembers with
c                                 species j on site i, this method
c                                 is inefficient but idependent of
c                                 endmember order.   
            do k = 1, istot
               if (jmsol(k,i).eq.j) indx(im,i,j) = k
            end do 
         end do 
      end do 
      
      if (istot+norder.gt.k12) call error (39,0d0,k12,'INPUT9')    

      smod(im) = .true.
      pmod(im) = .true.

      do i = 1, kstot
c                                 pointer to endmember
         id = kdsol(insp(i))
c                                 figure out the compositional distance between
c                                 the endmembers, this is used to scale the solvus
c                                 tolerance
         do j = i+1, kstot

            jd = kdsol(insp(j))
c                                 

            do k = 1, icp
               dx = dabs(cp(k,id) - cp(k,jd))
               if (dcp(k,im).lt.dx) dcp(k,im) = dx
            end do 

         end do 
c                                 set ifp for melt endmembers
         if (ifp(id).le.0.and.(jsmod.eq.24.or.jsmod.eq.25)) then
            ifp(id) = -jsmod
         end if 
c
         jend(im,2+i) = id
c                                 set shear/bulk moduli flags
         if (iemod(id).eq.0) smod(im) = .false.
         if (iemod(id).lt.2) pmod(im) = .false.
c                                 look for endmembers to be killed
         if (iend(insp(i)).ne.2) cycle

         add = .true. 

         do j = 1, killct

            if (killid(j).eq.id) then
               add = .false.
               exit
            end if 
         end do 

         if (add) then 

            killct = killct + 1
            if (killct.gt.10) call error (999,wg(1,1),killct,tname)
            killid(killct) = id

         end if 

      end do 
c                                 this looks like bad news, for laar/recip
c                                 or laar/order, but appears to be overridden
c                                 by use of logical classification variables,
c                                 in which case, why is it here????
      if (laar.and.ksmod(im).ne.3) ksmod(im) = 7 

      if (laar.and.iterm.eq.0) then 
          if (ksmod(im).eq.3) ksmod(im) = 2
          laar = .false.
      end if 
c                                 set type flags, presently no provision for 
c                                 bw summation
      llaar(im) = .false.
      lexces(im) = .false.
      lorder(im) = .false.
      lrecip(im) = .false.
      
      if (iterm.gt.0) then 
         lexces(im) = .true.
         if (laar) llaar(im) = .true.
      end if 

      if (order) lorder(im) = .true.
c                                 the ksmod(im) test is made because
c                                 reform may dump the dependent endmembers
c                                 setting depend = .false., while retaining
c                                 a dummy site with no mixing. reform should
c                                 be redone to truly reformulate multiple
c                                 models to single site models. 
      if (depend.or.ksmod(im).eq.7) lrecip(im) = .true. 

      if (.not.lopt(3)) then 
c                                 hard limits are off, set limits to 0/1
         do i = 1, isite 
            do j = 1, isp(i) - 1

               xmxo(im,i,j) = 1d0
               xmno(im,i,j) = 0d0

            end do 
         end do
      end if   

      end 

      double precision function strtch (y)
c----------------------------------------------------------------------
c get the x-value from the unstretched coordinate y
c----------------------------------------------------------------------
      implicit none

      double precision y, t

      double precision bp1,bm1,bpm,lbpm
      common/ cst46 /bp1,bm1,bpm,lbpm

      t = bpm**(1d0-y)

      strtch = (bp1 - bm1*t)/(1d0 + t)

      end 

      double precision function unstch (x)
c----------------------------------------------------------------------
c get the y-value from the stretched coordinate x
c----------------------------------------------------------------------
      implicit none

      double precision x

      double precision bp1,bm1,bpm,lbpm
      common/ cst46 /bp1,bm1,bpm,lbpm

      unstch = 1d0 - dlog((bp1-x)/(bm1+x))/lbpm

      end 

      double precision function ydinc (y,xinc,mode,i,ksite,ids)
c----------------------------------------------------------------------
c get the new value of the stretched coordinate (y) from an
c increment in the cartesian coordinate (xinc)
c----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer ids, i, j, mode, ksite

      double precision x, xinc, strtch, yreal, yloc, unstch, dy, ylmn,
     *                 ylmx, y
    
      logical odd
c                                 interval limits conformal transformation
      integer intv
      double precision yint, yfrc
      common/ cst47 /yint(5,ms1,mst,h9),yfrc(4,ms1,mst,h9),intv(4)
c----------------------------------------------------------------------
c                                 y is the real coordinate.
      if (mode.lt.4) then 
         odd = .false.
      else
         odd = .true. 
      end if 
c                                 there are as many as intv(mode)
c                                 intervals to cycle through
      do j = 1, intv(mode)
c                                 odd or even interval?
         odd = .not.odd
c                                 interval limits              
         ylmx = yint(j+1,i,ksite,ids)
c                                 which interval are we starting from?
         if (y.gt.ylmx) cycle

         ylmn = yint(j,i,ksite,ids)
         dy = ylmx - ylmn
c                                 the current value is in interval j
c                                 convert to raw y (varies from 0 ->1 
c                                 over the local interval)
         if (dy.ne.0d0) then 
            yloc = (y-ylmn) / dy
         else 
            yloc = y 
         end if 
c                                 convert to cartesian x and add increment

         if (odd) then 
            x = unstch(yloc) + xinc/yfrc(j,i,ksite,ids)
         else
            x = 1d0 - unstch(1d0-yloc) + xinc/yfrc(j,i,ksite,ids)
         end if 

         if (x.gt.1d0) then
c                                 jumped to next interval
            if (j.lt.intv(mode)) then
c                                 add the residual (opposite odd)
               x = (x - 1d0)*yfrc(j,i,ksite,ids)/yfrc(j+1,i,ksite,ids)
               ylmn = ylmx
               ylmx = yint(j+2,i,ksite,ids)
               dy = ylmx - ylmn

               if (odd) then 
                  yreal = ylmx - strtch(1d0-x) * dy
               else
                  yreal = ylmx + strtch(x) * dy 
               end if 
            else 
               yreal = ylmx
            end if 

         else if (x.ge.0d0) then
c                                 within interval j
            if (odd) then 
               yreal = ylmn + strtch(x) * dy 
            else
               yreal = ylmx - strtch(1d0-x) * dy 
            end if               

         else
c                                 jumped to an earlier interval
            if (j.gt.1) then
c                                 add the residual (opposite odd)
               x = (x + 1d0)*yfrc(j,i,ksite,ids)/yfrc(j-1,i,ksite,ids)
               ylmx = ylmn
               ylmn = yint(j-1,i,ksite,ids)
               dy = ylmx - ylmn

               if (odd) then 
                  yreal = ylmx - strtch(1d0-x) * dy
               else
                  yreal = ylmn + strtch(x) * dy 
               end if 
            else 
               yreal = ylmn
            end if 
         end if

         exit 
 
      end do 

      ydinc = yreal 
         
      end 

      subroutine factor (a,n,ipvt,ier)
c-----------------------------------------------------------------------
c factor is a subroutine which calculates the triangular
c decompositions of the matrix 'a'. factor is modified from
c the subroutine of the same name given by conte and de boor
c in 'elementary numerical analysis', mcgraw-hill, 1980.
c factor uses scaled partial pivoting.
c
c input     a- an n by n array containing the elements of matrix a.
c           n- the dimension of the matrix a.
c output    a- an n by n array containing the upper, u, and lower, l,
c              triangular decompositions of input matrix a.
c        ipvt- a vector indicating that row ipvt(k) was used to
c              eliminate the a(n,k).
c         ier- a flag, zero if a is of rank = n, and 1 if a is of
c              lower rank.
c-----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

     
      double precision a(k8,k8),d(k8),rmax,tmax,temp,ratio

      integer ipvt(k8),i,j,k,ier,ip1,n,istr,nm1
c-----------------------------------------------------------------------
      ier = 0
c                            initialize ipvt,d
      do i = 1, n
         ipvt(i) = i
         rmax = 0d0
         do j = 1, n
            rmax = dmax1(rmax,dabs(a(i,j)))
         end do 
c                            ax = b is singular if rmax = 0
         if (dabs(rmax).lt.1d-5) goto 9000
         d(i) = rmax
      end do 
c                            begin decomposition: 
      nm1 = n-1
c
      do i = 1, nm1
         ip1 = i+1
c                            determine pivot row (istr).
         rmax = dabs(a(i,i))/d(i)
         istr = i
         do j = ip1, n
            tmax = dabs(a(j,i))/d(j)
            if (tmax.gt.rmax) then
               rmax = tmax
               istr = j
            end if 
         end do

         if (dabs(rmax).lt.1d-5) goto 9000
c                            if istr gt i, make i the pivot row
c                            by interchanging it with row istr.
         if (istr.gt.i) then 
            j = ipvt(istr)
            ipvt(istr) = ipvt(i)
            ipvt(i) = j
            temp = d(istr)
            d(istr) = d(i)
            d(i) = temp

            do j = 1, n
               temp = a(istr,j)
               a(istr,j) = a(i,j)
               a(i,j) = temp
            end do 
         end if 
c                            eliminate x(k) from rows k+1,...,n.
         do j = ip1,n
         a(j,i) = a(j,i)/a(i,i)
         ratio = a(j,i)
            do k = ip1,n
               a(j,k) = a(j,k)-ratio*a(i,k)
            end do 
         end do
      end do 

      if (dabs(a(n,n)).lt.1d-5) ier = 1

      return
c                           algoritmic singularity.
9000  ier = 1
 
      end

      subroutine y2p0 (id)
c-----------------------------------------------------------------------
c y2p0 converts the y array of disordered dependent and independent 
c species abundance to the p0 array of the independent (ordered and 
c disordered) species. the p0 array gives the minimum possible 
c concentrations of the ordered species (the stable abundances are 
c determined by solving the speciation problem). 

c for non-reciprocal solutions the y and p0 arrays are identical.
c-----------------------------------------------------------------------
      implicit none
 
      include 'perplex_parameters.h'

      integer id,k,l

      double precision y2pg
      common/ cxt4  /y2pg(m15,m4,h9)

      double precision z, pa, p0a, x, w, y
      common/ cxt7 /y(m4),z(m4),pa(m4),p0a(m4),x(mst,msp),w(m1)

      integer lstot,mstot,nstot,ndep,nord
      common/ cxt25 /lstot(h9),mstot(h9),nstot(h9),ndep(h9),nord(h9)

      integer ksmod, ksite, kmsol, knsp
      common/ cxt0  /ksmod(h9),ksite(h9),kmsol(h9,m4,mst),knsp(m4,h9)
c-----------------------------------------------------------------------
c                                 convert y's to p's
c                                 initialize ordered species
      do k = 1, nord(id)
         p0a(lstot(id)+k) = 0d0
      end do        

      do k = 1, nstot(id)
c                                 initialize the independent species
c                                 other then the ordered species
         if (k.le.lstot(id)) p0a(k) =  y(knsp(k,id))
c                                 convert the dependent species to
c                                 idependent species
         do l = 1, ndep(id)
            p0a(k) = p0a(k) + y2pg(l,k,id) * y(knsp(lstot(id)+l,id))
         end do 

         pa(k) = p0a(k)

      end do

      end 

      subroutine p0dord (id)
c-----------------------------------------------------------------------
c decomposes p0a values that specify the abundances of independent 
c ordered endmembers to their stoichiometric equivalent disordered
c species. 
c-----------------------------------------------------------------------
      implicit none
 
      include 'perplex_parameters.h'

      integer id,k,l,ind 

      double precision dvnu,deph,dydy
      common/ cxt3r /dvnu(m4,j3,h9),deph(j3,h9),dydy(m4,j3,h9)

      integer ideps,icase
      common/ cxt3i /ideps(2,j3,h9),icase(h9)

      double precision z, pa, p0a, x, w, y
      common/ cxt7 /y(m4),z(m4),pa(m4),p0a(m4),x(mst,msp),w(m1)

      integer lstot,mstot,nstot,ndep,nord
      common/ cxt25 /lstot(h9),mstot(h9),nstot(h9),ndep(h9),nord(h9)
c-----------------------------------------------------------------------

      do k = 1, nord(id)
         do l = 1, 2
            ind = ideps(l,k,id)
            p0a(ind) = p0a(ind) + dvnu(ind,k,id) * p0a(lstot(id)+k)
         end do 
      end do 

      end 

      subroutine y2p4z (id)
c----------------------------------------------------------------------
c subroutine to convert site fraction expressions in terms of 
c y's to p's, this conversion consists simply of eliminating 
c the dependent endmembers and coverting the pointer array 
c jsub is changed from a pointer to the y array to a pointer
c to the p array.

c the reason for writing z(y) is it is a more intuitive input,
c i.e., users do not have to understand the distinction between
c dependent and independent endmembers.
c----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      double precision ncoef(m0)

      integer i,j,k,id,ind,jconv,mterm(m0)
c                                 -------------------------------------
      integer msite, ksp, lterm, ksub
      common/ cxt1i /msite(h9),ksp(m10,h9),lterm(m11,m10,h9),
     *               ksub(m0,m11,m10,h9)

      double precision qmult, d0, dcoef, scoef      
      common/ cxt1r /qmult(m10,h9),d0(m11,m10,h9),dcoef(m0,m11,m10,h9),
     *               scoef(m4,h9)

      integer lstot,mstot,nstot,ndep,nord
      common/ cxt25 /lstot(h9),mstot(h9),nstot(h9),ndep(h9),nord(h9)

      integer jmsol,kdsol
      common/ cst142 /jmsol(m4,mst),kdsol(m4)

      integer iorig,jnsp,iy2p
      common / cst159 /iorig(m4),jnsp(m4),iy2p(m4)
c----------------------------------------------------------------------
c                                 for each site
      do i = 1, msite(id)
c                                 for each species
         do j = 1, ksp(i,id)
 
            jconv = 0 

            do k = 1, lterm(j,i,id)

               ind = ksub(k,j,i,id)

               if (kdsol(ind).ne.-2) then
c                                 index points to an independent endmember
                  jconv = jconv + 1
                  mterm(jconv) = ind
                  ncoef(jconv) = dcoef(k,j,i,id)

               end if 

            end do 
c                                 load the reformulated function
c                                 into lterm, ksub, and dcoef
            lterm(j,i,id) = jconv
 
            do k = 1, jconv

               dcoef(k,j,i,id) = ncoef(k)
               ind = mterm(k)

               if (ind.le.mstot(id)) then 
                  ksub(k,j,i,id) = iy2p(ind)
               else 
                  ksub(k,j,i,id) = mterm(k) - ndep(id)
               end if 

            end do                       

         end do 
 
      end do  

      end

      subroutine specis (g,id)
c----------------------------------------------------------------------
c subroutine to speciation of a solution with disordered composition p0a. 
c the speciated composition is returned in array pa. 
c    id identifies the solution.
c    g is the change in G for the stable speciation relative to a mechanical
c      mixture of the endmembers.
c----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer i,id

      logical error

      double precision g, gdord, omega, gex

      double precision z, pa, p0a, x, w, y
      common/ cxt7 /y(m4),z(m4),pa(m4),p0a(m4),x(mst,msp),w(m1)

      integer lstot,mstot,nstot,ndep,nord
      common/ cxt25 /lstot(h9),mstot(h9),nstot(h9),ndep(h9),nord(h9)

      logical lorder, lexces, llaar, lrecip
      common/ cxt27 /lorder(h9),lexces(h9),llaar(h9),lrecip(h9)

      double precision r,tr,pr,ps,p,t,xco2,u1,u2
      common/ cst5   /p,t,xco2,u1,u2,tr,pr,r,ps

      double precision dvnu,deph,dydy
      common/ cxt3r /dvnu(m4,j3,h9),deph(j3,h9),dydy(m4,j3,h9)

      integer iopt
      logical lopt
      double precision nopt
      common/ opts /nopt(i10),iopt(i10),lopt(i10)
c----------------------------------------------------------------------
      g = 0d0 

      if (lrecip(id)) then 
c                                 initialize limit expressions
         call p0limt (id)

      else 
c                                 non-reciprocal, initialize p0 
c                                 and if necessary, limits.
         do i = lstot(id)+1, nstot(id)
            p0a(i) = 0d0
            pa(i) = p0a(i)
         end do

         if (nord(id).gt.1) call p0limt (id)

      end if 
c                                 as most models are single species and
c                                 there is so much overhead in computing
c                                 multiple speciation, use a special routine
c                                 for single species models:
      if (nord(id).gt.1) then
 
         call speci2 (g,id,error)

      else 

         call speci1 (g,id,1,error) 

      end if 

      if (error.or.iopt(17).ne.0) then 
c                                 if speciation returns error, or order_check is on,
c                                  i.e., iopt(17).ne.0, compute disordered g.                               
         gdord =  gex(id,p0a) - t*omega(id,p0a)
 
         if (lrecip(id)) then 
            do i = 1, nord(id)
               gdord = gdord + p0a(lstot(id)+i)*deph(i,id)
            end do 
         end if 

         if (error) then 

            g = gdord

         else

            if (gdord.lt.g) g = gdord

         end if 

      end if 
c                                 convert the ordered endmember fractions to 
c                                 disordered fractions (stored in the p0a array).      
      if (lrecip(id)) call p0dord (id)

      end 

      subroutine gderiv (id,g,dp,error)
c----------------------------------------------------------------------
c subroutine to compute the g of a solution (id) and it's 1st and 2nd 
c derivatives with respect to the oncentrations of nord(id) ordered 
c species. the formulation assumes atomic site fractions are linear 
c functions of the ordered species concentrations (p's) and that the 
c excess function is second order.
c----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      logical error

      integer i,k,l,i1,i2,id,norder,ipvt(j3)

      double precision g,dp(j3),t,s,ds(j3),d2s(j3,j3),dg(j3),d2g(j3,j3)
c                                 working arrays
      double precision z, pa, p0a, x, w, y
      common/ cxt7 /y(m4),z(m4),pa(m4),p0a(m4),x(mst,msp),w(m1)

      double precision alpha,dt
      common/ cyt0  /alpha(m4),dt(j3)
c                                 excess energy variables
      integer jterm, jord, jsub
      common/ cxt2i /jterm(h9),jord(h9),jsub(m2,m1,h9)

      double precision dvnu,deph,dydy
      common/ cxt3r /dvnu(m4,j3,h9),deph(j3,h9),dydy(m4,j3,h9)
c                                 model type
      logical lorder, lexces, llaar, lrecip
      common/ cxt27 /lorder(h9),lexces(h9),llaar(h9),lrecip(h9)

      integer lstot,mstot,nstot,ndep,nord
      common/ cxt25 /lstot(h9),mstot(h9),nstot(h9),ndep(h9),nord(h9)

      double precision dppp,d2gx,sdzdp
      common/ cxt28 /dppp(j3,j3,m1,h9),d2gx(j3,j3),sdzdp(j3,m11,m10,h9)

      double precision p,tk,xc,u1,u2,tr,pr,r,ps
      common/ cst5 /p,tk,xc,u1,u2,tr,pr,r,ps

      logical pin
      common/ cyt2 /pin(j3)
c----------------------------------------------------------------------
c                                 initialize, d2gx has been set in setw
      g = 0d0

      norder = nord(id)

      do k = 1, norder
         dg(k) = 0d0
         do l = k, norder
            d2g(l,k) = d2gx(l,k)
         end do 
      end do 

      if (lexces(id)) then

         do i = 1, jterm(id)
c                                 assuming regular terms
           i1 = jsub(1,i,id)
           i2 = jsub(2,i,id)

           g = g + w(i) * pa(i1) * pa(i2)

           do k = 1, norder

              if (.not.pin(k)) cycle

              dg(k) = dg(k) + w(i) * (pa(i1)*dydy(i2,k,id) 
     *                              + pa(i2)*dydy(i1,k,id))
           end do 

         end do  
c                                 get derivative of excess function
         if (llaar(id)) then 

            t = 0d0 
c                                 h&p van laar
            do i = 1, nstot(id)
               t = t + alpha(i)* pa(i)
            end do 
c                                 coming out of this loop g, dg, and
c                                 d2g  are not the complete functions 
c                                 because of the "tphi" term in the 
c                                 van laar.

            do k = 1, norder

               if (.not.pin(k)) cycle
c                                 convert dg and d2g to the full derivative
               dg(k) = (dg(k) - g*dt(k)/t)/t
               do l = k, norder
                  d2g(l,k) = (d2g(l,k) - 2d0*dt(k)*dg(k))/t
               end do 
            end do 
c                                 and the full excess energy 
            g = g/t

         end if 

      end if 
c                                 get the configurational entropy derivatives
      call sderiv (id,s,ds,d2s)

      do k = 1, norder

         if (.not.pin(k)) cycle

         g = g + deph(k,id) * pa(lstot(id)+k)
c                                 dg is the negative of the differential of g 
c                                 with respect to the kth species.
         dg(k) = -(deph(k,id) + dg(k) - tk*ds(k))
         do l = k, norder 
            d2g(l,k) = d2g(l,k) - tk*d2s(l,k)
         end do 
      end do
c                                 determininats, to check for a saddle point
c      if (norder.eq.2) then 
c         detg = d2g(1,1)*d2g(2,2)-d2g(2,1)**2
c      else 
c         detg = d2g(1,1)*(d2g(2,2)*d2g(3,3)-d2g(3,2)**2) 
c     *        - d2g(2,2)*d2g(1,3)**2
c     *        + 2d0*d2g(2,1)*d2g(3,2)*d2g(3,1)-d2g(2,1)**2*d2g(3,3)
c      end if 

      g = g - tk*s 
c                                 copy dg and d2g into dp and d2s
      do k = 1, norder
         if (pin(k)) then 
            dp(k) = dg(k)
            d2s(k,k) = d2g(k,k)
            do l = k+1, norder
               if (pin(l)) then  
                  d2s(l,k) = d2g(l,k)
                  d2s(k,l) = d2g(l,k) 
               end if 
            end do 
         end if 
      end do 

      do k = 1, norder
         if (.not.pin(k)) then
            dp(k) = 1d0 
            d2s(k,k) = 1d0 
            do l = 1, norder
               if (l.eq.k) cycle 
               d2s(l,k) = 0d0
               d2s(k,l) = 0d0 
            end do 
         end if 
      end do     
c                                 get the newton-raphson increments:
c                                 this is a general factorization routine, should
c                                 exploit that d2g is symmetric.
      call factr2 (d2s,j3,norder,ipvt,error)
c                                 solve for the increments by back-substitution, 
c                                 this routine is also not efficient and should 
c                                 be re written. 
      if (.not.error) call subst2 (d2s,ipvt,j3,norder,dp,error) 
c                                 substitute replaces the values of dg with the 
c                                 newton-raphson increments for the ordered species
c                                 compositions. 
      end

      subroutine sderiv (id,s,dsy,dsyy)
c----------------------------------------------------------------------
c subroutine to the derivative of the configurational entropy of a 
c solution with respect to the proportion of a dependent species.

c THIS DOES NOT INCLUDE ENDMEMBER CONFIGURATION ENTROPY DERIVATIVES!
c----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer i,j,k,l,id

      logical inf

      double precision zt,dzdy,s,dsy(j3),dsyy(j3,j3),q,zl,
     *                 z(m11,m10),s0,ztemp,zlnz,
     *                 dsinf(j3),d2sinf(j3,j3)
c                                 working arrays
      double precision zz, pa, p0a, x, w, y
      common/ cxt7 /zz(m4),y(m4),pa(m4),p0a(m4),x(mst,msp),w(m1)
c                                 configurational entropy variables:
      integer msite, ksp, lterm, ksub
      common/ cxt1i /msite(h9),ksp(m10,h9),lterm(m11,m10,h9),
     *               ksub(m0,m11,m10,h9)

      double precision qmult, d0, dcoef, scoef      
      common/ cxt1r /qmult(m10,h9),d0(m11,m10,h9),dcoef(m0,m11,m10,h9),
     *               scoef(m4,h9)

      double precision dppp,d2gx,sdzdp
      common/ cxt28 /dppp(j3,j3,m1,h9),d2gx(j3,j3),sdzdp(j3,m11,m10,h9)

      integer lstot,mstot,nstot,ndep,nord
      common/ cxt25 /lstot(h9),mstot(h9),nstot(h9),ndep(h9),nord(h9)

      logical pin
      common/ cyt2 /pin(j3)
c----------------------------------------------------------------------
      s = 0d0
c                                 for each site
      do i = 1, msite(id)

         zt = 0d0
         s0 = zt 
c                                 get site fractions
         do j = 1, ksp(i,id)

            ztemp = d0(j,i,id)
c                                 for each term:
            do k = 1, lterm(j,i,id)
               ztemp = ztemp + dcoef(k,j,i,id) * pa(ksub(k,j,i,id))
            end do  

            zt = zt + ztemp
            if (ztemp.gt.0d0) s0 = s0 - ztemp * dlog (ztemp)
            z(j,i) = ztemp

         end do 

         ztemp = 1d0 - zt
         if (ztemp.gt.0d0) s0 = s0 - ztemp * dlog (ztemp)
         z(j,i) = ztemp
         s = s + qmult(i,id) * s0

      end do 
c                                 endmember corrections
      do i = 1, nstot(id)
         s = s - pa(i)*scoef(i,id)
      end do 

c                                 initialize derivatives:
      inf = .false.

      do k = 1, nord(id)
         dsy(k) = 0d0 
         dsinf(k) = 0d0 
         do l = k, nord(id) 
            dsyy(l,k) = 0d0 
            d2sinf(l,k) = 0d0 
         end do 
      end do  
c                                 evaluate derivatives:
      do i = 1, msite(id)

         q = qmult(i,id)
 
         do j = 1, ksp(i,id) + 1   

            zl = z(j,i) 

            if (zl.gt.0d0) then 
               zlnz = 1d0 + dlog(zl)
            else
               zlnz = 1d0 
            end if 

            do k = 1, nord(id)        
c                                 skip species not in the model
               if (.not.pin(k)) cycle
c                                 sdzdp is (dz(i,j)/dp(k))
               dzdy = sdzdp(k,j,i,id)

               if (dzdy.eq.0d0) cycle 

               if (zl.gt.0d0) then 
c                                 the first derivative is
                  dsy(k) = dsy(k) - q * dzdy * zlnz
c                                 and the jacobians are
                  do l = k, nord(id)

                     if (.not.pin(l)) cycle 
                     dsyy(l,k) = dsyy(l,k) 
     *                         - q * dzdy * sdzdp(l,j,i,id) / zl
                  end do 

               else if (zl.lt.-1d-6) then 

                   write (*,*) 'wacka boom',zl,j,i
                   write (*,*) (p0a(l),l=1,8)
                   write (*,*) (pa(l),l=1,8)
                   write (*,*) 

               else 

                  inf = .true.
c                                 a species with a non-zero
c                                 derivative is zero, the 
c                                 first will be sign(dzdy)*infinity
                  dsinf(k) = dsinf(k) + dsign(q,dzdy)

                  do l = k, nord(id)
c                                 the 2nd will be -sign of 
c                                 cross term * infinity
                     if (.not.pin(l)) cycle 
                     d2sinf(l,k) = dsinf(k) -  
     *                             dsign(q,dzdy * sdzdp(l,j,i,id))
                  end do 
               
               end if 
            end do  

         end do 

      end do 

      if (inf) then

         do k = 1, nord(id)

            if (.not.pin(k)) cycle 
            if (dabs(dsinf(k)).gt.1d-5) dsy(k) = 1d8*dsinf(k)

            do l = k, nord(id)
               if (.not.pin(l)) cycle 
               if (dabs(d2sinf(l,k)).gt.1d-5) 
     *                                  dsyy(l,k) = 1d10*d2sinf(l,k)
            end do  
 
         end do 

      end if 

      end

      subroutine factr2 (a,m,n,ipvt,error)
c-----------------------------------------------------------------------
c factr2 is a subroutine which calculates the triangular
c decompositions of the matrix 'a'. factor is modified from
c the subroutine of the same name given by conte and de boor
c in 'elementary numerical analysis', mcgraw-hill, 1980.
c factor uses scaled partial pivoting.
c
c input     a- an n by n array containing the elements of matrix a.
c           n- the actual dimension of matrix a
c           m- the phsical dimension of matrix a
c output    a- an n by n array containing the upper, u, and lower, l,
c              triangular decompositions of input matrix a.
c        ipvt- a vector indicating that row ipvt(k) was used to
c              eliminate the a(n,k).
c       error- false if a is of rank = n, and true if a is of
c              lower rank.
c-----------------------------------------------------------------------
      implicit none

      logical error 

      include 'perplex_parameters.h'

      integer m,ipvt(m),i,j,k,ip1,n,istr
    
      double precision a(m,m),d(m),rmax,tmax,temp,ratio
c-----------------------------------------------------------------------
      error = .false.
c                            initialize ipvt,d
      do i = 1, n

         ipvt(i) = i
         rmax = 0d0

         do j = 1, n
            rmax = dmax1(rmax,dabs(a(i,j)))
         end do 
c                            ax = b is singular if rmax = 0
         if (dabs(rmax).lt.1d-5) then 
            error = .true.
            return 
         end if 

         d(i) = rmax

      end do 
c                            begin decomposition: 
      do i = 1, n-1
c                            determine pivot row (istr).
         ip1 = i+1
         rmax = dabs(a(i,i))/d(i)
         istr = i

         do j = ip1, n

            tmax = dabs(a(j,i))/d(j)

            if (tmax.gt.rmax) then
               rmax = tmax
               istr = j
            end if 

         end do

         if (dabs(rmax).lt.1d-5) then 
            error = .true.
            return
         end if 
c                            if istr gt i, make i the pivot row
c                            by interchanging it with row istr.
         if (istr.gt.i) then 

            j = ipvt(istr)
            ipvt(istr) = ipvt(i)
            ipvt(i) = j
            temp = d(istr)
            d(istr) = d(i)
            d(i) = temp

            do j = 1, n
               temp = a(istr,j)
               a(istr,j) = a(i,j)
               a(i,j) = temp
            end do 

         end if 
c                            eliminate x(k) from rows k+1,...,n.
         do j = ip1, n

            a(j,i) = a(j,i)/a(i,i)
            ratio = a(j,i)

            do k = ip1, n
               a(j,k) = a(j,k)-ratio*a(i,k)
            end do 

         end do

      end do 

      if (dabs(a(n,n)).lt.1d-5) error = .true.
 
      end

      subroutine subst2 (a,ipvt,m,n,b,error)
c-----------------------------------------------------------------------
c subst uses the lu decomposition of the matrix 'a' contained
c in the array 'a' to solve ax = b for x. subst is modified from the
c the subroutine of the same name listed by conte and de boor
c in 'elementary numerical analysis', mcgraw-hill, 1980.
c factor uses scaled partial pivoting.
 
c input     a- an n by n array containing the non-zero elements of
c              the u and l decompositions of a, as output by factor.
c           n- the actual dimension of the matrix a.
c           m- the physical dimension of a.
c        ipvt- a vector indicating that row ipvt(k) was used to
c              eliminate the coefficient a(n,k).
c           b- the vector b.
c output    b- the solution vector x.
c----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      logical error 
 
      integer m,ipvt(m),ip,i,j,n,ii

      double precision a(m,m),b(m),x(m),sum
c----------------------------------------------------------------------
c                                 solve ly = b for y:
      ip = ipvt(1)
      x(1) = b(ip)

      do i = 2, n

         sum = 0d0

         do j = 1, i - 1
            sum = a(i,j)*x(j) + sum
         end do 

         ip = ipvt(i)
         x(i) = b(ip)-sum

      end do 
c                                 solve ux = y for x:
      if (a(n,n).eq.0d0) then
c                                 this check should be superfluous. should check
c                                 what's with factor. 
         error = .true.
         return
      end if 

      x(n) = x(n)/a(n,n)

      do ii = 1, n - 1

         i = n-ii

         sum = 0d0

         do j = i + 1, n
            sum = a(i,j)*x(j)+sum
         end do 

         if (a(i,i).eq.0d0) then
c                                 as above.
            error = .true.
            return
         end if 

         x(i) = (x(i)-sum)/a(i,i)
         b(i) = x(i)

      end do 

      b(n) = x(n)

      end

      subroutine speci0 (g,h,w,n,fac,c0,f)
c----------------------------------------------------------------------
c subroutine to solve speciation of 0-d speciation with 1 ordering parameter
c by halving. assumes an ordered species in which A is on 1 site and B is on 
c n sites, and a disordered state in which A and B are distributed over all 
c n+1 sites. 

c    h   - is the enthalpy of complete disordering
c    w   - is the interaction energy
c    fac - is an empirical correction to the entropy, supposedly accounting for SRO.
c    g   - is the change in G for the stable speciation relative to the ordered state. 
c    y   - is the fraction of the ordered species

c                                                  JADC, Aug 29, 2010. 
c----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      double precision g,h,w,sign,dy,odg,ndg,n,f,y,dgdy,rt,c0,c1,c2,fac

      double precision r,tr,pr,ps,p,t,xco2,u1,u2
      common/ cst5   /p,t,xco2,u1,u2,tr,pr,r,ps

      integer iopt
      logical lopt
      double precision nopt
      common/ opts /nopt(i10),iopt(i10),lopt(i10)
c----------------------------------------------------------------------
c                                 check ordered state
      y = 1d0 - nopt(5)
      rt = r*t*fac

      odg = dgdy(h,w,n,f,y,rt)
c                                 if dgdy > 0 must be fully ordered
      if (odg.lt.0d0) then 

         g = -h

      else 
c                                 initialize at halfway point
         dy = -0.5d0 
c                                 iteration loop:
         do 

            y = y + dy 
            if (y.le.0d0) y = nopt(5)

            ndg = dgdy(h,w,n,f,y,rt)

            sign = odg*ndg

            if (sign.lt.0d0) then 
c                                 crossed the zero, flip the search
               odg = ndg
               dy = -dy/2d0

            else if (dabs(dy).lt.nopt(5)) then
c                                 refined to tolerance
               c1 = (n+y)/c0
               c2 = (1-y)*n/c0
               g = w*y*(1-y) + (1-y)*h
     *            - rt*(-c2*dlog(c2)-(1d0-c2)*dlog(1d0-c2)
     *                 - n*(c1*dlog(c1)+(1d0-c1)*dlog(1d0-c1)))
               exit

            else if (y.le.nopt(5)) then 
c                                 fully disordered
               g = 0d0
               exit 

            end if 

         end do 

      end if 

      end 

      double precision function dgdy (h,w,n,f,y,rt)
c----------------------------------------------------------------------
c function to compute dg/dy for subroutine speci0
c----------------------------------------------------------------------
      implicit none

      double precision h,w,n,f,y,rt

      dgdy = (1d0-2d0*y)*w - h
     *       - rt*f*dlog(n*(1d0-y)**2/(n+y)/(1d0+n*y))

      end 

      subroutine speci1 (g,id,k,error)
c----------------------------------------------------------------------
c subroutine to speciation of a solution with a single ordering parameter
c and disordered composition p0a by newton raphson. the speciated 
c composition is returned 
c in array pa. 
c    id identifies the solution.
c    g is the change in G for the stable speciation relative to a mechanical
c      mixture of the endmembers.
c----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer i1,i2,id,jd,k,itic

      logical error

      double precision g,pt,pmax,pmin,dy1,dy2,dp,dpmax,
     *                 omega,gex,dg,d2g

      double precision z, pa, p0a, x, w, y
      common/ cxt7 /y(m4),z(m4),pa(m4),p0a(m4),x(mst,msp),w(m1)

      double precision r,tr,pr,ps,p,t,xco2,u1,u2
      common/ cst5   /p,t,xco2,u1,u2,tr,pr,r,ps

      integer ideps,icase
      common/ cxt3i /ideps(2,j3,h9),icase(h9)

      integer lstot,mstot,nstot,ndep,nord
      common/ cxt25 /lstot(h9),mstot(h9),nstot(h9),ndep(h9),nord(h9)

      double precision dvnu,deph,dydy
      common/ cxt3r /dvnu(m4,j3,h9),deph(j3,h9),dydy(m4,j3,h9)

      logical pin
      common/ cyt2 /pin(j3)

      integer iopt
      logical lopt
      double precision nopt
      common/ opts /nopt(i10),iopt(i10),lopt(i10)

      logical lorder, lexces, llaar, lrecip
      common/ cxt27 /lorder(h9),lexces(h9),llaar(h9),lrecip(h9)
c----------------------------------------------------------------------
      i1 = ideps(1,k,id)
      i2 = ideps(2,k,id)
      dy1 = dydy(i1,k,id)
      dy2 = dydy(i2,k,id)
      jd = lstot(id) + k 
      error = .false.
c                                 starting point
      if (lrecip(id)) then 
c                                 reciprocal
         call plimit (pmin,pmax,k,id) 
         dpmax = pmax - pmin

      else 
c                                 find the maximum proportion of the 
c                                 ordered species cannot be > the amount 
c                                 of reactant initially present
         dpmax = dmin1(-pa(i1)/dy1,-pa(i2)/dy2)

      end if 
c                                 to avoid singularity set the initial 
c                                 composition to the max - nopt(5), at this
c                                 condition the first derivative < 0, 
c                                 and the second derivative > 0 (otherwise
c                                 the root must lie at p > pmax - nopt(5).               
      if (dpmax.gt.0d0) then

         pin(k) = .true.
         dp = dpmax - nopt(5)
         pmax = p0a(jd) + dp
         pmin = p0a(jd) + nopt(5)
c                                 get starting end for the search
c                                 first try the maximum
         pa(jd) = p0a(jd) + dp 
         pa(i1) = p0a(i1) + dy1*dp
         pa(i2) = p0a(i2) + dy2*dp 

         call gderi1 (k,id,dg,d2g)

         if (dg.gt.0d0.and.d2g.gt.0d0) then 
c                                 at the maximum concentration, the 
c                                 first derivative is positive, if 
c                                 the second is also > 0 then we're 
c                                 business
            dp = -dg/d2g

         else if (dg.lt.0d0) then
c                                 then saturated with the ordered 
c                                 species
            pa(jd) = p0a(jd) + dpmax
            pa(i1) = p0a(i1) + dy1*dpmax
            pa(i2) = p0a(i2) + dy2*dpmax    

            goto 90       

         else
c                                 try the min
            pa(jd) = pmin
            pa(i1) = p0a(i1) + dy1*nopt(5)
            pa(i2) = p0a(i2) + dy2*nopt(5)
 
            call gderi1 (k,id,dg,d2g)

            if (dg.lt.0d0.and.d2g.gt.0d0) then 
c                                 ok
               dp = -dg/d2g
            
            else                
c                                 full disordered
               error = .true.
               return             

            end if 
         end if 

         pt = pa(jd) + dp
c                                 check bounds 
         if (pt.lt.pmin) then
                             
            pa(jd) = pa(jd) + (pmin - pa(jd))/2d0

         else if (pt.gt.pmax) then
 
            pa(jd) = pa(jd) + (pmax - pa(jd))/2d0
          
         else 

            pa(jd) = pt         

         end if
c                                 set speciation
         dp = pa(jd) - p0a(jd)
         pa(i1) = p0a(i1) + dy1*dp
         pa(i2) = p0a(i2) + dy2*dp    
c                                 iteration counter to escape
c                                 infinite loops
         itic = 0 
c                                 newton raphson iteration
         do 

            call gderi1 (k,id,dg,d2g)

            dp = -dg/d2g 

            pt = pa(jd) + dp 

            if (pt.lt.pmin) then
c                                 increment would make p < pmin
c                                 switch the starting guess to pmax 
               dp = (pmin - pa(jd))/2d0
               pa(jd) = pa(jd) + dp

            else if (pt.gt.pmax) then
c                                 increment would make p > pmax
c                                 switch the starting guess to pmin 
               dp = (pmax - pa(jd))/2d0
               pa(jd) = pa(jd) + dp 

            else if (pt.eq.pmin.or.pt.eq.pmax) then 

               exit 

            else 

               pa(jd) = pt         

            end if

            pa(i1) = pa(i1) + dy1*dp
            pa(i2) = pa(i2) + dy2*dp 

            if (dabs(dp).lt.nopt(5)) then 

               exit

            else 

               itic = itic + 1
               if (itic.gt.20) exit

            end if 

         end do


      end if  

90    g = pa(jd)*deph(k,id) - t*omega(id,pa) + gex(id,pa)

      end

      subroutine speci2 (g,id,error)
c----------------------------------------------------------------------
c subroutine to multiple speciation of a solution with disordered composition 
c p0a. the speciated composition is returned in array pa. 
c    id identifies the solution.
c    g is the change in G for the stable speciation relative to a mechanical
c      mixture of the endmembers.
c----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      logical error

      integer i,k,id,lord,itic

      double precision g,dp(j3),tdp,gold,xtdp

      integer lstot,mstot,nstot,ndep,nord
      common/ cxt25 /lstot(h9),mstot(h9),nstot(h9),ndep(h9),nord(h9)

      logical pin
      common/ cyt2 /pin(j3)

      integer iopt
      logical lopt
      double precision nopt
      common/ opts /nopt(i10),iopt(i10),lopt(i10)
c----------------------------------------------------------------------
c                                 get initial p values
      call pinc0 (id,lord)
c                                 lord is the number of possible species
      if (lord.eq.1) then 

         do i = 1, nord(id)
            if (pin(i)) then 
               call speci1 (g,id,i,error)
               exit 
            end if 
         end do

      else if (lord.gt.1) then 

         itic = 0  
         gold = 0d0
         xtdp = 0d0

         do 

            call gderiv (id,g,dp,error)

            if (error) exit

            tdp = 0d0 

            do k = 1, nord(id)
               
               if (.not.pin(k)) cycle

               call pinc (dp(k),k,id)

               tdp = tdp + dabs(dp(k))

            end do 

            if (tdp.lt.nopt(5).and.gold-g.lt.1d2.or.tdp.eq.xtdp) exit

            if (g.gt.gold.and.gold.ne.0d0) xtdp = tdp

            gold = g 

            itic = itic + 1

            if (itic.eq.16) exit 

         end do

      else 
c                                 no speciation possible, but still need
c                                 to calculate g (setting error will do this). 
         error = .true.

      end if 

      end                  

      subroutine pinc (dp,k,id)
c----------------------------------------------------------------------
c subroutine to increment the k'th species of solution id, if the increment
c violates a stoichiometric limit, it's set to half it's maximum value.
c----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer k,i1,i2,id,jd

      double precision dp,pmx,pmn,tol
c                                 working arrays
      double precision z, pa, p0a, x, w, y
      common/ cxt7 /y(m4),z(m4),pa(m4),p0a(m4),x(mst,msp),w(m1)

      integer ideps,icase
      common/ cxt3i /ideps(2,j3,h9),icase(h9)

      integer lstot,mstot,nstot,ndep,nord
      common/ cxt25 /lstot(h9),mstot(h9),nstot(h9),ndep(h9),nord(h9)

      double precision dvnu,deph,dydy
      common/ cxt3r /dvnu(m4,j3,h9),deph(j3,h9),dydy(m4,j3,h9)

      save tol
      data tol/1d-5/
c----------------------------------------------------------------------
c                                 given dp check if it violates
c                                 stoichiometric constraints
      i1 = ideps(1,k,id)
      i2 = ideps(2,k,id)
      jd = lstot(id) + k 

      tol = 1d-7

      call plimit (pmn,pmx,k,id)       

      if (pa(jd)+dp.gt.pmx) then 
         dp = pmx - pa(jd) - tol
      else if (pa(jd)+dp.lt.pmn) then 
         dp = pmn - pa(jd) + tol
      end if  
c                                 adjust the composition by the increment
      pa(i1) = pa(i1) + dydy(i1,k,id)*dp
      pa(i2) = pa(i2) + dydy(i2,k,id)*dp 
      pa(jd) = pa(jd) + dp

      end 

      subroutine pinc0 (id,lord)
c----------------------------------------------------------------------
c subroutine set initial species concentrations to half their 
c stoichiometric limit.
c----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer i,j,k,i1,i2,id,jd,lord,iout,ibad(m4)

      double precision dp,pmn,pmx,dpp(j3),dinc,tinc
c                                 working arrays
      double precision z, pa, p0a, x, w, y
      common/ cxt7 /y(m4),z(m4),pa(m4),p0a(m4),x(mst,msp),w(m1)

      integer ideps,icase
      common/ cxt3i /ideps(2,j3,h9),icase(h9)

      integer lstot,mstot,nstot,ndep,nord
      common/ cxt25 /lstot(h9),mstot(h9),nstot(h9),ndep(h9),nord(h9)

      double precision dvnu,deph,dydy
      common/ cxt3r /dvnu(m4,j3,h9),deph(j3,h9),dydy(m4,j3,h9)

      logical pin
      common/ cyt2 /pin(j3)
c----------------------------------------------------------------------

      lord = 0

      if (icase(id).eq.1) then 
c                                 case 1: fully correlated
         dinc = 0.9d0/dfloat(nord(id))
         tinc = dinc

         do k = 1, nord(id)

            call plimit (pmn,pmx,k,id) 

            if (pmn.ge.pmx) then 
               pin(k) = .false.
               cycle 
            else 
               pin(k) = .true.
               lord = lord + 1
            end if 

            jd = lstot(id) + k 
            i1 = ideps(1,k,id)
            i2 = ideps(2,k,id)

            dp = pmn + (pmx - pmn) * tinc - pa(jd)
c                                 adjust the composition by the first increment
            pa(i1) = pa(i1) + dydy(i1,k,id)*dp
            pa(i2) = pa(i2) + dydy(i2,k,id)*dp 
            pa(jd) = pa(jd) + dp

            tinc = tinc + dinc

         end do

      else if (icase(id).eq.2) then 
c                                 case 2: positive partial correlation
         do i = 1, 5

            do k = 1, nord(id)

               call plimit (pmn,pmx,k,id) 

               if (i.eq.1) then 

                  if (pmn.ge.pmx) then 
                     pin(k) = .false.
                     cycle 
                  else 
                     pin(k) = .true.
                     lord = lord + 1
                 end if 

               end if 
c                                 adjust the composition by the first increment
               jd = lstot(id) + k 
               dp = pmx - pa(jd) 
               pa(jd) = pa(jd) + dp
               dpp(k) = pa(jd) - p0a(jd)

            end do 
c                                 no species possible
            if (lord.eq.0) return

         end do 
c                                 back off from maximum for final assignements
         do k = 1, nord(id)

            if (.not.pin(k)) cycle

            jd = lstot(id) + k 
            pa(jd) = p0a(jd)
            i1 = ideps(1,k,id)
            i2 = ideps(2,k,id)

            dp = dpp(k)*0.9d0
c                                 adjust the composition by the first increment
            pa(i1) = pa(i1) + dydy(i1,k,id)*dp
            pa(i2) = pa(i2) + dydy(i2,k,id)*dp 
            pa(jd) = pa(jd) + dp

         end do 

      else if (nord(id).eq.1) then
c                                 only one order parameter, as currently programmed
c                                 this will never be called. 
         call plimit (pmn,pmx,1,id) 

         if (pmn.ge.pmx) then 
            pin(1) = .false.
         else 

            pin(1) = .true.
            lord = 1
            jd = lstot(id) + 1
            i1 = ideps(1,1,id)
            i2 = ideps(2,1,id)

            dp = pmn + (pmx - pmn) * 0.9d0 - pa(jd)
c                                 adjust the composition by the first increment
            pa(i1) = pa(i1) + dydy(i1,1,id)*dp
            pa(i2) = pa(i2) + dydy(i2,1,id)*dp 
            pa(jd) = pa(jd) + dp

         end if 

      else 
c                                 unanticipated case?
         call error (999,p0a(1),i,
     *               'unanticpated correlation between ordered species')

      end if
c                                 check for degenerate compositions
      if (lord.gt.0) then 

         iout = 0 

         do i = 1, lstot(id)
            if (p0a(i).eq.0d0) then
               iout = iout + 1
               ibad(iout) = i 
            end if
         end do 
c                                 the indices of the present components are igood(1..in)
         if (iout.gt.0) then 
            do k = 1, nord(id)
               if (pin(k)) then    
c                                 check that the ordered species are in the subcomposition
                  do j = 1, 2                                    
                     do i = 1, iout
                        if (ideps(j,k,id).eq.ibad(i)) then 
                           lord = 0 
                           return 
                        end if 
                     end do 
                  end do 
               end if
            end do 
         end if 
      end if  

      end 

      subroutine gderi1 (k,id,dg,d2g)
c----------------------------------------------------------------------
c subroutine to compute the 1st and 2nd derivatives of the g of 
c solution (id)  with respect to the concentrations of the kth ordered. 
c the formulation assumes atomic site fractions are linear 
c functions of the ordered species concentrations (p's) and that the 
c excess function is second order.
c----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer i,k,i1,i2,id

      double precision g,dg,d2g,t,ds,d2s
c                                 working arrays
      double precision z, pa, p0a, x, w, y
      common/ cxt7 /y(m4),z(m4),pa(m4),p0a(m4),x(mst,msp),w(m1)

      double precision alpha,dt
      common/ cyt0  /alpha(m4),dt(j3)
c                                 excess energy variables
      integer jterm, jord, jsub
      common/ cxt2i /jterm(h9),jord(h9),jsub(m2,m1,h9)

      double precision dvnu,deph,dydy
      common/ cxt3r /dvnu(m4,j3,h9),deph(j3,h9),dydy(m4,j3,h9)
c                                 model type
      logical lorder, lexces, llaar, lrecip
      common/ cxt27 /lorder(h9),lexces(h9),llaar(h9),lrecip(h9)

      integer lstot,mstot,nstot,ndep,nord
      common/ cxt25 /lstot(h9),mstot(h9),nstot(h9),ndep(h9),nord(h9)

      double precision dppp,d2gx,sdzdp
      common/ cxt28 /dppp(j3,j3,m1,h9),d2gx(j3,j3),sdzdp(j3,m11,m10,h9)

      double precision v,tr,pr,r,ps
      common / cst5 /v(l2),tr,pr,r,ps
c----------------------------------------------------------------------
c                                 initialize, d2gx has been set in setw
      g = 0d0
      dg = 0d0
      d2g = d2gx(k,k)

      if (lexces(id)) then

         do i = 1, jterm(id)
c                                 assuming regular terms
           i1 = jsub(1,i,id)
           i2 = jsub(2,i,id)

           g = g + w(i) * pa(i1) * pa(i2)
           dg = dg + w(i) * (pa(i1)*dydy(i2,k,id) 
     *                     + pa(i2)*dydy(i1,k,id))

         end do  
c                                 get derivative of excess function
         if (llaar(id)) then 

            t = 0d0 
c                                 h&p van laar
            do i = 1, nstot(id)
               t = t + alpha(i)* pa(i)
            end do 
c                                 coming out of this loop g, dg, and
c                                 d2g  are not the complete functions 
c                                 because of the "tphi" term in the 
c                                 van laar.

c                                 convert dg and d2g to the full derivative
            dg = (dg - g*dt(k)/t)/t
            d2g = (d2g - 2d0*dt(k)*dg)/t

         end if 

      end if 
c                                 get the configurational entropy derivatives
      call sderi1 (k,id,ds,d2s)

      dg  = dg + deph(k,id)  - v(2)*ds
      d2g = d2g - v(2)*d2s

      end

      subroutine sderi1 (l,id,ds,d2s)
c----------------------------------------------------------------------
c subroutine to the derivative of the configurational entropy of a 
c solution with respect to the proportion of the lth ordered species.

c THIS DOES NOT INCLUDE ENDMEMBER CONFIGURATION ENTROPY DERIVATIVES!
c----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer i,j,k,l,id

      double precision zt,dzdy,dzy,dzyy,zl,ds,d2s,zlnz,dsinf
c                                 working arrays
      double precision zz, pa, p0a, x, w, y
      common/ cxt7 /zz(m4),y(m4),pa(m4),p0a(m4),x(mst,msp),w(m1)
c                                 configurational entropy variables:
      integer msite, ksp, lterm, ksub
      common/ cxt1i /msite(h9),ksp(m10,h9),lterm(m11,m10,h9),
     *               ksub(m0,m11,m10,h9)

      double precision qmult, d0, dcoef, scoef      
      common/ cxt1r /qmult(m10,h9),d0(m11,m10,h9),dcoef(m0,m11,m10,h9),
     *               scoef(m4,h9)

      double precision dppp,d2gx,sdzdp
      common/ cxt28 /dppp(j3,j3,m1,h9),d2gx(j3,j3),sdzdp(j3,m11,m10,h9)
c----------------------------------------------------------------------

      ds = 0d0 
      d2s = 0d0 

      do i = 1, msite(id)

         dzy = 0d0  
         dzyy = 0d0
 
         zt = 0d0 
         dsinf = 0d0 
  
         do j = 1, ksp(i,id)    

            zl = d0(j,i,id)
c                                 for each term:
            do k = 1, lterm(j,i,id)
               zl = zl + dcoef(k,j,i,id) * pa(ksub(k,j,i,id))
            end do 

            if (zl.gt.0d0) then 
               zt = zt + zl 
               zlnz = 1d0 + dlog(zl)
            else
               zlnz = 1d0 
            end if         
c                                 sdzdp is (dz(i,j)/dp(l))
            dzdy = sdzdp(l,j,i,id)

            if (dzdy.eq.0d0) cycle 

            if (zl.gt.0d0) then 
c                                 the first derivative is
               dzy = dzy - dzdy * zlnz
c                                 and the jacobians are

               dzyy = dzyy  - dzdy**2 / zl

            else 
c                                 a species with a non-zero
c                                 derivative is zero, the s
c                                 derivative may be +/-infinite
               dsinf = dsinf + dsign(1d0,dzdy)
                             
            end if 

         end do 
c                                 add the contibution from the ksp(i,id)+1th
c                                 species:
         zl = 1d0 - zt

         if (zl.gt.0d0) then 
            zlnz = 1d0 + dlog(zl)
         else
            zlnz = 1d0 
         end if 

         dzdy = sdzdp(l,j,i,id)

         if (dzdy.ne.0d0) then 
            if (zl.gt.0d0) then 
c                                 the first derivative is
               dzy = dzy - dzdy * zlnz
c                                 and the second is 
               dzyy = dzyy  - dzdy**2 / zl

            else 
c                                 
c                                 a species with a non-zero
c                                 derivative is zero, the s
c                                 derivative may be +/-infinite
               dsinf = dsinf + dsign(1d0,dzdy) 
               
            end if 

         end if 

         if (dabs(dsinf).lt.1d-5) then 
            ds = ds + qmult(i,id)*dzy
            d2s = d2s + qmult(i,id)*dzyy
         else 
            ds = ds + qmult(i,id)*dsinf*1d8
            d2s = d2s - qmult(i,id)*dabs(dsinf)*1d8
         end if 

      end do 

      end

      subroutine p0limt (id)
c----------------------------------------------------------------------
c subroutine to compute the sums of the p0 terms in ordered species 
c limit expressions for solution id.
c----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer i,j,k,id
c                                 working arrays
      double precision z, pa, p0a, x, w, y
      common/ cxt7 /y(m4),z(m4),pa(m4),p0a(m4),x(mst,msp),w(m1)

      integer lstot,mstot,nstot,ndep,nord
      common/ cxt25 /lstot(h9),mstot(h9),nstot(h9),ndep(h9),nord(h9)

      integer ln,lt,lid,jt,jid
      double precision lc, l0c, jc
      common/ cxt29 /lc(j6,j5,j3,h9),l0c(2,j5,j3,h9),lid(j6,j5,j3,h9),
     *               ln(j3,h9),lt(j5,j3,h9),jc(j3,j5,j3,h9),
     *               jid(j3,j5,j3,h9),jt(j5,j3,h9)

      double precision tsum
      common/ cxt31 /tsum(j5,j3)
c----------------------------------------------------------------------
      do k = 1, nord(id) 
c                                 for ordered species k
         do i = 1, ln(k,id)
c                                 for limit i
            tsum(i,k) = l0c(1,i,k,id)  

            do j = 1, lt(i,k,id)
c                                 for term j
               tsum(i,k) = tsum(i,k) + lc(j,i,k,id)*p0a(lid(j,i,k,id))

            end do
 
         end do 

      end do 

      end  

      subroutine plimit (pmn,pmx,k,id)
c----------------------------------------------------------------------
c subroutine to compute minimum and maximum concentration of ordered
c species k in solution id from site fraction constraints, assumes the
c p0 terms have been accumulated in tsum (routine p0limt)
c----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer i,j,k,id

      double precision pmn,pmx,mini
c                                 working arrays
      double precision z, pa, p0a, x, w, y
      common/ cxt7 /y(m4),z(m4),pa(m4),p0a(m4),x(mst,msp),w(m1)

      integer ln,lt,lid,jt,jid
      double precision lc, l0c, jc
      common/ cxt29 /lc(j6,j5,j3,h9),l0c(2,j5,j3,h9),lid(j6,j5,j3,h9),
     *               ln(j3,h9),lt(j5,j3,h9),jc(j3,j5,j3,h9),
     *               jid(j3,j5,j3,h9),jt(j5,j3,h9)

      double precision tsum
      common/ cxt31 /tsum(j5,j3)
c----------------------------------------------------------------------
      pmx = 1d99
      pmn = -1d99

      do i = 1, ln(k,id)

         mini =  tsum(i,k) 

         do j = 1, jt(i,k,id)

            mini = mini + jc(j,i,k,id)*pa(jid(j,i,k,id))

         end do 

         if (mini.gt.pmn) pmn = mini
         if (l0c(2,i,k,id)+mini.lt.pmx) pmx = mini + l0c(2,i,k,id)

      end do 

      end  

      subroutine readlm (tname,bad)
c---------------------------------------------------------------------
c readlm - reads stoichiometric limits on ordered species concentrations
c---------------------------------------------------------------------
      implicit none
  
      include 'perplex_parameters.h'

      integer j,k,l,jd,len,inds(k7),ier,ict 

      double precision coeffs(k7)

      logical bad

      character begin*5, tag*3, tname*10

      integer limn,limt,limid,jimid,jimt
      double precision limc,jimc
      common/ cxt30 /limc(j6+2,j5,j3),limid(m0,j5,j3),jimid(j3,j5,j3),
     *               limn(j3),limt(j5,j3),jimc(j3,j5,j3),jimt(j5,j3)

      double precision wg,xmn,xmx,xnc
      integer iend,isub,imd,insp,ist,isp,isite,iterm,iord,istot,jstot,
     *        kstot
      common/ cst108 /wg(m1,m3),xmn(mst,msp),xmx(mst,msp),xnc(mst,msp),
     *      iend(m4),isub(m1,m2,2),imd(msp,mst),insp(m4),ist(mst),
     *      isp(mst),isite,iterm,iord,istot,jstot,kstot

      integer iddeps,norder 
      double precision depvnu,denth
      common/ cst141 /depvnu(2,j3),denth(j3),iddeps(2,j3),norder

      integer length,iblank,icom
      character chars*1
      common/ cst51 /length,iblank,icom,chars(240)

      integer jsmod
      double precision vlaar
      common/ cst221 /vlaar(m3,m4),jsmod

      integer iam
      common/ cst4 /iam
c----------------------------------------------------------------------
c                               initialize limit counter
      do j = 1, norder
         limn(j) = 0
      end do 

      if (jsmod.eq.6.and.norder.eq.1) return

      call readcd (n9,len,ier)

      write (begin,'(5a)') (chars(j),j=1, 5)

      if (begin.eq.'begin') then 

         do 
c                                 read the limit equations for the 
c                                 amount of the ordered endmembers
            call readz (coeffs,inds,ict,istot+norder,tname,tag)

            if (tag.eq.'end') then 
               exit 
            else if (ict.eq.1) then
               bad = .true.
               exit
            end if 
c                                 convert the endmember index to the 
c                                 ordered species index
            jd = inds(1) - istot
            limn(jd) = limn(jd) + 1
            k = limn(jd) 
            if (k.gt.j5) call error (999,coeffs(1),k,tname)
                   
            limt(k,jd) = 0
            jimt(k,jd) = 0 

            do l = 2, ict
c                                 four cases
               if (    (inds(l).le.istot) 
     *             .or.(inds(l) - istot.eq.jd)
     *             .or.(inds(l).eq.inds(l-1).and.
     *                  inds(l) - istot.ne.jd)) then
c                                 1) disordered species go in p0 array
c                                 2) the species is limit species, the 
c                                    species must be in the p0 array.
c                                 3) the species is an ordered species
c                                    and it's the second occurence
                  limt(k,jd) = limt(k,jd) + 1
                  j = limt(k,jd)
                  if (j.gt.j6) call error (33,coeffs(1),j,tname)
                  limid(j,k,jd) = inds(l)
                  limc(j,k,jd) = coeffs(l)

               else if (inds(l).gt.istot) then 
c                                 4) is an ordered species p-term
                  jimt(k,jd) = jimt(k,jd) + 1
                  j = jimt(k,jd)
                  if (j.gt.j3) call error (33,coeffs(1),j,tname)
                  jimid(j,k,jd) = inds(l)
                  jimc(j,k,jd) = coeffs(l)

               else 

                  bad = .true.

               end if 

            end do 
c                                 the constant and delta (max-min) are:
            j = limt(k,jd) + 1
            limc(j  ,k,jd) = coeffs(1)
            limc(j+1,k,jd) = coeffs(ict+1)

         end do 

      else 

         bad = .true.

      end if 

      if (bad) then 
         if (iam.lt.3) then 
            write (*,1000) tname,(chars(j),j=1,len)
            write (*,1010)
         end if  
         backspace (n9)
      end if 

1000  format ('**warning ver203** READLM missing or invalid format for '
     *       ,'stoichiometric limit of ordered species',/,'currently ',
     *        'reading (and rejecting) solution model: ',a,
     *      /,'last record was:',/,240a1)
1010  format (/,'This error may be due to an out-of-date '
     *         ,'solution model file.',/
     *         ,'The current version is: '
     *         ,'www.perplex.ethz.ch/perplex/datafiles/solution_model'
     *         ,'.dat',/)

      end 

      subroutine input9 (first,output)
c-----------------------------------------------------------------------
c given a list of solution phase names (fname(h9)) input9 searches a
c data file (on unit n9) for the relevant data and subdivides the
c solutions into pseudo-compounds.
c-----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer icoct, i,j,h,im,icky,id,icpct,idsol,ixct

      logical output, first, bad
 
      character*10 tname, uname(2)*8, sname(h9), new*3

      double precision zt

      integer jsmod
      double precision vlaar
      common/ cst221 /vlaar(m3,m4),jsmod

      character*100 prject,tfname
      common/ cst228 /prject,tfname

      integer jmsol,kdsol
      common/ cst142 /jmsol(m4,mst),kdsol(m4)

      integer ipoint,imyn
      common/ cst60 /ipoint,imyn

      character*8 names
      common/ cst8 /names(k1)

      character fname*10
      common/ csta7 /fname(h9)

      double precision wg,xmn,xmx,xnc
      integer iend,isub,imd,insp,ist,isp,isite,iterm,iord,istot,jstot,
     *        kstot
      common/ cst108 /wg(m1,m3),xmn(mst,msp),xmx(mst,msp),xnc(mst,msp),
     *      iend(m4),isub(m1,m2,2),imd(msp,mst),insp(m4),ist(mst),
     *      isp(mst),isite,iterm,iord,istot,jstot,kstot

      character mname*8
      common/ cst18a /mname(m4)

      integer ntot,npairs
      double precision y,xy
      common/ cst86 /xy(mdim,k1),y(ms1,mst,k1),ntot,npairs

      integer iorig,jnsp,iy2p
      common / cst159 /iorig(m4),jnsp(m4),iy2p(m4)

      integer isoct
      common/ cst79 /isoct

      integer io3,io4,io9
      common / cst41 /io3,io4,io9

      integer icomp,istct,iphct,icp
      common/ cst6  /icomp,istct,iphct,icp  

      integer ixp
      double precision sxs,exces
      common/ cst304 /sxs(k13),exces(m3,k1),ixp(k1)

      integer jend
      common/ cxt23 /jend(h9,k12)

      integer ikp
      common/ cst61 /ikp(k1)

      integer ksmod, ksite, kmsol, knsp
      common/ cxt0  /ksmod(h9),ksite(h9),kmsol(h9,m4,mst),knsp(m4,h9)

      double precision pa, p0a, xx, w, yy, z
      common/ cxt7 /yy(m4),xx(m4),pa(m4),p0a(m4),z(mst,msp),w(m1)

      integer lstot,mstot,nstot,ndep,nord
      common/ cxt25 /lstot(h9),mstot(h9),nstot(h9),ndep(h9),nord(h9)

      integer iopt
      logical lopt
      double precision nopt
      common/ opts /nopt(i10),iopt(i10),lopt(i10)

      integer iam
      common/ cst4 /iam

      save uname

      data uname/' ',' '/
c-----------------------------------------------------------------------
c                                 initialize counters
      ixct = 0 
c                                 gloabl coordinate counter for xcoor (cxt10)
      icoct = 0  
c                                 initialize model counter
      im = 0
c                                 no request for solutions
      if (io9.eq.1) then 
         isoct = 0 
         return 
      end if 
c                                 open pseudocompund list file
      if (output.and.lopt(10)) then
         call mertxt (tfname,prject,'_pseudocompound_list.txt',0)
         open (n8,file=tfname)
      end if 
c                                 format test line
      read (n9,'(a)') new

      if (new.ne.'011'.and.new.ne.'008') call error (3,zt,im,new)

      do 
c                                 -------------------------------------
c                                 read the solution name
         call rmodel (tname,bad)

         if (bad) cycle 
c                                 istot is zero, if eof: 
         if (istot.eq.0) then 
c                                 then at least one solution phase referenced
c                                 in the input is not present in the
c                                 solution phase data file, write warning:
            if (iam.lt.3) call warn (43,zt,isoct-im,'INPUT9')
            exit

         end if 
c                                 -------------------------------------
c                                 check the solution model:
         call cmodel (im,idsol,tname,0,uname(1),uname(2),first)

         if (jstot.lt.2) cycle 
c                                 -------------------------------------
c                                 reformulate the model so that it has 
c                                 no missing endmembers:             
         if (jstot.lt.istot) call reform (tname,im,first)

         if (istot.lt.2) cycle  
c                                 -------------------------------------
c                                 make various book keeping arrays (y2p,
c                                 jmsol, dydz, .....)
         call nmodel
c                                 save solution name
         sname(im) = tname
c           
c                                 save found solutions in global solution 
c                                 model arrays
         call gmodel (im,tname)
c                                 generate pseudocompound compositions.
c                                 subdiv returns the total
c                                 number of pseudocompounds (ipcps) and 
c                                 array y, of which element y(h,i,j) is
c                                 the site fraction of the jth species on
c                                 the ith site of the hth pseudocompound.
         if (iam.lt.3) then  
c                                 vertex/meemum need static pseudocompounds
            call subdiv (tname,im)       
c                                 subdiv generates ntot compositions,
c                                 generate the compound data for each solution:
c                                 save the identities of the endmembers

c                                 global pseudo-cpd counter for sxs
            icpct = 0

            do i = 1, kstot

               id = kdsol(knsp(i,im))
c                                 what if id = 0? shouldn't be possible.
               if (ikp(id).ne.-1) ikp(id) = im

            end do             
      
            do h = 1, ntot
c                                 load the composition into
c                                 a the site fraction array:
               do i = 1, isite
                  zt = 0d0
                  do j = 1, isp(i) - 1
                     z(i,j) = y(j,i,h)
                     zt = zt + z(i,j)
                  end do 
                  z(i,isp(i)) = 1d0 - zt
               end do 
c                               generate the pseudocompound:
               call soload (im,icoct,icpct,ixct,tname,icky,im)

            end do 

            if (icpct.gt.0) then 
 
               write (*,1100) icpct, tname

               if (output.and.lopt(10)) then

                  if (jsmod.ne.6.and.jsmod.ne.8) then
                     write (n8,1060) tname, 
     *                         (names(jend(im,2+i)), i =1, lstot(im))
                  else if (jsmod.eq.6) then 
                     write (n8,1060) tname, 
     *                         (mname(iorig(knsp(i,im))), 
     *                         i = 1, lstot(im)),'* see footnote 1'
                  else if (jsmod.eq.8) then 
                     write (n8,1060) tname, 
     *                         (mname(iorig(knsp(i,im))), 
     *                         i = 1, lstot(im)),'* see footnotes 1 & 2'
                  end if

                  do i = iphct-icpct+1, iphct
                     write (n8,1070) names(i),
     *                            (sxs(ixp(i)+j), j = 1, lstot(im))
                  end do

                  if (jsmod.eq.6) then 
                     write (n8,1120)
                  else if (jsmod.eq.8) then
                     write (n8,1120)
                     write (n8,1130)
                  end if 
               end if 

            end if 

            jend(im,2) = icpct

         end if 

         if (im.eq.isoct) exit 
c                               read next solution
      end do 

      if (isoct.gt.0) then 

         if (iam.lt.3) write (*,1110) iphct - ipoint
c                               scan for "killed endmembers"
         do i = 1, ipoint
c                               reset ikp
            if (ikp(i).lt.0) ikp(i) = 0
         end do 
c                               make general simplicial coordinates
c                               for iterative subdivision
c        if (iopt(10).gt.0.and.im.gt.0) call subdv0

         if (io3.eq.0.and.output.and.iam.lt.3) then 
            write (n3,1020)
            write (n3,1010) (fname(i), i = 1, isoct)
            if (im.gt.0) then 
               write (n3,1000)
               write (n3,1010) (sname(i), i = 1, im)
            else if (output) then 
               write (n3,1040) 
            end if 
         end if 

         do i = 1, im
            fname(i) = sname(i)
         end do 
      end if 

      isoct = im
c                              close pseudocompound list
      if (output.and.lopt(10)) close (n8)
c                              close solution model file
      close (n9)

      first = .false.

1000  format (/,'the following solution models will be considered:',/)
1010  format (7(2x,a10))
1020  format (/,'Of the requested solution models:',/)
1040  format (/,'no models will be considered.',/)
1060  format (/,'Solution: ',a,/,12x,'Endmember fractions:',
     *        /,12x,20(a,1x))
1070  format (a,2x,20(1x,f6.3,2x))
1100  format (i8,' pseudocompounds generated for: ',a)
1110  format (/,'Total number of pseudocompounds:',i8)
1120  format (/,'1 - Although the bulk composition of pseudocompounds'
     *        ,' for this solution is fixed,',/,' the proportions of'
     *        ,' its endmembers may vary due to respeciation.',/)
1130  format (/,'2 - Proportions output here may sum to <1 ', 
     *          'because the ordered species',/,'may have non-zero ',
     *          'initial proportions.',/)
      end 

      subroutine subdiv (tname,ids)
c---------------------------------------------------------------------
      implicit none
 
      include 'perplex_parameters.h'
 
      character*10 tname

      integer last,i,j,np1,h,index,ids

      integer ntot,npairs
      double precision y,xy
      common/ cst86 /xy(mdim,k1),y(ms1,mst,k1),ntot,npairs

      double precision wg,xmn,xmx,xnc
      integer iend,isub,imd,insp,ist,isp,isite,iterm,iord,istot,jstot,
     *        kstot
      common/ cst108 /wg(m1,m3),xmn(mst,msp),xmx(mst,msp),xnc(mst,msp),
     *      iend(m4),isub(m1,m2,2),imd(msp,mst),insp(m4),ist(mst),
     *      isp(mst),isite,iterm,iord,istot,jstot,kstot
c---------------------------------------------------------------------
c                                 do the first site:
      call cartes (1,tname,ids)

      last = isp(1) - 1
      if (isp(1).eq.1) last = 1

      do h = 1, npairs
         do i = 1, last
            y(i,1,h) = xy(i,h)
         end do 
      end do 

      np1 = npairs
      ntot = np1 

      if (isite.eq.1) return
c                                 do the second site:
      call cartes (2,tname,ids)

      index = 2 
      last = isp(index) - 1
      if (isp(1).eq.1) last = 1
c                                 there will be a total of
c                                 (npairs-1)*np1 compositions,
c                                 copy the first site 2 distribution
c                                 into the first np1 compositions:
      do h = 1, np1 
         do i = 1, last
c                                 this could be an invalid compostion for
c                                 a 3 site model.
            y(i,2,h) = xy(i,1)
         end do 
      end do 

      do h = 2, npairs
c                                 for each site 2 composition,
c                                 duplicate the range of site 1
c                                 compositions.
         do i = 1, np1

            ntot = ntot + 1

            if (ntot.gt.k1) call error (41,xy(1,1),k1,'SUBDIV')

            do j = 1, isp(1) - 1
               y(j,1,ntot) = y(j,1,i)
            end do 
c                                 put in the new site 2 compositions:
            do j = 1, isp(2) - 1 
               y(j,2,ntot) = xy(j,h)
            end do 
         end do 
      end do 
c                                 do the third site:
c                                 this hardwires the array dimensions to "mst"
      if (isite.eq.2) return

      np1 = (npairs-1) * np1

      call cartes (3,tname,ids)
c                                 the use of "index" is necessary in case mst<3.
      index = 3 
      last = isp(index) - 1
      if (isp(1).eq.1) last = 1
c                                 copy the first site 3 distribution
c                                 into the first np1*np2 compositions:
      do h = 1, ntot
         do i = 1, last
            y(i,mst,h) = xy(i,1)
         end do 
      end do 
c                                 for each site 3 composition,
c                                 duplicate the range of site 1 and 
c                                 site 2 compositions.
      do h = 2, npairs

         do i = 1, np1
            ntot = ntot + 1
            do j = 1, isp(1) - 1
               y(j,1,ntot) = y(j,1,i)
            end do 
            do j = 1, isp(2) - 1
               y(j,2,ntot) = y(j,1,i)
            end do 
            do j = 1, isp(mst) - 1
               y(j,mst,ntot) = xy(j,h)
            end do 
         end do 
      end do 
 
      end

      subroutine subdv0 
c---------------------------------------------------------------------
c subdv0 - subdivides simplices of dimension 1 to ksp on a cartesian
c grid with iopt(11)+1 points along each axis.
c---------------------------------------------------------------------
      implicit none
 
      include 'perplex_parameters.h'
 
      integer mres
 
      parameter (mres=11)

      integer i, ind(ms1), iy, indx, iexit, lsp, nsim

      double precision y(mres), ync

      integer ncoors

      integer ndim,mxsp
      logical cart
      double precision scoors
      common/ cxt86 /scoors(k24),ndim(mdim),mxsp,cart(mst,h9)

      integer iopt
      logical lopt
      double precision nopt
      common/ opts /nopt(i10),iopt(i10),lopt(i10)
c----------------------------------------------------------------------

      ync = 1d0/dfloat(iopt(11))
      lsp = mxsp - 1
      nsim = 0

c                                 generate coordinates for i'th component
      iy = 1
      y(1) = 0d0
           

      do while (y(iy).lt.1d0)

         iy = iy + 1
         if (iy.gt.mres) call error (999,ync,mres,'SUBDV0')

         y(iy) = y(iy-1) + ync

         if (y(iy).gt.1d0) y(iy) = 1d0 
 
      end do
c                                  
      do i = 1, mxsp
         ind(i) = 1
      end do 
c                                 assign the first point
      ncoors = mxsp

      do i = 1, mxsp
         scoors(i) = 0d0
      end do
c                                 now make the array index run over all
c                                 values increasing the last index fastest
      iexit = 0 

      do while (iexit.eq.0)
c                                 figure out which index to increment
         do i = mxsp, 1, -1

            if (ind(i).lt.iy) then
c                                 this is the one to increment
               ind(i) = ind(i) + 1
               indx = i 
               exit 

            else if (i.gt.1) then 
c                                 saturated the index
               ind(i) = 1
               
            else
c                                 saturated first index, done.
               ndim(mxsp) = ncoors
               return 

            end if 
         end do 
c                                 ok now we have the indices, check
c                                 the composition
         if (ncoors+mxsp.gt.k24) call error (180,ync,k24,
     *                               'CARTES increase parameter k24')

         do i = 1, mxsp
            if (i.eq.indx) then 
               scoors(ncoors+i) = y(ind(i)) 
            else 
               scoors(ncoors+i) = y(ind(i))
            end if 
         end do

         if (lsp.gt.0) then 
            if (scoors(ncoors+lsp).gt.0d0) then 
                  nsim = nsim + 1
                  ndim(nsim) = ncoors
                  lsp = lsp - 1
            end if 
         end if 

         ncoors = ncoors + mxsp

      end do 

      end 

      subroutine mapcub (ids,ksite)
c----------------------------------------------------------------------
c mapcub - does subdivision by mapping a general cube onto the local
c composition space. only used during iterative refinement.
c----------------------------------------------------------------------
      implicit none
 
      include 'perplex_parameters.h'

      integer jsp,i,h,ksite,ids,i1

      double precision xcum

      integer ntot,npairs
      double precision y,xy
      common/ cst86 /xy(mdim,k1),y(ms1,mst,k1),ntot,npairs

      double precision wg,xmn,xmx,xnc
      integer iend,isub,imd,insp,ist,isp,isite,iterm,iord,istot,jstot,
     *        kstot
      common/ cst108 /wg(m1,m3),xmn(mst,msp),xmx(mst,msp),xnc(mst,msp),
     *      iend(m4),isub(m1,m2,2),imd(msp,mst),insp(m4),ist(mst),
     *      isp(mst),isite,iterm,iord,istot,jstot,kstot

      integer ndim,mxsp
      logical cart
      double precision scoors
      common/ cxt86 /scoors(k24),ndim(mdim),mxsp,cart(mst,h9)

      double precision xmng, xmxg, xncg, xmno, xmxo
      common/ cxt6r /xmng(h9,mst,msp),xmxg(h9,mst,msp),xncg(h9,mst,msp),
     *               xmno(h9,mst,msp),xmxo(h9,mst,msp)
c---------------------------------------------------------------------
c                                 use rescaled coordinates (scoors) of 
c                                 a general cube generated by subdv0 
      jsp = isp(ksite) - 1
      npairs = 0

      do h = mxsp, ndim(jsp), mxsp

         npairs = npairs + 1
         i1 = 0 
         xcum = 0d0 

         do i = h+1-jsp, h

            i1 = i1 + 1
            xy(i1,npairs) = xmn(ksite,i1) 
     *                         + scoors(i)*(xmx(ksite,i1)-xmn(ksite,i1))
            xcum = xcum + xy(i1,npairs)
c                                 check if in bounds
            if (xy(i1,npairs).gt.xmxg(ids,ksite,i1).or.
     *          xy(i1,npairs).lt.xmng(ids,ksite,i1).or.
     *          xcum.gt.1d0) then 

               npairs = npairs - 1
               exit 

            end if 

         end do 
      end do 

      end 

      subroutine subdv1 (tname,ids)
c----------------------------------------------------------------------
c subdv1 - does subdivision during adaptive minimization
c----------------------------------------------------------------------
      implicit none
 
      include 'perplex_parameters.h'
 
      character*10 tname

      integer last,i,j,np1,h,index,ids

      integer ntot,npairs
      double precision y,xy
      common/ cst86 /xy(mdim,k1),y(ms1,mst,k1),ntot,npairs

      double precision wg,xmn,xmx,xnc
      integer iend,isub,imd,insp,ist,isp,isite,iterm,iord,istot,jstot,
     *        kstot
      common/ cst108 /wg(m1,m3),xmn(mst,msp),xmx(mst,msp),xnc(mst,msp),
     *      iend(m4),isub(m1,m2,2),imd(msp,mst),insp(m4),ist(mst),
     *      isp(mst),isite,iterm,iord,istot,jstot,kstot

      integer ndim,mxsp
      logical cart
      double precision scoors
      common/ cxt86 /scoors(k24),ndim(mdim),mxsp,cart(mst,h9)
c---------------------------------------------------------------------
c                                 do the first site:
      last = isp(1) - 1

      if (last.eq.0) then 
c                                 a dummy site 
         last = 1
         npairs = 1
         xy(1,1) = xmn(1,1)

      else if (cart(1,ids)) then 
c                                 use rescaled coordinates (scoors) of 
c                                 a general cube generated by subdv0
         call mapcub (ids,1)  
 
      else
c                                 do explicit subdivision 
         call cartes (1,tname,ids)

      end if

      do h = 1, npairs
         do i = 1, last
            y(i,1,h) = xy(i,h)
         end do 
      end do 

      ntot = npairs 

      if (isite.eq.1) return
c                                 do the second site:
      np1 = npairs
      last = isp(2) - 1
      if (isp(1).eq.1) last = 1

      if (cart(2,ids)) then

         call mapcub (ids,2)  

      else  

         call cartes (2,tname,ids)

      end if 
c                                 there will be a total of
c                                 (npairs-1)*np1 compositions,
c                                 copy the first site 2 distribution
c                                 into the first np1 compositions:
      do h = 1, np1 
         do i = 1, last
c                                 this could be an invalid compostion for
c                                 a 3 site model.
            y(i,2,h) = xy(i,1)
         end do 
      end do 

      do h = 2, npairs
c                                 for each site 2 composition,
c                                 duplicate the range of site 1
c                                 compositions.
         do i = 1, np1

            ntot = ntot + 1

            if (ntot.gt.k1) call error (41,xy(1,1),k1,'SUBDV1')

            do j = 1, isp(1) - 1
               y(j,1,ntot) = y(j,1,i)
            end do 
c                                 put in the new site 2 compositions:
            do j = 1, isp(2) - 1 
               y(j,2,ntot) = xy(j,h)
            end do 
         end do 
      end do 
c                                 do the third site:
c                                 this hardwires the array dimensions to "mst"
      if (isite.eq.2) return

      np1 = (npairs-1) * np1

      call cartes (3,tname,ids)
c                                 the use of "index" is necessary in case mst<3.
      index = 3 
      last = isp(index) - 1
      if (isp(1).eq.1) last = 1
c                                 copy the first site 3 distribution
c                                 into the first np1*np2 compositions:
      do h = 1, ntot
         do i = 1, last
            y(i,mst,h) = xy(i,1)
         end do 
      end do 
c                                 for each site 3 composition,
c                                 duplicate the range of site 1 and 
c                                 site 2 compositions.
      do h = 2, npairs

         do i = 1, np1
            ntot = ntot + 1
            do j = 1, isp(1) - 1
               y(j,1,ntot) = y(j,1,i)
            end do 
            do j = 1, isp(2) - 1
               y(j,2,ntot) = y(j,1,i)
            end do 
            do j = 1, isp(mst) - 1
               y(j,mst,ntot) = xy(j,h)
            end do 
         end do 
      end do 
 
      end

      subroutine satsrt 
c---------------------------------------------------------------------
c routine to sort pseudocompounds consisting entirely of saturated
c components.
c---------------------------------------------------------------------
      implicit none
  
      include 'perplex_parameters.h'

      integer j,idc
 
      integer icomp,istct,iphct,icp
      common/ cst6  /icomp,istct,iphct,icp  

      double precision cp
      common/ cst12 /cp(k5,k1)

      integer ids,isct,icp1,isat,io2
      common/ cst40 /ids(h5,h6),isct(h5),icp1,isat,io2
 
      do j = isat, 1, -1
         idc = icp + j
         if (cp(idc,iphct).ne.0d0) then
            isct(j) = isct(j) + 1
            if (isct(j).gt.h6) call error (17,cp(1,1),h6,'SATSRT')
            if (iphct.gt.k1) call error (180,cp(1,1),k1,
     *                                  'SATSRT increase parameter k1')
            ids(j,isct(j)) = iphct
            exit
         end if
      end do 

      end

      subroutine soload (isoct,icoct,icpct,ixct,tname,icky,im)
c--------------------------------------------------------------------------
c soload - loads/requires solution properties: 

c   jend(h9,k12)  - h9 is the maximum number of solutions
c                   k12 is the maximum number of endmembers pers
c                   solution plus two.
c   jend(i,1)     - OBSOLETE! is the number of endmembers in solution i.
c   jend(i,2)     - is the number of pseudocompounds of solution i.
c   jend(i,3-3+j) - are the indices of the j endmembers in solution i.
c   sxs(k13)      - contains the mole fractions of the endmembers
c                   in the pseudocompounds.
c   ixp(i)        - a pointer that locates the first mole fraction (- 1)
c                   of the ith pseudocompound, the remaining mole fractions
c                   follow sequentially (as in jend(i,3-3+j)).
c   ikp(i)        - the index of the solution corresponding to pseudocompound i.
c   ifp(i)        - flag, 0  - margules/ideal
c                         1  - internal eos fluid                         
c                         3  - van laar
c                         23 - toop, internal
c   exces(j,i)    - the excess function of pseudocompound i, accounts for 
c                   excess properties and configurational entropy as a function
c                   of pressure and temperature:

c                       gexces(i) = exces(1) + exces(2)*T + exces(3)*P 
c--------------------------------------------------------------------------

      implicit none
  
      include 'perplex_parameters.h'

      character*10 tname

      logical bad
 
      double precision zpr,hpmelt,slvmlt,gmelt,smix,esum,ctotal,omega,x

      integer jtic,id,im,h,i,j,l,m,icpct,isoct,ixct,icky,index,icoct

      double precision ctot
      common/ cst3   /ctot(k1)

      integer jmsol,kdsol
      common/ cst142 /jmsol(m4,mst),kdsol(m4)

      integer jsmod
      double precision vlaar
      common/ cst221 /vlaar(m3,m4),jsmod

      character*8 names
      common/ cst8 /names(k1)

      integer lstot,mstot,nstot,ndep,nord
      common/ cxt25 /lstot(h9),mstot(h9),nstot(h9),ndep(h9),nord(h9)

      integer iddeps,norder 
      double precision depvnu,denth
      common/ cst141 /depvnu(2,j3),denth(j3),iddeps(2,j3),norder

      double precision qmult, d0, dcoef, scoef      
      common/ cxt1r /qmult(m10,h9),d0(m11,m10,h9),dcoef(m0,m11,m10,h9),
     *               scoef(m4,h9)

      integer jndq, jdqf, iq
      double precision dqfg, dq 
      common/ cxt9 /dqfg(m3,m4,h9),dq(m4),jndq(m4,h9),jdqf(h9),iq(m4)

      double precision cp
      common/ cst12 /cp(k5,k1)

      double precision p,t,xco2,u1,u2,tr,pr,r,ps
      common/ cst5 /p,t,xco2,u1,u2,tr,pr,r,ps

      integer iff,idss,ifug,ifyn,isyn
      common/ cst10  /iff(2),idss(h5),ifug,ifyn,isyn

      integer jterm, jord, jsub
      common/ cxt2i /jterm(h9),jord(h9),jsub(m2,m1,h9)

      integer icomp,istct,iphct,icp
      common/ cst6  /icomp,istct,iphct,icp  

      integer ikp
      common/ cst61 /ikp(k1)

      integer ixp
      double precision sxs,exces
      common/ cst304 /sxs(k13),exces(m3,k1),ixp(k1)

      integer ifp
      common/ cxt32 /ifp(k1)

      logical depend,laar,order,fluid,macro,specil,recip
      common/ cst160 /depend,laar,order,fluid,macro,specil,recip

      double precision pa, p0a, zp, w, y, z
      common/ cxt7 /y(m4),zp(m4),pa(m4),p0a(m4),z(mst,msp),w(m1)

      double precision xcoor
      integer icoor
      common/ cxt10 /xcoor(k18),icoor(k1)

      double precision wgl,vlar
      common/ cxt2r /wgl(m3,m1,h9),vlar(m3,m4,h9)

      integer ksmod, ksite, kmsol, knsp
      common/ cxt0  /ksmod(h9),ksite(h9),kmsol(h9,m4,mst),knsp(m4,h9)

      integer ideps,icase
      common/ cxt3i /ideps(2,j3,h9),icase(h9)

      double precision y2pg
      common/ cxt4  /y2pg(m15,m4,h9)

      integer jend
      common/ cxt23 /jend(h9,k12)

      integer iopt
      logical lopt
      double precision nopt
      common/ opts /nopt(i10),iopt(i10),lopt(i10)
c                                 model type
      logical lorder, lexces, llaar, lrecip
      common/ cxt27 /lorder(h9),lexces(h9),llaar(h9),lrecip(h9)

      integer msite, ksp, lterm, ksub
      common/ cxt1i /msite(h9),ksp(m10,h9),lterm(m11,m10,h9),
     *               ksub(m0,m11,m10,h9)

      integer istg, ispg, imlt, imdg
      common/ cxt6i /istg(h9),ispg(h9,mst),imlt(h9,mst),imdg(ms1,mst,h9)

      integer ineg
      common/ cst91 /ineg(h9,m15)
c----------------------------------------------------------------------
c                              eliminate end-member compositions 
      do l = 1, mstot(im)
         y(l) = 1d0
         do m = 1, istg(im)
c                              check for invalid compositions
            x = z(m,jmsol(l,m))

            if (x.gt.1d0.or.x.lt.0d0) then 
               if (x.gt.0d0.and.x.lt.1.0001d0) then
                  x = 1d0
               else if (x.gt.-1d-4) then
                  x = 0d0
               else 
                  call error (125,x,1,tname)
               end if
            end if 

            y(l) = y(l)*x

         end do
c                                 y is the mole fraction of endmember l
         if (y(l).gt.0.9999d0.and.kdsol(l).gt.0) return

      end do   
c                                 move site fractions into array indexed 
c                                 only by independent disordered endmembers:
      do i = 1, mstot(im)
         pa(i) = y(knsp(i,im))
      end do

      if (depend) then

         if (ksmod(im).eq.5) then
c                                 for stx special case, reject excess comps
            do j = 1, ndep(im) 

               if (y(knsp(lstot(im)+j,im)).gt.0d0.and.
     *             y(knsp(lstot(im)+j,im)).le.y(ineg(im,j))) return

            end do 
         end if 
c                                 convert y's to p's
         do h = 1, lstot(im)
            do j = 1, ndep(im)
               pa(h) = pa(h) + y2pg(j,h,im) * y(knsp(lstot(im)+j,im))
            end do 
         end do          

      end if 

      if (order) then 
c                                 zero fractions of ordered species
         do h = lstot(im)+1, nstot(im)
            pa(h) = 0d0
         end do 
      end if 

      if (order.and.depend) then 
c                                 compute the fraction of the i'th ordered species
c                                 required by the decomposition of the dependent 
c                                 disordered species:
         do h = lstot(im)+1, nstot(im) 
            do j = 1, ndep(im)
               pa(h) = pa(h) + y2pg(j,h,im) * y(knsp(lstot(im)+j,im))
            end do 
         end do  
      end if 

      if (lopt(5).and.depend.or.order) then 
c                                 check for invalid site fractions, this is only necessary
c                                 for H&P models that assume equipartition (which is not 
c                                 implemented). 
         call zchk (pa,im,bad)
         if (bad) return 
      end if
c                                 the composition is acceptable.
      iphct = iphct + 1
      icpct = icpct + 1 

      if (iphct.gt.k1) call error (41,z(1,1),k1,'SOLOAD')

      ikp(iphct) = isoct
      ixp(iphct) = ixct
      icky = 0 

      do i = 1, m3
         exces(i,iphct) = 0d0
      end do
c                               classify model:
      if (jsmod.eq.0) then
c                               fluid uses internal eos
         ifp(iphct) = 1
c                               don't allow gonzoids to treat fluid
c                               as a solution if the user has also 
c                               specified fluid saturation
         if (ifyn.eq.0) call error (43,r,i,tname)  
      else if ((jsmod.eq.2.or.jsmod.eq.7.or.jsmod.eq.24
     *          .or.jsmod.eq.25.or.jsmod.eq.5).and.(.not.laar)) then
c                               no special treatment in computational
c                               routines.
         ifp(iphct) = 0 
c                               other special cases (internal solution
c                               models)
      else if (jsmod.ge.2) then
c                               Toop, internal EoS
c                               Van Laar ala HP.
         ifp(iphct) = jsmod    
      else 
c                               Ideal or Margules.
         ifp(iphct) = 0
      end if 
c                                encode a name
      if (istg(im).eq.2.and.mstot(im).eq.4) then
c                                special case 1, bin-bin reciprocal solution
         write (names(iphct),1020) tname,
     *                             (idint(1d2*z(j,1)), j = 1, 2)
      else if (istg(im).eq.2.and.mstot(im).eq.6.and.ispg(im,1).eq.3) 
     8        then
c                                special case 2, tern-bin reciprocal solution
         write (names(iphct),1060) tname,
     *                             (idint(1d2*z(1,j)), j = 1, 2),
     *                              idint(1d2*z(2,1))
      else if (istg(im).eq.2.and.mstot(im).eq.6.and.ispg(im,1).eq.2) 
     *        then
c                                special case 3, bin-tern reciprocal solution
         write (names(iphct),1060) tname,
     *                              idint(1d2*z(1,1)),
     *                             (idint(1d2*z(2,j)), j = 1, 2)
      else if (istg(im).eq.2.and.mstot(im).eq.9) then
c                                special case 4, tern-tern reciprocal solution
         write (names(iphct),1010) (idint(1d2*z(1,j)), j = 1, 2),
     *                             (idint(1d2*z(2,j)), j = 1, 2)
      else if (mstot(im).eq.2) then 
c                                binary solutions
         if (pa(1).eq.0d0.or.pa(1).eq.1d0) then

            write (names(iphct),1030) names(jend(im,3)),idint(1d2*pa(1))
         else 
            write (names(iphct),1070) names(jend(im,3)),1d2*pa(1)
         end if
      else if (mstot(im).eq.3) then 
c                                ternary solutions
         write (names(iphct),1040) (names(jend(im,2+j)),
     *                                idint(1d2*pa(j)), j = 1, 2)
      else if (mstot(im).eq.4) then 
c                                quaternary solutions
         icky = 1
         write (names(iphct),1060) tname,
     *                    (idint(1d2*pa(j)), j = 1, 3)
      else
c                                all the rest:
         icky = 1

         if (iphct.lt.1000000) then 
            write (names(iphct),1080) tname, iphct
         else if (iphct.lt.10000000) then
            write (names(iphct),1100) tname, iphct
         else
            write (names(iphct),1110) iphct
         end if 

      end if 
c                                get blanks out of name:
      if (mstot(im).lt.4) then 
         call unblnk (names(iphct)) 
      else 
         call reblnk (names(iphct)) 
      end if   
c                                 initialize constants:
      smix = 0d0
      esum = 0d0

      do i = 1, icomp
         cp(i,iphct) = 0d0
      end do 
c                                 load constants:
      ctotal = 0d0
      jtic = 0 
c                                 load xcoors if reciprocal
      if (lrecip(im)) then 

         icoor(iphct) = icoct 

         do i = 1, istg(im)
            do j = 1, ispg(im,i)
               icoct = icoct + 1
               xcoor(icoct) = z(i,j)
            end do
         end do 

      end if 

      do h = 1, lstot(im)
c                               do not count the mole
c                               fractions of absent endmembers
         id = jend(im,2+h)

         ixct = ixct + 1
         if (ixct.gt.k13) call error (40,y(1),k13,'SOLOAD')

         sxs(ixct) = pa(h) 

         if (sxs(ixct).ne.0d0) then
c                              composition vector
            do l = 1, icomp
               cp(l,iphct) = cp(l,iphct) + sxs(ixct) * cp(l,id)
               if (l.le.icp) ctotal = ctotal + sxs(ixct) * cp(l,id)
            end do 
c                              accumulate endmember configurational entropy
            esum = esum + sxs(ixct) * scoef(h,im)

            jtic = jtic + 1

         end if  

      end do  

      if (order.and.depend) then 

         do i = 1, norder 

            h = lstot(im) + i
            ixct = ixct + 1
            if (ixct.gt.k13) call error (40,y(1),k13,'SOLOAD')
            sxs(ixct) = pa(h)
c                              split these fraction into the fractions of the
c                              consituent disordered species:
            do j = 1, 2

               x = depvnu(j,i)*pa(h)
               id = jend(im,2+ideps(j,i,im)) 
c                              composition vector
               do l = 1, icomp
                  cp(l,iphct) = cp(l,iphct) + x * cp(l,id)
                  if (l.le.icp) ctotal = ctotal + x * cp(l,id)
               end do 

            end do 

         end do  

      end if 

      do l = 1, icomp
         if (cp(l,iphct).gt.-1d-8.and.cp(l,iphct).lt.0d0) then 
            cp(l,iphct) = 0d0 
         else if (cp(l,iphct).lt.0d0) then
            call error (228,cp(l,iphct),l,tname)
         end if 
      end do 
c                                 check if the phase consists
c                                 entirely of saturated components:
      if (ctotal.eq.0d0) then
         call satsrt 
c                                 to prevent nan's in the compositional coordinates:
         ctot(iphct) = 1d0
      else
         ctot(iphct) = ctotal
      end if 
c                                 compute ideal configurational negentropy:
      if (order) then
c                                 for cpd formation models, configurational entropy
c                                 is evaluated from speciation.
         smix = 0d0

      else if (jsmod.eq.24) then 
c                              hp melt model, use internal routine to get entropy
         smix = -hpmelt(im)

      else if (jsmod.eq.25) then 
c                              ghiorso melt model, use internal routine to get entropy
         smix = -gmelt(im)

      else if (jsmod.eq.28) then 

         smix = -slvmlt()

      else if (msite(im).ne.0) then 

         smix = -omega(im,pa)

      end if 
c                              save it:
      exces(2,iphct) = smix 
c                              load excess terms, if not Laar or ordered:
      if ((.not.laar).and.(.not.order)) then 

         do i = 1, jterm(im)

            zpr = 1d0

            do j = 1, jord(im)
               if (jsub(j,i,im).ne.0) zpr = zpr * pa(jsub(j,i,im))
            end do  

            do j = 1, m3
               exces(j,iphct) = exces(j,iphct) + zpr * wgl(j,i,im)
            end do 

         end do  

      end if 
c                              dqf corrections are also be saved in the
c                              exces array this implies that speciation
c                              does not effect the amount of the dqf'd
c                              endmembers.

c                              p0dord converts the p0 of any ordered species
c                              to it's disordered equivalents, as necessary
c                              for the dqf.
      if (depend.and.order) call p0dord (im)

      do i = 1, jdqf(im)
c                              index points to the endmember in the full
c                              model:
         index = jndq(i,im)
c                              user has made a dqf to an ordered species
c                              or a dependent endmember
         if (kdsol(knsp(index,im)).lt.0) 
     *                        call error (227,exces(1,1),index,tname)

         if (depend) then
            do j = 1, m3
               exces(j,iphct) = exces(j,iphct) + pa(index)*dqfg(j,i,im)
            end do 
         else 
            do j = 1, m3
               exces(j,iphct) = exces(j,iphct) + y(index)*dqfg(j,i,im)
            end do 
         end if 

      end do

1010  format (i2,i2,i2,i2)
1020  format (a2,i2,'_',i2)
1030  format (a2,i2)
1040  format (a1,i2,a1,i2)
1060  format (a2,i2,i2,i2)
1070  format (a2,f5.2)
1080  format (a2,i6)
1100  format (a1,i7)
1110  format (i8)

      end

      double precision function gkomab (id,jd,vdp)
c---------------------------------------------------------------------
c evaluate g for iron according to the EoS of Komabayashi & Fei (JGR,2010)
c id points to a phase of iron
c jd points to its parameters in thermo
c vdp is the vdp integral for all phases except HCP
c---------------------------------------------------------------------
      implicit none
 
      include 'perplex_parameters.h'

      integer id,jd

      double precision  g,vdp

      double precision thermo,uf,us
      common/ cst1 /thermo(k4,k10),uf(2),us(h5)    

      double precision p,t,xco2,u1,u2,tr,pr,r,ps
      common/ cst5 /p,t,xco2,u1,u2,tr,pr,r,ps

      g = thermo(4,jd) + t*(thermo(5,jd) + thermo(6,jd)*dlog(t)
     *  + t*(thermo(7,jd) + t*thermo(8,jd))) + thermo(9,jd)/t

      if (id.eq.600) then
c                                 BCC iron
         if (t.gt.1811d0) then 
            g = -25383.581d0 + t*(299.31255d0 - 46d0*dlog(t)) 
     *                       + 2.29603d31*t**(-9)
         end if 

      else if (id.eq.601) then 
c                                 FCC iron
           g = g - 2476.28 * dsqrt(t)

      else if (id.eq.602) then 
c                                 HCP iron 
           g = g - 2476.28 * dsqrt(t)
c                                 vdp from daewaele EoS
      else if (id.eq.603) then
c                                 liquid iron, destabilize at T < 1811
      end if 

      gkomab = g + vdp

      end 

      subroutine setau1 (output)
c----------------------------------------------------------------------
c setau1 sets autorefine dependent parameters. vertex is true if vertex
c is the calling program. output is set to false if autorefine mode is 
c not auto (i.e., iopt(6) = 2) or it is auto and in the second cycle.
c----------------------------------------------------------------------
      implicit none
 
      include 'perplex_parameters.h'

      logical output
 
      character*8 y*1

      character*10 badnam(h9)

      integer ibad2,ibad1,igood,i,j,ierr

      character*100 n10nam,n11nam,n12nam

      character*100 prject,tfname
      common/ cst228 /prject,tfname
c                                 solution model counter
      integer isoct
      common/ cst79 /isoct
c                                 solution model names
      character*10 fname
      common/ csta7 /fname(h9)

      integer isec,icopt,ifull,imsg,io3p
      common/ cst103 /isec,icopt,ifull,imsg,io3p

      integer iopt
      logical lopt
      double precision nopt
      common/ opts /nopt(i10),iopt(i10),lopt(i10)

      double precision dcp,soltol
      common/ cst57 /dcp(k5,h8),soltol

      logical refine
      common/ cxt26 /refine

      integer iam
      common/ cst4 /iam
c-----------------------------------------------------------------------
      refine = .false.
c                                 only use autorefine if solutions
c                                 are present and it is requested.
      if (isoct.ne.0) then 

         call mertxt (n10nam,prject,'.arf',0)
         open (n10, file = n10nam, iostat = ierr, status = 'old')

         call mertxt (n12nam,prject,'.tof',0)

         if (iam.eq.1) then

            open (n8, file = n12nam, status = 'unknown')
c                                 user friendly text version 
            if (lopt(11)) then 
               call mertxt (n11nam,prject,'_auto_refine.txt',0)
               open (n11, file = n11nam, status = 'unknown')
            end if 

            ibad1 = 0 
            igood = 0 

            if (ierr.ne.0) then 
c                                 no auto_refine data
               write (*,1020) n10nam
               open (n10, file = n10nam, status = 'unknown')

            else 
                   
               read (n10,*,iostat=ierr) ibad1, ibad2, igood
               if (ibad1.gt.0) read (n10,'(a)') (badnam(i),i=1,ibad1)

               if (iopt(6).ne.2.or.output) write (*,1030) n10nam

               if (iopt(6).eq.1) then 
c                                 manual mode, allow reinitialization
c                                 or suppression.
                  write (*,1060) 
                  read (*,'(a)') y

                  if (y.eq.'y'.or.y.eq.'Y') then

                     iopt(6) = 0
                     igood = 0

                  else 

                     refine = .true.  

                  end if

                  output = .true.
 
               else if (output) then  
c                                 second cycle of automated mode
                  refine = .true.

               end if  

               write (n8,*) refine

            end if 
c                                 set cycle dependent parameters
            if (refine.and.lopt(9)) then 
c                                 solvus tolerance 
               nopt(8) = nopt(13)/nopt(17)

            else if (lopt(9)) then 

               nopt(8) = nopt(13)

            end if

         else 
c                                 werami/pssect if refine, get the 
c                                 solution models to be rejected
            open (n8, file = n12nam, iostat=ierr, status = 'old')
        
            if (ierr.eq.0) then 
c                                 write a flag to indicate if auto-refine
c                                 has been used, this is necessary so that other
c                                 perplex programs know whether to reject the
c                                 badnam phases:
               read (n8,*,iostat=ierr) refine
c                                 read phases to be rejected if in auto-refine
               if (refine) then 
                  read (n10,*,iostat=ierr) ibad1, ibad2, igood
                  if (ibad1.gt.0) read (n10,'(a)') (badnam(i),i=1,ibad1)
               end if 

            end if 

         end if 

      end if 

      close (n8)
c                                 just to be sure
      if (iopt(6).eq.0) refine = .false.

      if (refine) then 
c                                 reject solution models that were 
c                                 not found to be stable and set parameters 
c                                 that depend on refinement
         ibad2 = 0 

         do 50 i = 1, isoct

            do j = 1, ibad1
               if (fname(i).eq.badnam(j)) then
                  if (iam.eq.1) write (*,1070) fname(i)
                  goto 50
               end if 
            end do 

            ibad2 = ibad2 + 1
            fname(ibad2) = fname(i)

50       continue 

         isoct = ibad2 

         write (*,'(/)')

      end if

      if (iopt(6).eq.2.and..not.refine) then 
         output = .false.
      else
         output = .true.
      end if 

1020  format (/,'Writing data for auto-refinement to file: ',a,/)
1030  format (/,'Reading data for auto-refinement from file: ',a,/)
1060  format ('Suppress or reinitialize auto-refinement (y/n)?')
1070  format ('Eliminating solution model: ',a,' in auto-refinement.')

      end 

      subroutine setau2 (output)
c----------------------------------------------------------------------
c setau2 sets/resets autorefine parameters after the solution models have
c been read. setau1 must be called first.

c output is set to true if autorefine mode is auto (i.e., iopt(6) = 2) 
c but no solutions are present (isoct = 0). 
c----------------------------------------------------------------------
      implicit none
 
      include 'perplex_parameters.h'

      logical output

      integer i,index
c                                 solution model counter
      integer isoct
      common/ cst79 /isoct

      integer isec,icopt,ifull,imsg,io3p
      common/ cst103 /isec,icopt,ifull,imsg,io3p

      integer ivarrx,ivarip,isudo,ivar
      common/ cst62 /ivarrx(k2),ivarip(k2),isudo,ivar

      integer jlow,jlev,loopx,loopy,jinc
      common/ cst312 /jlow,jlev,loopx,loopy,jinc

      integer grid
      double precision rid 
      common/ cst327 /grid(5,2),rid(2)

      integer ipot,jv,iv
      common/ cst24 /ipot,jv(l2),iv(l2)

      double precision vmax,vmin,dv
      common/ cst9  /vmax(l2),vmin(l2),dv(l2)

      logical oned
      common/ cst82 /oned

      logical refine
      common/ cxt26 /refine
c-----------------------------------------------------------------------
      if (isoct.eq.0) then 
     
         index = 2
         output = .true.

      else if (.not.output) then

         index = 1

      else 

          if (refine) then

             index = 2

          else 

             index = 1

          end if 

      end if 
c                                 set auto-refine dependent parameters
      if (icopt.eq.5) then 
c                                 gridded minimization
         if (oned) then 
            jlow = grid(4,index)
            loopx = 1
         else 
            jlow = grid(1,index)
            loopx = grid(2,index) 
         end if

         jlev = grid(3,index) 
          
      else if (icopt.gt.5) then 
c                                 1d/2d phase fractionation
         jlow = grid(4,index)

      else if (icopt.eq.1) then 
c                                 schreinemakers diagrams

c                                 max variance of curves to be traced
          isudo = grid(5,index)
c                                 default variable tracing increment
          do i = 1, 2
             dv(iv(i)) = (vmax(iv(i)) - vmin(iv(i)))*rid(index)
          end do 

      else if (icopt.eq.3) then 
c                                 mixed variable diagrams 

c                                 no variance restriction
          isudo = 99
c                                 default search increment
          dv(iv(1)) = (vmax(iv(1)) - vmin(iv(1)))*rid(index)

      end if 

      end 

      subroutine input1 (first,output)
c-----------------------------------------------------------------------
c input1 reads data from a file on unit n1, this data controls the
c computational options and is modified frequently.

c iam - indicates calling program 1 - vertex
c                                 2 - meemum
c                                 3 - werami
c                                 any other values no output
c-----------------------------------------------------------------------
      implicit none
 
      include 'perplex_parameters.h'
 
      logical output, eof, first

      character*100 blank*1,string(3)*8,rname*5,name*8,strg*80,n2name,
     *              n9name,y*1,sname*10,prt*3,plt*3

      integer idum,nstrg,i,j,ierr,icmpn,jcont,kct

      double precision dip

      character*100 cfname
      common/ cst227 /cfname

      integer ipot,jv,iv
      common/ cst24 /ipot,jv(l2),iv(l2)

      integer imaf,idaf
      common/ cst33 /imaf(i6),idaf(i6)

      character*162 title
      common/ csta8 /title(4)

      double precision vmax,vmin,dv
      common/ cst9 /vmax(l2),vmin(l2),dv(l2)

      character*10 fname
      common/ csta7 /fname(h9) 

      character*8 xname,vname
      common/ csta2 /xname(k5),vname(l2)

      character*5 cname
      common/ csta4 /cname(k5) 

      integer icp2
      common/ cst81 /icp2

      character*5 zname
      common/ cst209a /zname

      character tcname*5,xcmpnt*5
      common/ csta9 /tcname(k0),xcmpnt(k0)

      double precision buf
      common/ cst112 /buf(5)

      integer iwt
      common/ cst209 /iwt

      integer ivfl
      common/ cst102 /ivfl

      integer jfct,jmct,jprct
      common/ cst307 /jfct,jmct,jprct

      integer iind, idep
      double precision c0,c1,c2,c3,c4,c5
      common/ cst316 /c0,c1,c2,c3,c4,c5,iind,idep

      integer icont
      double precision dblk,cx
      common/ cst314 /dblk(3,k5),cx(2),icont

      integer ibuf,hu,hv,hw,hx 
      double precision dlnfo2,elag,gz,gy,gx
      common/ cst100 /dlnfo2,elag,gz,gy,gx,ibuf,hu,hv,hw,hx

      double precision ctrans
      integer ictr,itrans
      common/ cst207 /ctrans(k0,k5),ictr(k5),itrans

      integer iff,idss,ifug,ifyn,isyn
      common/ cst10  /iff(2),idss(h5),ifug,ifyn,isyn

      integer isoct
      common/ cst79 /isoct

      double precision v,tr,pr,r,ps
      common/ cst5  /v(l2),tr,pr,r,ps

      integer icomp,istct,iphct,icp
      common/ cst6  /icomp,istct,iphct,icp  

      integer ifct,idfl
      common/ cst208 /ifct,idfl

      integer ixct,iexyn,ifact
      common/ cst37 /ixct,iexyn,ifact 

      character*100 prject,tfname
      common/ cst228 /prject,tfname

      character*8 exname,afname
      common/ cst36 /exname(h8),afname(2)

      integer ids,isct,icp1,isat,io2
      common/ cst40 /ids(h5,h6),isct(h5),icp1,isat,io2

      integer isec,icopt,ifull,imsg,io3p
      common/ cst103 /isec,icopt,ifull,imsg,io3p

      integer jbulk
      double precision cblk
      common/ cst300 /cblk(k5),jbulk

      integer ivarrx,ivarip,isudo,ivar
      common/ cst62 /ivarrx(k2),ivarip(k2),isudo,ivar

      integer jlow,jlev,loopx,loopy,jinc
      common/ cst312 /jlow,jlev,loopx,loopy,jinc

      logical oned
      common/ cst82 /oned

      integer io3,io4,io9
      common / cst41 /io3,io4,io9

      logical usv
      integer pindex,tindex
      common/ cst54 /pindex,tindex,usv

      integer hcp,idv
      common/ cst52  /hcp,idv(k7) 

      character*8 eoscmp
      common/ cst98 /eoscmp(2)

      save blank
      data blank/' '/
c-----------------------------------------------------------------------
c                             output = .false. then in 1st cycle of
c                             autorefine.
      if (.not.output) then 
c                                 read computational option file 
         call fopen1 
      
      else 
c                                 create the file name           
         call mertxt (tfname,prject,'.dat',0)
         open (n1, file = tfname, iostat = ierr, status = 'old')
         if (ierr.ne.0) call error (120,r,n1,tfname)

      end if 
c                                 begin reading input:

c                                 read name of thermodynamic data file
      read (n1,'(a)') n2name
      call enblnk (n2name)
c                                 read print and graphic file names
      read (n1,'(a)') prt

      read (n1,'(a)') plt

      read (n1,'(a)') n9name
      call enblnk (n9name)
c
      do i = 1, 4
         title(i) = ' '
      end do 
c                                 read title for the calculation:
      read (n1,'(a)') title(1)
c                                 read computational option or option file name
c                                 use error condition to determine which:
      read (n1,'(a)') tfname
c                                 get first non-blank string 
      call getstg (tfname)

      read (tfname,'(i2)',iostat=ierr) icopt 

      if (ierr.eq.0) then 
c                                 if no error, old version
         tfname = 'perplex_option.dat'

      else
c                                 new version, read icopt
         read (n1,*,err=998) icopt

      end if 
c                                 if fractionation path from data 
c                                 file, get name:
      if (icopt.eq.10) then 
         read (n1,'(a)') cfname
         call enblnk (cfname)
      end if 
c                                 dummy variable place holders
      read (n1,*,err=998) idum
      read (n1,*,err=998) idum 
      read (n1,*,err=998) idum 
      read (n1,*,err=998) idum
      read (n1,*,err=998) idum 
      read (n1,*,err=998) idum
      read (n1,*,err=998) idum
      read (n1,*,err=998) idum
      read (n1,*,err=998) idum

      read (n1,*,err=998) itrans
      read (n1,*,err=998) icmpn
c                                 read new component definitions:
      do i = 1, itrans
         read (n1,'(a,1x,i2)') tcname(i), ictr(i)
         read (n1,*) (ctrans(j,i), j = 1, icmpn)
      end do

      read (n1,*,err=998) iwt
c                                 dummy variable place holders
      read (n1,*,err=998) idum
      read (n1,*,err=998) idum  
      read (n1,*,err=998) idum
c                                 read code for choice of fluid equation
c                                 of state from terminal. 
      read (n1,*,err=998) ifug
      if (ifug.ge.7.and.ifug.le.12.and.ifug.ne.9.and.ifug.ne.14.or.
     *    ifug.eq.19.or.ifug.eq.16.or.ifug.eq.17.or.ifug.eq.24.or.
     *    ifug.eq.20.or.ifug.eq.25) 
     *                  read (n1,*,err=998) ibuf,hu,dlnfo2,elag
      if (ibuf.eq.5) read (n1,*,err=998) buf     

      if (hu.eq.1) then 
c                                 hardwired fluid EoS endmember names
         eoscmp(1) = 'H2      '
         eoscmp(2) = 'O2      '

      else 

         eoscmp(1) = 'H2O     '
         eoscmp(2) = 'CO2     '

      end if 
c                                 no dependent variable
      iind = 0 
c                                 dummy variable
      read (n1,*,err=998) loopx
c                                 here loopx is just a 1d/2d flag for 
c                                 gridded minimization, for backwards 
c                                 compatibility set the to 2d if > 2 or < 1.
      if (loopx.eq.1) then 
         oned = .true.
      else
         oned = .false.
      end if 

      read (n1,*,err=998) idep
      read (n1,*,err=998) c0,c1,c2,c3,c4

      if (idep.eq.1) then 
         iind = 2
      else if (idep.eq.2) then 
         iind = 1
      end if 
c                                 decode thermodynamic components
c                                 read to the beginning of the component list
      do 
         read (n1,'(a)',end=998) rname
         if (rname.eq.'begin') exit
      end do 
c                                 count (icp) and save names (cname)
      icp = 0
      jbulk = 0 
  
      do 

         read (n1,'(a,a)') rname,strg

         if (rname.eq.'end t') then 
c                                 finished, could check for no components
            if (icp.eq.0) then
               write (*,*) 'No thermodynamic components'
               goto 998
            else if (icopt.eq.5.and.jbulk.lt.icp) then 
               write (*,*) 'All thermodynamic components must be ',
     *                     'constrained.'
               goto 998
            end if 
        
            exit 

         else if (rname.eq.blank) then 
 
            cycle 

         else if (rname.eq.'V'.or.rname.eq.'S') then

            usv = .true.

         else

            icp = icp + 1
            cname(icp) = rname
c                                 encode a graphics names for the
c                                 compositional variables, this is kind of
c                                 pointless, but it looks good.
            write (xname(icp),'(a,a,a)') 'x(',rname,')'
c                                 unblank the name
            call unblnk (xname(icp))
            if (icp.gt.k5) call error (197,r,icp,'INPUT1')

         end if 
c                                 check for compositional constraints
         read (strg,*,err=998) icont

         if (icont.ne.0) then 
            jbulk = jbulk + 1
            read (strg,*,err=998) j, (dblk(i,jbulk), i = 1, icont)    
         end if 

      end do           

      icp1 = icp + 1
      icp2 = icp + 2

      if (usv) then

         hcp = icp2
         tindex = icp1
         pindex = icp2
         cname(tindex) = 'T(K) '
         cname(pindex) = '-P(b)'

      else

         hcp = icp

      end if 
c                                 decode saturated components    
c                                 isat is the saturated component counter,
c                                 isyn = 1 if isat = 0, else isyn = 0
      isyn = 1
      isat = 0
      io2  = 0 

      do 
         read (n1,'(a)',end=998) rname
         if (rname.eq.'begin') exit
      end do 

      do 

         read (n1,'(a,a)') rname,strg
         if (rname.eq.blank) cycle 

         if (rname.eq.'end s') then 

            if (isat.ne.0) isyn = 0
            icomp = icp + isat
            exit 

         else if (rname.eq.blank) then 

            cycle 

         end if 
c                                 check for compositional constraints
         read (strg,*,err=998) jcont

         if (jcont.ne.0) then 
            jbulk = jbulk + 1
            read (strg,*,err=998) j, (dblk(i,jbulk), i = 1, icont)    
c                                 override variance flag choice, why here?
            isudo = 0    
         end if  

         isat = isat + 1
         if (isat.gt.h5) call error (15,r,i,'BUILD')
         cname(icp+isat) = rname
         if (rname.eq.'O2') io2 = isat

      end do 
c                                 decode saturated phase components
      do 
         read (n1,'(a)',end=998) rname
         if (rname.eq.'begin') exit
      end do 
c                                 ifct is the fluid component counter,
c                                 ifyn = 1 if ifct = 0.
      ifyn = 1
      ifct = 0

      do 

         read (n1,'(a)') rname

         if (rname.eq.'end s') then 
            if (ifct.ne.0) ifyn = 0
            icomp = icomp + ifct
            exit 
         else if (rname.eq.blank) then 
            cycle 
         end if 
      
         ifct = ifct + 1
         if (ifct.gt.2) call error (44,r,i,'BUILD')
c                                 save the component if only one
c                                 for use in input2.
         if (ifct.eq.1) zname = rname
         cname(icomp+ifct) = rname
      end do 
c                                  decode mobile components
c                                  jmct - mobile component counter
      jmct = 0 
      ifact = 0 

      do 

         call rdstrg (n1,nstrg,string,eof)

         if (eof) then 

            goto 998

         else if (string(1).eq.'begin') then

            cycle 

         else if (string(1).eq.'end') then

            icomp = icomp + jmct
            exit 

         else 

            read (string(1),'(a5)') rname
            jmct = jmct + 1
            if (jmct.gt.2) call error (45,r,i,'BUILD')
            cname(icomp+jmct) = rname

            if (nstrg.eq.1) then 
c                                 old format, create variable name
               write (vname(3+jmct),'(a,a)') 'mu_',rname
               imaf(jmct) = 1

            else 
c                                 new format
               read (string(2),'(a1)') y
               vname(3+jmct) = string(2)
               afname(jmct) = string(3)

               if (y.eq.'m') then 
c                                 chemical potential
                  imaf(jmct) = 1

               else if (y.eq.'f') then 

                  imaf(jmct) = 2

               else if (y.eq.'a') then 

                  imaf(jmct) = 3

               end if 

               if (imaf(jmct).gt.1) ifact = ifact + 1 

            end if 
               
         end if 

      end do 
c                             the ifct flag can probably be set later if fluid
c                             is in the thermodynamic composition space.   
      jfct = icp + isat 
c                             jprct+1..icomp -> (jmct.ne.0) mobile components 
      jprct = icomp - jmct 
c                             excluded phases
      iexyn = 1
      ixct = 0
c                             decode excluded phases
      do 
         read (n1,'(a)',end=998) name
         if (name.eq.'begin ex') exit
      end do

      do 

        read (n1,'(a)') name

         if (name.eq.'end excl') then 
            if (ixct.ne.0) iexyn = 0 
            exit
         else if (name.eq.blank) then 
            cycle 
         end if 

         ixct = ixct + 1
         if (ixct.gt.h8) call error (13,r,i,'BUILD')
         exname(ixct) = name

      end do  
c                             solution phases:
      do 
         read (n1,'(a)',end=998) sname
         if (sname.eq.'begin solu') exit
      end do
c                             isoct - solution phase counter,
c                             io9 is a flag = 0 no solution file
      isoct = 0

      do 

         read (n1,'(a)') sname
 
         if (sname.eq.'end soluti') then 
            if (io9.eq.1) isoct = 0 
            exit 
         else if (name.eq.blank) then 
            cycle  
         end if 

         isoct = isoct + 1
         if (isoct.gt.h9) call error (25,r,i,'BUILD')
         fname(isoct) = sname

      end do  
c                             read the maximum pressure, temper-
c                             ature, xco2, u1, and u2; the minimum
c                             pressure temperature, xco2, u1, and u2;
c                             and the default pressure, temperature,
c                             xco2, and chemical
c                             potential increments use kelvins, bars and
c                             joules as units (if no mobile components
c                             enter two zeroes for each read).
      read (n1,*,err=998) vmax
      read (n1,*,err=998) vmin
      read (n1,*,err=998) dv
c                             read the default indices of the
c                             dependent, independent, and secondary
c                             independent intensive variables, p = 1,
c                             t = 2, and xco2 = 3, respectively.
      read (n1,*,err=998) (iv(i), i = 1, 5)
c                             check to make sure input requests are
c                             consistent:
      if (icopt.ne.0.and.icopt.ne.4) then
c                             first check iv(1):
         if (iv(1).eq.3.and.ifyn.eq.1) call error (110,r,i,'I')
         if (iv(1).eq.3.and.ifct.eq.1) then 
            if (icopt.ne.7.and.iv(2).ne.3) call error (111,r,i,'I')
         end if 

         if (vmin(iv(1)).ge.vmax(iv(1)).and.icopt.lt.5) 
     *                                 call error (112,r,i,'I') 
         if (vname(iv(1)).eq.blank) call error (116,dip,i,'I')
      end if
c                             now check iv(2):
      if (icopt.eq.1) then
         if (iv(2).eq.3.and.ifyn.eq.1) call error (110,r,i,'INPUT1')
         if (iv(2).eq.3.and.ifct.eq.1) call error (111,r,i,'INPUT1')
         if (vmin(iv(2)).ge.vmax(iv(2))) call error (112,r,i,'I')
         if (vname(iv(2)).eq.blank) call error (116,r,i,'INPUT1')
      end if
c                             if a chemical potential is specified as an
c                             independent variable (iv(1-3)), check if
c                             the variable is defined:
      kct = 0
      do i = 1, 3
         if (iv(i).gt.3) kct = kct + 1
      end do 
c                             identify the variable used to determine
c                             which phases lie on the left hand side
c                             of a reaction equation.
      if (icopt.eq.3) then
         ivfl = iv(1)
      else if (iv(1).eq.2.or.iv(2).eq.2) then
c                             choose T
         ivfl = 2
      else if (iv(1).eq.1.or.iv(2).eq.1) then
c                             no T, so choose P
         ivfl = 1
      else
c                             no P or T, choose independent V
         if (iv(2).ne.3) then
            ivfl = iv(2)
         else
            ivfl = iv(1)
         end if
      end if
c                             ok, now find out which variables are
c                             dummies and story the indexes of the
c                             non-dummy variables in jv.
      ipot = 0

      do i = 1, 5
c                             variables v(1) (p) and v(2) (t) are
c                             only dummies if idep is set.
         if ((iv(i).ne.idep.or.icopt.eq.7.or.icopt.eq.9).and.
     *       (iv(i).eq.1.or.iv(i).eq.2)) then
            ipot = ipot+1
            jv(ipot) = iv(i)
c                             variable v(3) is a dummy if ifyn = 1:
         else if ((iv(i).eq.3).and.(ifyn.eq.0)) then
            ipot = ipot+1
            jv(ipot) = iv(i)
c                             variables v(4) and v(4) are dummies if
c                             imyn = 1:
         else if (jmct.ne.0) then
            if (iv(i).eq.4) then
               ipot = ipot+1
               jv(ipot) = iv(i)
            else if (iv(i).eq.5.and.jmct.eq.2) then
               ipot = ipot+1
               jv(ipot) = iv(i)
            end if
         end if
      end do 
c                                 if dependent variable add to jv list, could
c                                 increment ipot, but maybe it's better not to.
      if (idep.ne.0) jv(ipot+1) = idep
c                                 set convergence criteria for routine univeq
      if (icopt.le.3) call concrt

      if (icopt.ne.0) close (n1)
c                                 open files requested in input
      call fopen (n2name,prt,plt,n9name,jbulk,icp,icopt)
c                                 read auxilliary input for 2d fractionation
      if (icopt.eq.9) call rdain
c                                 get runtime parameters
      if (first.or.(.not.first).and.(.not.output)) 
     *   call redop1 (first,tfname)

      goto 999
c                                 archaic error trap
998   call error (27,r,i,n2name)

999   end

      subroutine input2 (first)
c----------------------------------------------------------------------
c input2 reads the thermodynamic data file for most perplex programs, 
c a (the?) notable exception being frendly that calls the parallel 
c routine jnput2.
c----------------------------------------------------------------------
      implicit none
 
      include 'perplex_parameters.h'
 
      character*5 mnames(k16*k17)*8

      double precision twt(k5),cst
 
      integer i,j,ict,im,k,ifer,inames, jphct, imak(k16)
 
      logical eof, good, first

      integer iff,idss,ifug,ifyn,isyn
      common / cst10 /iff(2),idss(h5),ifug,ifyn,isyn

      double precision ctot
      common/ cst3  /ctot(k1)

      integer iwt
      common/ cst209 /iwt

      integer icomp,istct,iphct,icp
      common/ cst6  /icomp,istct,iphct,icp  
     
      character*5 zname
      common/ cst209a /zname

      character*5 cname
      common/ csta4 /cname(k5)

      character*8 names
      common/ cst8 /names(k1)

      character*8 name
      common/ csta6 /name

      integer icont
      double precision dblk,cx
      common/ cst314 /dblk(3,k5),cx(2),icont

      integer ifct,idfl
      common/ cst208 /ifct,idfl

      integer ic
      common/ cst42 /ic(k0)

      integer idh2o,idco2,ikind,icmpn,icout,ieos
      double precision comp,tot
      common/ cst43 /comp(k0),tot,icout(k0),idh2o,idco2,
     *               ikind,icmpn,ieos

      integer cl
      character cmpnt*5, dname*80
      common/ csta5 /cl(k0),cmpnt(k0),dname

      double precision p,t,xco2,u1,u2,tr,pr,r,ps
      common/ cst5 /p,t,xco2,u1,u2,tr,pr,r,ps

      integer ilam,idiso,lamin,idsin
      double precision tm,td
      common/ cst202 /tm(m7,m6),td(m8),ilam,idiso,lamin,idsin

      integer ids,isct,icp1,isat,io2
      common/ cst40 /ids(h5,h6),isct(h5),icp1,isat,io2

      double precision atwt
      common/ cst45 /atwt(k0)

      integer iemod,kmod
      logical smod,pmod
      double precision emod
      common/ cst319 /emod(k15,k10),smod(h9),pmod(k10),iemod(k10),kmod

      integer jbulk
      double precision cblk
      common/ cst300 /cblk(k5),jbulk

      integer ixct,iexyn,ifact
      common/ cst37 /ixct,iexyn,ifact 

      character*8 exname,afname
      common/ cst36 /exname(h8),afname(2)

      integer ipoint,imyn
      common/ cst60 /ipoint,imyn

      integer jfct,jmct,jprct
      common/ cst307 /jfct,jmct,jprct

      integer imaf,idaf
      common/ cst33 /imaf(i6),idaf(i6)

      double precision mcomp
      character mknam*8
      integer nmak
      logical mksat
      common / cst333 /mcomp(k16,k0),nmak,mksat(k16),mknam(k16,k17)

      double precision mkcoef, mdqf
      integer mknum, mkind
      common / cst334 /mkcoef(k16,k17),mdqf(k16,k17),mkind(k16,k17),
     *                 mknum(k16)

      integer make
      common / cst335 /make(k10)

      integer eos
      common/ cst303 /eos(k10)

      integer ikp
      common/ cst61 /ikp(k1)

      double precision vnumu
      common/ cst44 /vnumu(i6,k10)

      integer iopt
      logical lopt
      double precision nopt
      common/ opts /nopt(i10),iopt(i10),lopt(i10)
c-----------------------------------------------------------------------
c                               initialization for each data set
c                               for k10 endmembers
      do i = 1, k10
         make(i) = 0 
      end do
c                               for k1 phases:
      do i = 1, k1
         ikp(i) = 0
      end do 
c                               other counters and flags:
      do i = 1, h5
         isct(i) = 0
      end do 
c                               counters for bounds
      iphct = 0
      lamin = 0 
      idsin = 0 
      idfl = 0
c                               read data base header, do component
c                               transformations, read make definitions.
      call topn2 (0)
c                               general input data for main program

c                               reorder thermodynamic components
c                               if the saturated phase components are 
c                               present
      ict = 0 

      if (lopt(7)) then 
c                               first component 1st
         do i = 1, icp
            if (cname(i).eq.cmpnt(idh2o)) then 
               ict = 1
               if (i.eq.1) exit 
               cname(i) = cname(1)

               do j = 1, 3
                  cst = dblk(j,i)
                  dblk(j,i) = dblk(j,1) 
                  dblk(j,1) = cst
               end do 

               cname(1) = cmpnt(idh2o)
               ict = 1
               exit            
            end if 
         end do 
c                               now check second component
         do i = 1, icp
            if (cname(i).eq.cmpnt(idco2)) then 
c                               if i = 2, already in second position exit
               if (i.eq.ict+1) exit
               cname(i) = cname(ict+1)

               do j = 1, 3
                  cst = dblk(j,i)
                  dblk(j,i) = dblk(j,ict+1) 
                  dblk(j,ict+1) = cst
               end do 

               cname(ict+1) = cmpnt(idco2)
               ict = 1
c                              used to re-execute loop? changed to exit 10/06
               exit            
            end if 
         end do
      end if  
c                              load the old cbulk array
      if (ifyn.ne.1) iphct = 2
c                               identify nonzero components.
c                               initialize icout(i) = 0
      do i = 1, icmpn
         icout(i) = 0
      end do

      do i = 1, icomp
         im = 0
         do j = 1, icmpn
            if (cname(i).eq.cmpnt(j)) then 
               twt(i) = atwt(j)
               ic(i) = j
               icout(j) = 1
               if (lopt(7)) then 
                  if (j.eq.idh2o) then
                     iff(1) = i
                     idfl = idfl + 1
                  else if (j.eq.idco2) then
                     iff(2) = i
                     idfl = idfl + 1
                  end if
               end if  
               im = 1
            end if 
         end do 
c                               write error message if a component
c                               was not found:
         if (im.eq.0) then 
            write (*,1230) cname(i), (cmpnt(k), k = 1, icmpn)
            write (*,1240)
            stop
         end if 
 
      end do 
c                                 this segment is to check if
c                                 a possible saturated phase component
c                                 has been made a mobile component,
c                                 if there is also a saturated phase
c                                 component idfl is the identity of the
c                                 mobile component otherwise idfl = 0.
      if (ifct.eq.1.and.idfl.eq.2) then
         if (zname.eq.cmpnt(idh2o)) then
            idfl = 1
         else if (zname.eq.cmpnt(idco2)) then
            idfl = 2
         end if
      else 
         idfl = 0
      end if
c                                 load atwts in updated order
      do i = 1, icomp
         atwt(i) = twt(i)
      end do 
c                                 convert weight to molar amounts
      if (jbulk.ne.0) then 

         if (iwt.eq.1) then 
            do i = 1, jbulk
               do j = 1, 3
                  dblk(j,i) = dblk(j,i)/atwt(i)
               end do 
            end do 
         end if 

         do i = 1, jbulk
            cblk(i) = dblk(1,i)
         end do   

      end if 
c                                 get composition vectors for entities
c                                 defined by a make definition:
      call makecp (inames,mnames,first)
c                                 loop to read reference phase data for
c                                 activity/fugacity variables
      ict = 0 

      if (ifact.gt.0) then
c                                 rewind and read 'til end of header
         call eohead (n2)

         good = .false.

         do

            call getphi (name,eof)

            if (eof) then 

               write (*,1000) (afname(i),i=1,jmct)
               write (*,1010)
               stop

            end if 
c                                 now look for a match with the 
c                                 reference phase names
            do i = 1, jmct

               if (name.eq.afname(i)) then 
c                                 got a match, count
                  iphct = iphct + 1

                  ict = ict + 1

                  idaf(i) = iphct
c                                 store thermodynamic parameters:
                  call loadit (iphct,.false.)
c                                 zero the component
                  vnumu(i,iphct) = 0d0

                  if (imaf(i).eq.2) then 
c                                 if some cretin chooses fugacity, prevent
c                                 gphase from calling the EoS.   
                     eos(iphct) = ieos 

                  else if (lopt(7)) then 
c                                 check for special component names
c                                 this is necessary because loadit 
c                                 will not set isfp if ifyn = 0.
                     if (name.eq.cmpnt(idh2o)) then 
                        eos(iphct) = 101
                     else if (name.eq.cmpnt(idco2)) then
                        eos(iphct) = 102 
                     end if
 
                  end if 
c                                 blank the name, this has two purposes,
c                                 it prevents problems if an entry is 
c                                 replicated in the data file, and flags
c                                 tagged entries 
                  afname(i) = ' '

                  if (ict.eq.jmct) good = .true.

                  exit 

               end if 

            end do 

            if (good) exit 

         end do 

      end if 
c                                 begin first read loop for data on
c                                 saturated components.
      if (isyn.ne.0.and.ifyn.ne.0) goto 40
c                                 read 'til end of header
      call eohead (n2)
c                                 loop to read real saturated
c                                 entities:
      ifer = 0

      do 

         call getphi (name,eof)

         if (eof) exit
 
         call chkphi (0,name,good)

         if (good) call sattst (ifer,good)

      end do 
c                                 loop to load made saturated entities
      do i = 1, nmak

         if (.not.mksat(i)) cycle
c                                 load make data 
         do j = 1, icmpn
            comp(j) = mcomp(i,j)
         end do 

         name = mknam(i,mknum(i)+1)
c                                 redundant check:
         call chkphi (2,name,good)
c                               
         if (.not.good) call error (57,comp(1),iphct,name)

         call sattst (ifer,good)

         if (good) then 
            make(iphct) = i
c                                 pointer used for iemod.
            imak(i) = iphct
         end if 

      end do 
c                                 check that there is data for
c                                 every fluid component.
      if (ifyn.eq.0.and.ifer.ne.ifct) call error (36,r,i,'INPUT2')
c                                 check that there is one phase
c                                 for each saturation constraint
40    do i = 1, isat
         if (isct(i).lt.1) call error (15,r,i,cname(icp+i))
      end do
c                                 read data for the remaining
c                                 phases of appropriate composition.
      istct = iphct + 1
c                                 read till end of header
      call eohead (n2)
c                                 begin second read loop:

      do  
    
         call getphi (name,eof)

         if (eof) exit 
c                                 check if valid phase:
         call chkphi (1,name,good)

         if (good) then 
c                                 acceptable data, count the phase:
            iphct = iphct + 1
c                                 for normalized composition:
            ctot(iphct) = tot
c                                 store thermodynamic parameters:
            call loadit (iphct,.false.)
         end if 
      end do 

c                                 loop to load made entities
      do i = 1, nmak

         if (mksat(i)) cycle
c                                 load make data 
         do j = 1, icmpn
            comp(j) = mcomp(i,j)
         end do 

         name = mknam(i,mknum(i)+1)
c                                 redundant check, but makes ctot.
         call chkphi (3,name,good)
c                               
         if (.not.good) call error (57,comp(1),iphct,name)

         iphct = iphct + 1
         ctot(iphct) = tot
c                                 set ieos flag to that of the first
c                                 real entity in the make definition
         ieos = eos(mkind(i,1))

         call loadit (iphct,.true.)

         make(iphct) = i
c                                pointer used for iemod.
         imak(i) = iphct

      end do 
c                                 get/save data for makes, this
c                                 data is saved in the arrays thermo
c                                 and cp by loadit, but are not counted,
c                                 i.e., the counters ipoint and iphct
c                                 are reset. soload will then load the
c                                 cp array over the values loaded here,
c                                 but thermo should not be affected. gmake
c                                 then gets the data using the array 
c                                 mkind. the names array will also be 
c                                 overwritten.
      jphct = iphct
c                                 read header
      call eohead (n2)

      do 

         call getphi (name,eof)

         if (eof) exit

         do i = 1, inames

            if (name.ne.mnames(i)) cycle
c                                 matched a name
            iphct = iphct + 1
c                                 store thermodynamic parameters:
            call loadit (iphct,.false.)

         end do 

      end do 

      do i = 1, nmak
c                                remake pointer array for makes 
         do j = 1, mknum(i)
            do k = jphct + 1, iphct
               if (names(k).ne.mknam(i,j)) cycle
               mkind(i,j) = k
            end do
         end do 
      end do  
c                                reset ipoint counter, but do not 
c                                reset iphct, because the compositions
c                                of the make phases are necessary for
c                                chemical potential variables. 
      iphct = jphct 
      ipoint = jphct

      do i = 1, nmak
c                                make an iemod flag for made
c                                endmembers:   
         do j = 1, mknum(i)
            if (iemod(mkind(i,j)).eq.0) exit 
         end do 

         if (j.le.mknum(i)) cycle

         iemod(imak(i)) = iemod(mkind(i,1))

      end do 

1000  format ('**error ver007** at least one of the reference ',
     *        'phases:',/,5(a,1x))
1010  format ('needed to define an independent fugacity/activity ',
     *    'variable is missing from the',/,'thermodynamic data file',/)
1230  format ('**error ver013** ',a,' is an incorrect component'
     *       ,' name, valid names are:',/,12(1x,a))
1240  format ('check for upper/lower case matches or extra blanks',/)

      close (n2)

      end

      subroutine setvr0 (i,j)
c--------------------------------------------------------------------
c setvr1 computes nodal variables for node ij, three cases:

c icont = 1 -> independent variables are the 1st and 2nd potentials
c icont = 2 -> 1st independent variable is a composition variable,  
c              2nd independent variable is the 1st potential (iv1)
c icont = 3 -> independent variables are compositional variables

c---------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer i,j

      double precision v,tr,pr,r,ps
      common/ cst5  /v(l2),tr,pr,r,ps

      double precision vmax,vmin,dv
      common/ cst9  /vmax(l2),vmin(l2),dv(l2)

      integer ipot,jv,iv1,iv2,iv3,iv4,iv5
      common / cst24 /ipot,jv(l2),iv1,iv2,iv3,iv4,iv5

      integer jvar
      double precision var,dvr,vmn,vmx
      common/ cxt18 /var(l3),dvr(l3),vmn(l3),vmx(l3),jvar

      integer icont
      double precision dblk,cx
      common/ cst314 /dblk(3,k5),cx(2),icont
c----------------------------------------------------------------------

      if (icont.eq.1) then 

         v(iv1) = vmin(iv1) + (i-1)*dv(iv1)
         v(iv2) = vmin(iv2) + (j-1)*dv(iv2)
         call incdp0

      else if (icont.eq.2) then 

         v(iv1) = vmin(iv1) + (j-1)*dv(iv1)
         call incdep (iv1)

         cx(1) =  (i-1)*dvr(1)
         call setblk 

      else 

         cx(1) = (i-1) * dvr(1)
         cx(2) = (j-1) * dvr(2)
         call setblk

      end if 

      end

      subroutine setblk
c-----------------------------------------------------------------------
c for gridded minimization setblk computes the bulk composition
c and initializes the arrays for lpopt.
c-----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      double precision x0

      integer i,j

      integer npt,jdv
      logical fulrnk
      double precision cptot,ctotal
      common/ cst78 /cptot(k5),ctotal,jdv(k19),npt,fulrnk

      double precision a,b,c
      common/ cst313 /a(k5,k1),b(k5),c(k1)

      integer jbulk
      double precision cblk
      common/ cst300 /cblk(k5),jbulk

      integer icont
      double precision dblk,cx
      common/ cst314 /dblk(3,k5),cx(2),icont

      integer hcp,idv
      common/ cst52  /hcp,idv(k7) 

      integer iopt
      logical lopt
      double precision nopt
      common/ opts /nopt(i10),iopt(i10),lopt(i10)
c-----------------------------------------------------------------------
      x0 = 1d0

      if (lopt(1)) then 
c                                 closed composition
         do j = 1, icont-1
            x0 = x0 - cx(j)
         end do 

      end if 

      do j = 1, jbulk
         cblk(j) = x0*dblk(1,j)
      end do 
         
      do j = 1, jbulk
         do i = 2, icont 
            cblk(j) = cblk(j) + cx(i-1)*dblk(i,j)
         end do 
      end do
c                                 modify cblk here to change the 
c                                 composition before minimization.
      ctotal = 0d0 
c                                 get total moles to compute mole fractions             
      do i = 1, hcp
         ctotal = ctotal + cblk(i)
      end do

      do i = 1, hcp 
         b(i) = cblk(i)/ctotal
      end do

      end 

      subroutine setvar 
c--------------------------------------------------------------------
c setvar initializes the variables for gridded minimization, three
c cases:

c icont = 1 -> independent variables are the 1st and 2nd potentials
c icont = 2 -> 1st independent variable is a composition variable,  
c              2nd independent variable is the 1st potential (iv1)
c icont = 3 -> independent variables are compositional variables
c---------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer i,j

      double precision rloopy,rloopx

      double precision v,tr,pr,r,ps
      common/ cst5  /v(l2),tr,pr,r,ps

      double precision vmax,vmin,dv
      common/ cst9  /vmax(l2),vmin(l2),dv(l2)

      integer ipot,jv,iv1,iv2,iv3,iv4,iv5
      common / cst24 /ipot,jv(l2),iv1,iv2,iv3,iv4,iv5

      integer jbulk
      double precision cblk
      common/ cst300 /cblk(k5),jbulk

      integer jlow,jlev,loopx,loopy,jinc
      common/ cst312 /jlow,jlev,loopx,loopy,jinc

      integer jvar
      double precision var,dvr,vmn,vmx
      common/ cxt18 /var(l3),dvr(l3),vmn(l3),vmx(l3),jvar

      integer icont
      double precision dblk,cx
      common/ cst314 /dblk(3,k5),cx(2),icont

      integer isec,icopt,ifull,imsg,io3p
      common/ cst103 /isec,icopt,ifull,imsg,io3p
c----------------------------------------------------------------------

      rloopy = dfloat(loopy-1)
      rloopx = dfloat(loopx-1)
c                                 for 1d calculations
      if (rloopx.eq.0) rloopx = rloopy

      do i = 1, ipot
         v(jv(i)) = vmin(jv(i))
      end do

      call incdp0

      if (icopt.eq.10) then 
c                                using nodal coordinate system
         dvr(1) = 1

      else if (icont.eq.1) then 
c                                v(iv1) on x, v(iv2) on y
         dv(iv1) = (vmax(iv1) - vmin(iv1))/rloopx
         dvr(1) = dv(iv1)

         dv(iv2) = (vmax(iv2) - vmin(iv2))/rloopy
         dvr(2) = dv(iv2)

      else if (icont.eq.2) then 
c                               composition is on x, v(iv1) on y
         dvr(1) = 1d0/rloopx

         dv(iv1) = (vmax(iv1) - vmin(iv1))/rloopy
         dvr(2) = dv(iv1)

      else 
c                                compositions on both axes
         dvr(1) = 1d0/rloopx
         dvr(2) = 1d0/rloopy 
         cx(1) = 0d0
         cx(2) = 0d0

      end if 
c                                set the bulk composition:
      do j = 1, jbulk
         cblk(j) = dblk(1,j)
      end do 

      end 

      subroutine inipot 
c--------------------------------------------------------------------
c setvar initializes the independent potential variables to their 
c minimum values
c---------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer i

      double precision v,tr,pr,r,ps
      common/ cst5  /v(l2),tr,pr,r,ps

      double precision vmax,vmin,dv
      common/ cst9  /vmax(l2),vmin(l2),dv(l2)

      integer ipot,jv,iv
      common / cst24 /ipot,jv(l2),iv(l2)
c----------------------------------------------------------------------
c                                 initialize potentials
      do i = 1, ipot
         v(jv(i)) = vmin(jv(i))
      end do 
c                                 set dependent potential, if it exists
      call incdp0

      end 

      subroutine getcmp (jd,id,ids)
c-----------------------------------------------------------------------
c getcmp gets the composition of pseudocompund id, where:
c  if ids < 0, -ids points to the composition of a true compound in array cp
c  if ids > 0, id points to the composition of a solution defined in terms
c              on endmember fractions defined and saved by routine resub
c              in array zcoor.
c the composition is saved in arrays cp3 and x3, entry jd
c-----------------------------------------------------------------------
      implicit none
 
      include 'perplex_parameters.h'

      integer i,j,id,jd,ids
c                                 -------------------------------------
c                                 global variables:
      integer icomp,istct,iphct,icp
      common/ cst6  /icomp,istct,iphct,icp

      double precision cp
      common/ cst12 /cp(k5,k1)
c                                 bookkeeping variables
      integer ksmod, ksite, kmsol, knsp
      common/ cxt0  /ksmod(h9),ksite(h9),kmsol(h9,m4,mst),knsp(m4,h9)

      integer lstot,mstot,nstot,ndep,nord
      common/ cxt25 /lstot(h9),mstot(h9),nstot(h9),ndep(h9),nord(h9)
c                                 working arrays
      double precision z, pa, p0a, x, w, y
      common/ cxt7 /y(m4),z(m4),pa(m4),p0a(m4),x(mst,msp),w(m1)
c                                 single site solution coordinates:
      integer jend
      common/ cxt23 /jend(h9,k12)
c                                 refined compositions and solution 
c                                 pointer
      integer kkp,np,ncpd,ntot
      double precision cp3,amt
      common/ cxt15 /cp3(k0,k5),amt(k5),kkp(k5),np,ncpd,ntot

      logical lorder, lexces, llaar, lrecip
      common/ cxt27 /lorder(h9),lexces(h9),llaar(h9),lrecip(h9)

      integer ikp
      common/ cst61 /ikp(k1)

      double precision cp0
      common/ cst71 /cp0(k0,k5)

      integer iam
      common/ cst4 /iam

      integer npt,jdv
      logical fulrnk
      double precision cptot,ctotal
      common/ cst78 /cptot(k5),ctotal,jdv(k19),npt,fulrnk
c----------------------------------------------------------------------

      kkp(jd) = ids
      cptot(jd) = 0d0

      if (ids.lt.0) then 
c                                 simple compounds
         if (iam.ne.5) then
c                                 all programs except frendly 
            do i = 1, icomp
               cp3(i,jd) = cp(i,-ids)
            end do 
c                                 check if it's a solution endmember
            if (ikp(-ids).ne.0) call endcp (jd,-ids,ikp(-ids))
   
         else 
c                                 frendly 
            do i = 1, k0
               cp3(i,jd) = cp0(i,-ids)
            end do 

         end if 

      else
c                                 solutions, initialize
         do i = 1, icomp
            cp3(i,jd) = 0d0
         end do
c                                 get the x(i,j) coordinates for the
c                                 composition from the zcoor array,
c                                 this routine also saves a copy of the
c                                 xcoordinates in x3(jd,i,j)
         call getxz (jd,id,ids)
c                                 convert the x(i,j) coordinates to the
c                                 geometric y coordinates
         call xtoy (ids)

         if (lrecip(ids)) then
c                                 get the p' coordinates (amounts of 
c                                 the independent endmembers)     
            call getpp (ids) 

            do i = 1, lstot(ids)
               do j = 1, icomp 
                  cp3(j,jd) = cp3(j,jd) + p0a(i) * cp(j,jend(ids,2+i))
               end do 
            end do          

         else 
c                                 solutions with no dependent endmembers:
c                                 y coordinates used to compute the composition
            do i = 1, mstot(ids)
               do j = 1, icomp
                  cp3(j,jd) = cp3(j,jd) + y(i) * cp(j,jend(ids,2+i))
               end do
            end do

         end if 

      end if 

      do i = 1, icp
         cptot(jd) = cptot(jd) + cp3(i,jd)
      end do 

      end 

      subroutine inblnk (text,char)
c----------------------------------------------------------------------
c inblnk - scan text to last '/' or '\' and insert char after.
 
c     text - character string 
c----------------------------------------------------------------------
      implicit none

      integer i, nchar
 
      character text*(*), bitsy(400)*1, char*1 
c----------------------------------------------------------------------
      nchar = len(text) 
      read (text,1000) (bitsy(i), i = 1, nchar)
c                                 scan for blanks:

      do i = nchar,1,-1
c                                 this line may cause problems
c                                 on some operating systems that 
c                                 recognize the backslash as an escape
c                                 character.
         if (bitsy(i).eq.'/') goto 10
         bitsy(i+1) = bitsy(i)
      end do 

      i = 0

10    bitsy(i+1) = char

      write (text,1000) (bitsy(i), i = 1, nchar)
 
1000  format (400a1)
      end

      subroutine matchj (unnown,itis)
c----------------------------------------------------------------------
 
c matchj - subroutine to determine if the string unnown is a valid
c          solution or compound name.
 
c   itis = -id if compound
c   itis = ikp if solution 
c   itis = 0 if invalid
c----------------------------------------------------------------------
      implicit none

      integer i, itis
 
      character*10 unnown
 
      include 'perplex_parameters.h'
 
      integer isoct
      common/ cst79 /isoct

      integer icomp,istct,iphct,icp
      common/ cst6  /icomp,istct,iphct,icp

      character names*8
      common/ cst8 /names(k1)

      character sname*10
      common/ csta7 /sname(h9)
c---------------------------------------------------------------------- 
 
      itis = 0

      do i = 1, isoct
         if (unnown.eq.sname(i)) then
             itis = i
             goto 99
         end if
      end do

      do i = 1, iphct
         if (unnown.eq.names(i)) then
            itis = -i
            goto 99
         end if
      end do 

99    end

      subroutine maktit 
c-----------------------------------------------------------------------
c create a title for graphics output, the title consists of the 
c calculation title + saturation hierarchy (provided one is 
c specified) and is the first two elements of title (csta8).
c if icopt = 1 or 3, also adds a blurb about reaction convention.

c title is max 3 lines, but four lines are written to be consistent
c with old plot file formats written by frendly, pt2curv etc.
c-----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer i

      character*162 title
      common/ csta8 /title(4)

      character*8 vname,xname     
      common/ csta2  /xname(k5),vname(l2)

      integer ivfl
      common/ cst102 /ivfl

      character*5 cname
      common/ csta4 /cname(k5)

      integer isec,icopt,ifull,imsg,io3p
      common/ cst103 /isec,icopt,ifull,imsg,io3p

      integer iff,idss,ifug,ifyn,isyn
      common/ cst10  /iff(2),idss(h5),ifug,ifyn,isyn

      integer ids,isct,icp1,isat,io2
      common/ cst40 /ids(h5,h6),isct(h5),icp1,isat,io2

      integer icomp,istct,iphct,icp
      common/ cst6  /icomp,istct,iphct,icp  
c-----------------------------------------------------------------------
      do i = 2, 4
         title(i) = ' '
      end do                              
c                               saturated and buffered component names:
      if (isyn.eq.0) then 
         write (title(2),1070) (cname(i+icp), i= 1, isat)
      else 
         write (title(2),1000) ' '
      end if 
c                                 reaction convention
      if (icopt.eq.1.or.icopt.eq.3) write (title(3),1080) vname(ivfl)

      do i = 1, 3
         call deblnk (title(i))
      end do 

1000  format (a)
1070  format ('Component saturation hierarchy: ',7(a,1x))
1080  format ('Reaction equations are written with the high ',
     *         a,'assemblage to the right of the = sign')

      end

      subroutine rdain
c-----------------------------------------------------------------------
c a subprogram to read auxilliary input file for 2d fractionation 
c calculations, called by VERTEX and WERAMI
c-----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer maxlay

      parameter (maxlay=6) 

      integer i,ierr

      double precision zlayer

      character*100 name

      integer icomp,istct,iphct,icp
      common/ cst6  /icomp,istct,iphct,icp

      character*100 prject,tfname
      common/ cst228 /prject,tfname

      integer ipot,jv,iv
      common/ cst24 /ipot,jv(l2),iv(l2)

      double precision vmax,vmin,dv
      common/ cst9  /vmax(l2),vmin(l2),dv(l2)

      integer gloopy,ilay,irep
      double precision a0,a1,a2,a3,b0,b1,b2,b3,c0,c1,c2,c3,dv1dz,
     *               zbox,iblk
      common/ cst66 /a0,a1,a2,a3,b0,b1,b2,b3,c0,c1,c2,c3,dv1dz,
     *               zbox,iblk(maxlay,k5),gloopy,ilay,irep(maxlay)
c-----------------------------------------------------------------------
c                                 look for input data from a file 
c                                 of type aux
      call mertxt (name,prject,'.aux',0)
      open (n8,file=name,status='old',iostat=ierr)

      if (ierr.ne.0) call error (51,zbox,gloopy,name) 
c                                 set the number of independent variables
c                                 to 1 (the independent path variable must
c                                 be variable jv(1), and the dependent path
c                                 variable must be jv(2), the path variables
c                                 can only be pressure and temperature
      ipot = 1
c                                 in old versions this was the number of steps 
c                                 along the path, in 07 loopy is now set via
c                                 jlow/1dpath (above). gloopy is not used as a 
c                                 flag if top layer composition is to be refreshed
c                                 after each step (gloopy=999).
      read (n8,*) gloopy
c                                 thickness of a box in column
      read (n8,*) zbox 
c                                 gradient in variable jv(1) with z, jv(1)
c                                 is the independent variable, for subduction
c                                 this is logically pressure, i.e.,
c                                 dp(bar)/dz(m)
      read (n8,*) dv1dz 
c                                 now we need a path function for the dependent
c                                 variable, here we take a function defined in
c                                 terms of the absolute depth of the top of the
c                                 column (z0) and the relative depth (dz) within
c                                 the column
c                                 
c                                 v2 = a(z0)*dz^2 + b(z0)*dz + c(z0)

c                                 e.g., T(K) =  a(z0)*dz^2 + b(z0)*dz + c(z0)

c                                 where a(z0) = a0 + a1*z0 + a2*z0^2 + a3*z0^3 + ...
c                                 b(z0) = b0 + b1*z0 + b2*z0^2 + b3*z0^3 + ...
c                                 c(z0) = c0 + c1*z0 + c2*z0^2 + c3*z0^3 + ...
      read (n8,*) a0, a1, a2, a3
      read (n8,*) b0, b1, b2, b3
      read (n8,*) c0, c1, c2, c3
c                                 get the initial global composition array
c                                 consisting of ibox compositions defined 
c                                 in terms of icp components. this read
c                                 statement assumes that H2O an CO2 (if 
c                                 thermodynamic components) are the 1st and
c                                 2nd components (if present). 
      ilay = 0
      vmax(2) = 0d0
      vmin(2) = 0d0
c                                 number of nodes with appended composition
c                                 end of data indicated by zero 
      do 

         read (n8,*) zlayer

         if (zlayer.eq.0) exit 

         ilay = ilay + 1

         if (ilay.eq.maxlay) then 
            write (*,*) 'increase maxlay in routine FRAC2D'
            stop
         end if 

         read (n8,*) (iblk(ilay,i),i=1,icp)

         irep(ilay) = idint(zlayer/zbox)
c                                 set the y coodinate to depth below top
         vmin(2) = vmin(2) - irep(ilay)*zbox

      end do 

      close (n8)

      end 

      subroutine fr2dpt (p0,dz)
c----------------------------------------------------------------------
c subroutine to set p-t variables from i-j coordinates in 2d-fractionation
c calculations, called by VERTEX and WERAMI
c----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer maxlay

      parameter (maxlay=6) 

      double precision p0, z0, dz

      integer gloopy,ilay,irep
      double precision a0,a1,a2,a3,b0,b1,b2,b3,c0,c1,c2,c3,dv1dz,
     *               zbox,iblk
      common/ cst66 /a0,a1,a2,a3,b0,b1,b2,b3,c0,c1,c2,c3,dv1dz,
     *               zbox,iblk(maxlay,k5),gloopy,ilay,irep(maxlay)

      double precision v,tr,pr,r,ps
      common/ cst5  /v(l2),tr,pr,r,ps
c----------------------------------------------------------------------
c                                 convert to depth at top of column
      z0 = p0/dv1dz
c                                 set the independent variable
      v(1) = p0 + dz * dv1dz   
c                                 set the dependent variable
      v(2) = (a0 + a1*z0 + a2*z0**2 + a3*z0**3)*dz**2 
     *     + (b0 + b1*z0 + b2*z0**2 + b3*z0**3)*dz 
     *     +  c0 + c1*z0 + c2*z0**2 + c3*z0**3                       
      end 
   
      subroutine getpp (id)
c-----------------------------------------------------------------------
c getpp computes the amounts of the indepdendent edmembers of a reciprocal
c solution in terms of the disordered endmembers (i.e., the p coordinates
c corrected for the amounts of the ordered species if present [ksmod=8]).
c-----------------------------------------------------------------------
      implicit none
 
      include 'perplex_parameters.h'

      integer id

      integer lstot,mstot,nstot,ndep,nord
      common/ cxt25 /lstot(h9),mstot(h9),nstot(h9),ndep(h9),nord(h9)
c----------------------------------------------------------------------
c                                  first convert the istot disordered
c                                  endmember coordinates to the 
c                                  kstot + nord p0 coordinates
      call y2p0 (id) 
c                                  decompose ordered species
      if (nord(id).gt.0) call p0dord (id)

      end

c-----------------------------------------------------------------------
 
c FLIB - fluid phase subroutines common to FRENDLY, VERTEX, COHSRK,
c        RK, and BUILD.

c Unless otherwise noted, the subroutines herein were written by
c J. A. D. Connolly.
 
c Please do not distribute this source.
      
c-----------------------------------------------------------------------
      subroutine cfluid (fo2,fs2)
c-----------------------------------------------------------------------
c subroutine cfluid call fluid equations of state depending on
c the value of ifug. The GCOH eos return ln(fo2) as fo2. 
c-----------------------------------------------------------------------
      implicit none
 
      include 'perplex_parameters.h'

      integer i
 
      double precision x(2),fo2,fs2
 
      integer iff,idss,ifug,ifyn,isyn
      common/ cst10 /iff(2),idss(h5),ifug,ifyn,isyn

      double precision f
      common/ cst11 /f(2)

      double precision p,t,xco2,u1,u2,tr,pr,r,ps
      common/ cst5   /p,t,xco2,u1,u2,tr,pr,r,ps
c-----------------------------------------------------------------------
      if (xco2.gt.1d0) then 
         xco2 = 1d0
      else if (xco2.lt.0d0) then 
         xco2 = 0d0
      end if 

      x(2) = xco2
      x(1) = 1d0 - xco2
 
      if (ifug.eq.0) then 
         call mrk
      else if (ifug.eq.1) then 
         call hsmrk
      else if (ifug.eq.2.or.ifug.eq.23) then 
         call qrkmrk
      else if (ifug.eq.3) then 
         call saxfei
      else if (ifug.eq.4) then 
         call brmrk
      else if (ifug.eq.5) then 
         call hprk
      else if (ifug.eq.6) then 
         call trkmrk
      else if (ifug.eq.7) then 
         call cohgra (fo2)
      else if (ifug.eq.8) then  
         call cohhyb (fo2)
      else if (ifug.eq.9) then 
         call cohfit (fo2)
      else if (ifug.eq.10) then  
         call hocgra (fo2)
      else if (ifug.eq.11) then 
         call hocmrk (fo2)
      else if (ifug.eq.12) then 
         call cohsgr (fo2,fs2)
      else if (ifug.eq.13) then 
         call hh2ork (fo2)
      else if (ifug.eq.14) then 
         call pshp 
      else if (ifug.eq.1) then 
         call lohork (fo2)
      else if (ifug.eq.1) then 
         call homrk (fo2)
      else if (ifug.eq.1) then 
         call hosmrk (fo2,fs2)
      else if (ifug.eq.18) then 
         call dhhsrk
      else if (ifug.eq.19.or.ifug.eq.20) then 
         call xoxsrk (fo2,fs2)
      else if (ifug.eq.21) then 
         call hcrk 
      else if (ifug.eq.22) then 
         call dhcork 
      else if (ifug.eq.24) then 
         call cohngr (fo2)
      else if (ifug.eq.25) then 
         call waddah
      else 
         call error (11,xco2,ifug,'EoS (routine CFLUID)') 
      end if 

      do i = 1, 2
         if (x(i).gt.1d-38) cycle 
         f(i) = -9.9d9
      end do 

      end

      subroutine rfluid (irk,ifug)
c---------------------------------------------------------------------
c irk = 1 - write/read prompt for fluid equations of state
c irk = 2 - write fluid equation of state for outtit to unit n3
c irk = 3 - write fluid equation of state to console
c---------------------------------------------------------------------
      implicit none
   
      include 'perplex_parameters.h'

      integer nrk,i,irk,ifug,ier

      parameter (nrk=25)
   
      character rkname(0:nrk)*60, y*1

      character vname*8, xname*8
      common / csta2 /xname(k5),vname(l2)

      double precision buf
      common/ cst112 /buf(5)

      integer ibuf,hu,hv,hw,hx   
      double precision dlnfo2,elag,gz,gy,gx
      common/ cst100 /dlnfo2,elag,gz,gy,gx,ibuf,hu,hv,hw,hx

      integer ipot,jv,iv
      common/ cst24 /ipot,jv(l2),iv(l2)

      save rkname 

      data (rkname(i), i = 0, 11)/
     *  'X(CO2) Modified Redlich-Kwong (MRK/DeSantis/Holloway)',
     *  'X(CO2) Kerrick & Jacobs 1981 (HSMRK)',
     *  'X(CO2) Hybrid MRK/HSMRK',
     *  'X(CO2) Saxena & Fei 1987 pseudo-virial expansion',
     *  'Bottinga & Richet 1981 (CO2 RK)',
     *  'X(CO2) Holland & Powell 1991, 1998 (CORK)',
     *  'X(CO2) Hybrid Haar et al 1979/CORK (TRKMRK)',
     *  'f(O2/CO2)-f(S2) Graphite buffered COHS MRK fluid',
     *  'f(O2/CO2)-f(S2) Graphite buffered COHS hybrid-EoS fluid',
     *  'Max X(H2O) GCOH fluid Cesare & Connolly 1993',
     *  'X(O) GCOH-fluid hybrid-EoS Connolly & Cesare 1993',
     *  'X(O) GCOH-fluid MRK Connolly & Cesare 1993'/

      data (rkname(i), i = 12, nrk)/
     *  'X(O)-f(S2) GCOHS-fluid hybrid-EoS Connolly & Cesare 1993',
     *  'X(H2) H2-H2O hybrid-EoS',
     *  'X(CO2) Pitzer & Sterner 1994; Holland & Powell mixing 2003',
     *  'X(H2) low T H2-H2O hybrid-EoS',
     *  'X(O) H-O HSMRK/MRK hybrid-EoS',
     *  'X(O)-f(S2) H-O-S HSMRK/MRK hybrid-EoS',
     *  'X(CO2) Delany/HSMRK/MRK hybrid-EoS, for P > 10 kb',
     *  'X(O)-X(S) COHS hybrid-EoS Connolly & Cesare 1993',
     *  'X(O)-X(C) COHS hybrid-EoS Connolly & Cesare 1993',
     *  'X(CO2) Halbach & Chatterjee 1982, P > 10 kb, hybrid-Eos',
     *  'X(CO2) DHCORK, hybrid-Eos',
     *  'Toop-Samis Silicate Melt',
     *  'f(O2/CO2)-N/C Graphite saturated COHN MRK fluid',
     *  'H2O-CO2-NaCl Aranovich et al. 2010'/

      if (irk.eq.2) then
         write (n3,1060) rkname(ifug)
         goto 99
      else if (irk.eq.3) then 
         write (*,1060) rkname(ifug)
         goto 99         
      end if     

      elag = 0d0
      ibuf = 1
      dlnfo2 = 0d0

10    write (*,1000)

      do i = 0, nrk
         write (*,1070) i,rkname(i)
      end do 

      read (*,*,iostat=ier) ifug
      if (ifug.gt.nrk) ier = 1
      call rerror (ier,*10)

      if (ifug.eq.12.or.ifug.eq.17) then
c                                 COHS & HOS equations of state
c                                 get sulfur fugacity constraint:
         vname(3) = 'X(O)'
12       write (*,1090) 
         read (*,*,iostat=ier) ibuf
         if (ibuf.gt.3.or.ibuf.lt.1) ier = 1
         call rerror (ier,*12)

         if (ibuf.eq.2) then 
c                                 if ibuf = 2 dlnfo2 is the fe/s
c                                 of pyrrhotite
13          write (*,1100) 
            read (*,*,iostat=ier) dlnfo2
            call rerror (ier,*13)
         else if (ibuf.eq.3) then
c                                 if ibuf = 2 dlnfo2 is the fs2
14          write (*,1110)
            read (*,*,iostat=ier) dlnfo2
            call rerror (ier,*14)
            dlnfo2 = 2.302585093d0 * dlnfo2

         end if 

      else if (ifug.gt.9.and.ifug.lt.13 .or. 
     *         ifug.gt.13.and.ifug.lt.22) then

         if (ifug.ne.18) vname(3) = 'X(O)'

      else if (ifug.eq.13) then
 
         vname(3) = 'X(H2)'

      else if (ifug.ge.7.and.ifug.le.9.or.ifug.eq.24) then
c                                 chosen COH speciation option
c                                 check that XCO2 isn't a independent
c                                 variable:
         if (iv(1).eq.3.or.iv(2).eq.3) then 
            call warn (172,dlnfo2,ifug,'RFLUID')
            goto 10
         end if
      
         if (ifug.eq.9) goto 99 
c                                 change default buffer
20       write (*,1020)
         read (*,1030) y
         ibuf = 2
         dlnfo2 = 0d0
         if (y.eq.'y'.or.y.eq.'Y') then 
            write (*,1010) 
            read (*,*,iostat=ier) ibuf
            call rerror (ier,*20)
            if (ibuf.gt.5.or.ibuf.lt.1) then
               call warn (173,dlnfo2,ifug,'RFLUID')
               goto 20
            end if 
c                                ibuf = 5, define own buffer
            if (ibuf.eq.5) then
45             write (*,1180)  
               read (*,*,iostat=ier) buf
               call rerror (ier,*45)
               goto 30
c                                ibuf = 3, constant fo2.
            else if (ibuf.eq.3) then
40             write (*,1140) 
               read (*,*,iostat=ier) dlnfo2
               call rerror (ier,*40)
               dlnfo2 = 2.302585093d0 * dlnfo2
               goto 50
            end if 
c                                ibuf 2 or 1, permit del(fo2)
30          write (*,1040) 
            read (*,1030) y
            if (y.eq.'y'.or.y.eq.'Y') then 
               write (*,1050) 
               read (*,*,iostat=ier) dlnfo2
               call rerror (ier,*30)
               dlnfo2 = 2.302585093d0 * dlnfo2
            end if 
         end if
      end if 
c                                for graphite EoS's allow
c                                reduced gph activity:
c                                this could be done for all
c                                but here we only allow simple
c                                EoS's because the X(C),S/C and N/C
c                                routines use the variable elag to
c                                store these ratios.
50    if (ifug.ge.7.and.ifug.le.12.and.ifug.ne.9) then
         write (*,1170)
         read (*,1030) y
         hu = 0 
         if (y.eq.'y'.or.y.eq.'Y') hu = 1

         write (*,1120) 
         read (*,1030) y
         if (y.eq.'y'.or.y.eq.'Y') then
            write (*,1130) 
            read (*,*,iostat=ier) elag
            call rerror (ier,*50)
            elag = dlog (elag)
         end if

      else if (ifug.eq.19) then 
c                                for XO-XS EoS get S/C
         write (*,1150) 
         read (*,*,iostat=ier) elag
         call rerror (ier,*50)

      else if (ifug.eq.20) then
c                                for XO-XC EoS get X(C)
         write (*,1160) 
         read (*,*,iostat=ier) elag
         call rerror (ier,*50)
    
      else if (ifug.eq.25) then 
c                                special conditions for H2O-CO2-NaCl EoS
         write (*,1200)
         read (*,*,iostat=ier) ibuf
         call rerror (ier,*50)
         if (ibuf.lt.1.or.ibuf.gt.2) then
            write (*,*) 'invalid choice, try again ...'
            goto 50 
         end if 
c                                get the salt content (elag):
         if (ibuf.eq.1) then 
            write (*,1210) 'weight'
         else if (ibuf.eq.2) then 
            write (*,1210) 'molar '
         end if 

         read (*,*,iostat=ier) elag
         call rerror (ier,*50)
         if (elag.gt.1d0.or.elag.lt.0d0) then
            write (*,*) 'salt fraction must be > 0 and < 1, try again'
            goto 50 
         end if 

         vname(3) = 'Y(CO2)*'

      end if 

1000  format (/,'Select fluid equation of state:',/)
1010  format (/,'Select buffer: ',//,
     *          ' 1 - aQFM, 298-1200K',/,
     *          ' 2 - Maximum H2O content, 523-1273K, .5-30kbar',/,
     *          ' 3 - user specified f(O2)',/,
     *          ' 4 - aQ-Ru-Cc-Tn-Gph',/,
     *          ' 5 - ln(f(O2))= a + (b + c*p)/t + d/t**2 + e/t**3 ',/)
1020  format (/,'Modify default buffer (max H2O) (Y/N)? ')
1030  format (a)
1040  format (/,'Modify calculated fO2 by a constant (Y/N)?',/)
1050  format (/,'Enter constant in units of log10(fO2):',/)
1060  format (/,'Fluid equation of state: ',a)
1070  format (2x,i2,' - ',a)
1090  format (/,'Choose a buffer:',//
     *         ,'  1 - Pyrite + Pyrrhotite',
     *        /,'  2 - Pyrrhotite',/,'  3 - f(S2)',/)
1100  format (/,'Enter atomic Fe/S of pyrrhotite:',/)
1110  format (/,'Enter log10[f(S2)]:',/)
1120  format (/,'Reduce graphite activity (Y/N)?',/)
1130  format (/,'Enter activity of graphite:',/)
1140  format (/,'Enter log10[f(O2)]:',/)
1150  format (/,'Enter X(S), i.e., {n(S)/[n(S) + n(C)]}:',/)
1160  format (/,'Enter X(C), i.e., {n(C)/[n(S)+n(C)+n(O)+n(H)]}:',/)
1170  format (/,'Compute f(H2) & f(O2) as the dependent fugacities',
     *        /,'(do not unless you project through carbon) (Y/N)?',/)
1180  format ('Enter a-e :',/)
1200  format (/,'For this EoS Y(CO2)* is defined as:',/,
     *          '  Y(CO2)* = n(CO2)/[n(H2O)+n(CO2)]',/,
     *          'i.e., Y(CO2)* may vary from 0 -> 1 ',
     *          'regardless of salt content',//,
     *          'Choose how salt content is to be specified:',/,
     *          ' 1 - weight fraction',/,
     *          ' 2 - mole fraction',/)
1210  format (/,'Enter ',a,' salt fraction (0->1) in the fluid:',/)

99    end 

      subroutine cohsgr (fo2,fs2)
c----------------------------------------------------------------------
c program to calculate graphite saturated C-H-O-S speciation as 
c a function of XO using an MRK/HSMRK hybrid. 
c Species are CO2 CH4 CO H2 H2O H2S O2 SO2 COS. The latter 3 species
c are only significant for reduced graphite activities. 
c----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer ins(nsp),nit,ier

      double precision fo2,fs2,tol,oh2o,kh2s,kso2,kcos,ghh2o,ghco2,
     *                 ghch4,kh2o,kco2,kco,kch4,c1,c2,c3,c4,c5,c6,c7,
     *                 ek1,ek2,ek3,ek4,ek5,ek6,ek7

      integer ibuf,hu,hv,hw,hx
      double precision rat,elag,gz,gy,gx
      common/ cst100 /rat,elag,gz,gy,gx,ibuf,hu,hv,hw,hx

      double precision vol
      common/ cst26 /vol

      double precision gmh2o,gmco2,gmch4,vm
      common/ cstchx /gmh2o,gmco2,gmch4,vm(3)

      double precision xh2o,xco2,xco,xch4,xh2,xh2s,xo2,xso2,xcos,xn2,
     *                 xnh3,gh2o,gco2,gco,gch4,gh2,gh2s,go2,gso2,gcos,
     *                 gn2,gnh3,v
      common / cstcoh /xh2o,xco2,xco,xch4,xh2,xh2s,xo2,xso2,xcos,xn2,
     *                 xnh3,gh2o,gco2,gco,gch4,gh2,gh2s,go2,gso2,gcos,
     *                 gn2,gnh3,v(nsp)

      double precision p,t,xo,u1,u2,tr,pr,r,ps
      common / cst5 /p,t,xo,u1,u2,tr,pr,r,ps

      double precision fh2o,fco2
      common/ cst11 /fh2o,fco2

      save tol, ins

      data tol, ins/ .0001d0, 1,2,3,4,5,6,7,8,9,0,0/

      nit = 0
      oh2o = 2d0
      xh2 = 0.00001d0   
c                                fs2 = 1/2 ln (fs2),
c                                k's are ln(k)
      call setfs2 (fs2,kh2s,kso2,kcos)

      call setup (ghh2o,ghco2,ghch4,kh2o,kco2,kco,kch4)

      c3 = dexp (kch4) * p
      c1 = dexp (kco2 - 2d0*kco) * p 
      c2 = dexp (kh2o - kco) * p
      c4 = dexp (kh2s + fs2)
      c5 = dexp (kcos + fs2)
      c6 = dexp (kso2 - 2d0*kco + fs2) * p
      c7 = dexp (-2d0*kco) * p

c                                outer iteration loop: 
10    ek1 = c1 * gco**2/gco2 
      ek2 = c2 * gco * gh2/gh2o
      ek3 = c3 * gh2**2/gch4 
      ek4 = c4 * gh2/gh2s
      ek5 = c5 * gco/gcos
      ek6 = c6 * gco**2/gso2
      ek7 = c7 * gco**2/go2
c                                 solve for xh2, xco
      call evlxh1 (ek1,ek2,ek3,ek4,ek5,ek6,ek7,xo,xh2,xco,ier)

      if (ier.ne.0) call warn (501,xo,ier,'COHSGR')

      xch4 = ek3 * xh2**2 
      xh2o = ek2 * xh2 * xco
      xco2 = ek1 * xco**2
      xh2s = ek4 * xh2
      xso2 = ek6 * xco**2
      xcos = ek5 * xco
      xo2  = ek7 * xco**2

      nit = nit + 1

      if (nit.gt.100) call warn (502,xo,ier,'COHSGR')        

      if (dabs(xh2o-oh2o).lt.tol*xh2o) goto 90

      oh2o = xh2o

      call mrkmix (ins, 9)

      gh2o = ghh2o * gh2o
      gco2 = ghco2 * gco2 
      gch4 = ghch4 * gch4 

      goto 10 

90    vol = vol + xh2o * vm(1)
     *          + xco2 * vm(2)
     *          + xch4 * vm(3)

      goto (91), hu

      fh2o = dlog(gh2o*p*xh2o)
      fco2 = dlog(gco2*p*xco2)
      fo2 = 2d0 * (dlog(gco*p*xco) - kco)

      goto 99

91    fh2o = dlog(gh2*p*xh2)
      fco2 = 2d0 * (dlog(gco*p*xco) - kco)

99    end

      subroutine evlxh1 (k1,k2,k3,k4,k5,k6,k7,xo,xh2,xco,ier)
      implicit none

      integer ier,it
      double precision k1,k2,k3,k4,k5,k6,k7,xo,xh2,xco,f0,e1,e2,e3,e4,
     *                 e5,e6,e7,e8,e9,e0,r0,t2,t10,t11,t15,c1,g,dg

      it = 0 
      ier = 0 

      f0 = 2d0*(k7 + k6 + k1)
      e0 = 2d0*xo
      e1 = 1d0/f0
      e2 = 1d0 + k5**2 + 2d0*(k5 + f0)
      e3 = 2d0*k2*(1d0 + k5) - 2d0*f0*(k4 + 1d0)
      e4 = k2**2 - 2d0*k3*f0
      e5 = e0 + e0*k4 
      e6 = 4d0*xo*k3
      e7 = xo - k5 - 1d0 + xo*k5
      e8 = f0 * (xo - 1d0)
      e9 = k2*(3d0* xo - 1d0)

10    r0 = xh2
      t2 = xh2**2
      t10 = e2 + e3*xh2 + e4*t2

      if (t10.lt.0d0) then
c                                 if t10 < 0, bad guess
c                                 for xh2, find roots:
         c1 = dsqrt (e3**2 - 4d0*e4*e2)
         xh2 = 0.9d0*(-c1 - e3/2d0/ e4)
         r0 = xh2 
         t2 = xh2**2
         t10 = e2 + e3*xh2 + e4*t2

      end if 

      t10 = dsqrt (t10)

      t11 = t10 - 1d0 - k2*xh2 - k5
      xco = e1*t11
      g = e5*xh2 + e6*t2 + (e7 + e8*xco + e9*xh2)*xco
      t15 = (e3+2d0*e4*xh2)/2d0/t10 - k2
      dg = e5 + 2d0*e6*xh2 + e1*t15*(e9*xh2 + e7)
     *        + t11*(2d0*e8*e1**2*t15 + e9*e1)

      xh2 = r0 - g/dg
      if (xh2.lt.0d0) xh2 = r0/2d0
c                                 converged:
      if (dabs((xh2-r0)/xh2).lt.0.1d-6) goto 999

      it = it + 1

      if (it.gt.1000) then 

         ier = 2

         goto 99

      end if 

      goto 10 

999   xco = e1*(dsqrt(e2 + (e3 + e4*xh2)*xh2) - 1d0 - k2*xh2 - k5)

99    end

      subroutine setup (ghh2o,ghco2,ghch4,kh2o,kco2,kco,kch4)  
c----------------------------------------------------------------------
c program to setup C-O-H-S speciation calculations 
c----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      double precision ghh2o,ghco2,ghch4,kh2o,kco2,kco,kch4,t2,t3,agph,
     *                 dg

      integer ins(nsp), jns(3)

      integer is,i3,ifug,i1,i2
      common/ cst10 /is(2),i3(h5),ifug,i1,i2

      double precision gmh2o,gmco2,gmch4,vm
      common/ cstchx /gmh2o,gmco2,gmch4,vm(3)

      double precision xh2o,xco2,xco,xch4,xh2,xh2s,xo2,xso2,xcos,xn2,
     *                 xnh3,gh2o,gco2,gco,gch4,gh2,gh2s,go2,gso2,gcos,
     *                 gn2,gnh3,v
      common / cstcoh /xh2o,xco2,xco,xch4,xh2,xh2s,xo2,xso2,xcos,xn2,
     *                 xnh3,gh2o,gco2,gco,gch4,gh2,gh2s,go2,gso2,gcos,
     *                 gn2,gnh3,v(nsp)

      double precision p,t,xo,u1,u2,tr,pr,r,ps
      common / cst5 /p,t,xo,u1,u2,tr,pr,r,ps

      save jns, ins

      data ins, jns/ 1,2,3,4,5,6,7,8,9,0,0,1,2,3/

      t2 = t * t
      t3 = t2 * t
c                                check if xo is <1, >0,
c                                reset if necessary
      if (xo.gt.0.9999999999d0) then
         xo = 0.9999999999d0
      else if (xo.lt.1d-8) then
         xo = 1d-8
      end if 
c                                get pure species fugacities
c                                hsmrkp used hsmrk for h2o and co2
c     call hsmrkp (ins, 9, jns, 3)
c                                replaced by hscrkp which uses CORK
c                                for h2o and CO2 and HSMRK for CH4,
c                                JADC, 4/27/04.
      call hscrkp (ins, 9, jns)

      ghh2o = gh2o/gmh2o
      ghco2 = gco2/gmco2
      ghch4 = gch4/gmch4
c                                correct activity of graphite
c                                for diamond stability if necessary:
      call dimond (agph)
c                                graphite pressure effect:
      dg = p*( 1.8042d-06 + (0.058345d0 - 8.42d-08*p)/t ) 
c                                graphite activity effect:
      if (ifug.ne.20) dg = dg + agph
c                                ln k's fitted from robie:
      kh2o = -7.028214449d0 + 30607.34044d0/t  - 475034.4632d0/t2 
     *                      + 50879842.55d0/t3
      kco2 = .04078341613d0 + 47681.676177d0/t - 134662.1904d0/t2 
     *                      + 17015794.31d0/t3 + dg
      kco =  10.32730663d0  + 14062.7396777d0/t- 371237.1571d0/t2  
     *                      + 53515365.95d0/t3 + dg
      kch4 = -13.86241656d0 + 12309.03706d0/t  - 879314.7005d0/t2 
     *                      + .7754138439d8/t3 + dg

      end 

      subroutine xoxsrk (fo2,fs2)
c----------------------------------------------------------------------
c program to calculate C-H-O-S speciation as a function of XO and XS
c or XC using an MRK/HSMRK hybrid. 
c----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer ins(nsp),nit,ier

      double precision fo2,fs2,tol,oh2o,kh2s,kso2,kcos,ghh2o,ghco2,
     *                 ghch4,kh2o,kco2,kco,kch4,c1,c2,c3,c5,c6,
     *                 ek1,ek2,ek3,ek5,ek6

      integer ibuf,hu,hv,hw,hx
      double precision rat,xs,ag,gy,gx
      common/ cst100 /rat,xs,ag,gy,gx,ibuf,hu,hv,hw,hx

      double precision vol
      common/ cst26 /vol

      double precision gmh2o,gmco2,gmch4,vm
      common/ cstchx /gmh2o,gmco2,gmch4,vm(3)

      double precision xh2o,xco2,xco,xch4,xh2,xh2s,xo2,xso2,xcos,xn2,
     *                 xnh3,gh2o,gco2,gco,gch4,gh2,gh2s,go2,gso2,gcos,
     *                 gn2,gnh3,v
      common / cstcoh /xh2o,xco2,xco,xch4,xh2,xh2s,xo2,xso2,xcos,xn2,
     *                 xnh3,gh2o,gco2,gco,gch4,gh2,gh2s,go2,gso2,gcos,
     *                 gn2,gnh3,v(nsp)

      double precision p,t,xo,u1,u2,tr,pr,r,ps
      common / cst5 /p,t,xo,u1,u2,tr,pr,r,ps

      double precision fh2o,fco2
      common/ cst11 /fh2o,fco2

      integer iff,idss,ifug,ifyn,isyn
      common/ cst10 /iff(2),idss(h5),ifug,ifyn,isyn

      save tol, ins

      data tol, ins/ .0001, 1,2,3,4,5,6,8,9,3*0/

      nit = 0
      oh2o = 2d0
      xh2 = 0.00001d0
      xh2o = 0.1d0
c                                this fs2 = 1/2 ln (fs2),
c                                k's are ln(k)
      call setfs2 (fs2,kh2s,kso2,kcos)
  
      call setup (ghh2o,ghco2,ghch4,kh2o,kco2,kco,kch4)
c
      c1 = dexp (kcos + fs2) 
      c2 = dexp (kco2 - kco - kh2o) 
      c3 = dexp (kh2s + fs2)
      c5 = dexp (kso2 + 4d0*(kco-kco2) + 2d0*kh2o + fs2)/p
      c6 = dexp (kch4 + kh2o - kco) * p * p
c                                outer iteration loop: 
10    ek1 = c1 * gco/gcos 
      ek2 = c2 * gco * gh2o/gh2/gco2
      ek3 = c3 * gh2/gh2s     
      ek5 = c5 * gco2**4 * gh2**2/gco**4/gso2/gh2o/gh2o
      ek6 = c6 * gh2**3 * gco/gh2o/gch4
c                                 solve for xh2, xco
      if (ifug.eq.19) then
         call evlxh2 (ek1,ek2,ek3,ek5,ek6,xo,xs,xh2,xco,xh2o,ier)
      else 
         call evlxh3 (ek1,ek2,ek3,ek5,ek6,xo,xs,xh2,xco,xh2o,ier)
      end if 

      if (ier.ne.0) call warn (501,xh2,ier,'XOXSRK')

      xch4 = ek6 * xco * xh2**3/xh2o
      xco2 = ek2 * xh2o * xco/xh2
      xh2s = ek3 * xh2
      xso2 = ek5 * xh2o**2/xh2**2
      xcos = ek1 * xco

      nit = nit + 1

      if (nit.gt.100) then
         call warn (175,xh2,ier,'XOXSRK')  
         goto 90
      end if     

      if (dabs(xh2o-oh2o).lt.tol*xh2o) goto 90

      oh2o = xh2o

      call mrkmix (ins, 8)

      gh2o = ghh2o * gh2o
      gco2 = ghco2 * gco2 
      gch4 = ghch4 * gch4 

      goto 10 

90    fh2o = dlog(gh2o*p*xh2o)
      fco2 = dlog(gco2*p*xco2)

      fo2 = 2d0 * (fh2o - dlog(gh2*p*xh2) - kh2o)
c                                 compute graphite activity:
      ag = fco2 - fo2 - kco2

      vol = vol + xh2o * vm(1) + xco2 * vm(2) + xch4 * vm(3)

      end

      subroutine evlxh2 (c1,c2,c3,c5,c6,xo,xs,xh2,xco,xh2o,ier)
c----------------------------------------------------------------------
      implicit none

      integer ier,jt,it

      double precision c1,c2,c3,c5,c6,c7,xo,xs,xh2,xco,xh2o,d1,d2,d3,
     *                 d4,d5,d6,d7,d8,d9,d10,d11,d12,d13,d14,d15,d16,
     *                 d17,d18,d19,d20,d21,d22,d23,d24,d25,f10,r1,g1,
     *                 g2,r0,e1,e2,e3,e4,t14,t31,t37,t39,t43,t45,g,
     *                 t27,t49,t55,t61,t65,t67,t71,t73,t74,t80,t88,t98,
     *                 dg,t10,t11,t25,f2,f3,f4,f7,f8,f9,f11,f12,t4,f13,
     *                 f1,t32,f5,f6,f,t13,t38,t47,df
c----------------------------------------------------------------------
      jt = 0 
      ier = 0 
      c7 = 2d0*c5
      d2 = c5 - xs * c5
      d3 = c3 - xs * c3
      d4 = c1 - 2d0*xs*c1 - xs
      d6 = 2d0 * c2
      d7 = xs * c2
      d8 = xs * c6
      d9 = 4d0 * c6
      d10 = 2d0 * c3
      d11 = 12d0 * c6
      d12 = 5d0 * d8
      d25 = d10 + 2d0 
      f10 = 3d0*d2

100   r1 = xh2o

      it = 0 
      ier = 0 

      d1 = xh2o**2
      d5 = c7 * d1
      d13 = d7 * d1
      d14 = 2d0*d4*xh2o
      d15 = d2*d1
      d16 = d3*xh2o
      d17 = d4*xh2o  
      d18 = -3d0* d16
      d19 = -4d0*c5*d1
      d20 = 3d0*xh2o
      d21 = d9/xh2o
      d22 = d11*d3
      d23 = d11/xh2o
      d24 = d15*xh2o

      g1 = -6d0*c2*d1*d3
      g2 = d6*xh2o
c                                 solve g for xh2, guessed xh2o
10    r0 = xh2
c                                 evaluate g:
      e1 = xh2**2
      e2 = e1*xh2
      e3 = e2*xh2
      e4 = e3*xh2
      t14 = d24 + d16*e2
      t31 = d17*e1 - xh2*d13 - d8*e4
      t39 = -t14/t31
      t37 = g2*t39/xh2
      t43 = d5/e1
      t45 = c1*t39

      g = (t37 + t39 + t43 + xh2o + t45)/
     *    (t37 + t39 + t43 + d20  + t45 + 2d0*xh2  
     *         - d21*t14/t31*e2 + d10*xh2) - xo
c                                 evaluate dg:
      t27 = g1*xh2/t31
      t37 = t31**2
      t49 = d14*xh2 - d13 - d12*e3
      t55 = g2*t14/t37/xh2*t49
      t61 = -g2*t39/e1
      t65 = d18*e1/t31
      t67 = t14/t37*t49
      t71 = d19/e2
      t73 = c1*t65
      t74 = c1*t67
      t80 = -g2*t14/t31/xh2
      t88 = c1*t39
      t98 = t80 + t39 + t43 + d20 + t88 + 2d0*xh2 
     *          + d21*t39*e2 + d10*xh2

      dg = (t27 + t55 + t61 + t65 + t67 + t71 + t73 + t74)/t98
     *     - (t80 + t39 + t43 + xh2o + t88)/t98/t98
     *      *(t27 + t55 + t61 + t65 + t67 + t71 + t73 + t74 
     *        - d22*e4/t31 + d21*e2*t67 + d23*t39*e1 + d25)

      xh2 = r0 - g/dg
      if (xh2.lt.0d0) xh2 = r0/2d0
c                                 converged:
      if (dabs((xh2-r0)/xh2).lt.0.1d-6) goto 40

      it = it + 1

      if (it.gt.100) then 

         ier = 2

         goto 40

      end if 

      goto 10 

40    it = 0 
c                                 use xh2 to refine guesssed xh2o
      t10 = xh2**2
      t11 = xh2**3
      t25 = t10*t11
      f2 = 2d0*d7*xh2
      f3 = c2/xh2
      f4 = xh2 - 1d0 + c3*xh2
      f7 = c2*xh2
      f8 = d3*t11
      f9 = d7*xh2
      f11 = c5/t10
      f12 = d4*t10

30    r0 = xh2o
c                                 evaluate f:
      t4 = xh2o**2
      f13 = d2*t4
      f1 = f12*xh2o - t4*f9 - d8*t25
      t14 = f13*xh2o + xh2o*f8
      t32 = t14/f1
      f5 = c6*t11
      f6 = f5/xh2o

      f = -t32 - f3*xh2o*t32 - f5*t32/xh2o - c1*t32 
     *    + t4*f11 + xh2o + f4
c                                 evaluate df:
      t13 = f10*t4 + f8
      t31 = t13/f1
      t37 = d2*t4*xh2o + xh2o*f8
      t38 = f1**2
      t45 = d4*t10 - f2*xh2o
      t47 = t37/t38*t45
      t49 = -f3*f1

      df = t47 - t31 + t37*t49 + xh2o*t13*t49 
     *     + f7*xh2o*t47 - f6*t31
     *     + f6*t47 + f5*t37/f1/t4
     *     - c1*t31 + c1*t47 + c7*xh2o/t10 + 1d0

      xh2o = r0 - f/df

      if (xh2o.lt.0d0) then
         xh2o = r0/2d0
      else if (xh2o.ge.1d0) then
         xh2o = r0 + (1d0 - r0)/2d0
      end if         
c                                 converged:
      if (dabs((xh2o-r0)/xh2o).lt.0.1d-6) goto 99

      it = it + 1

      if (it.gt.100) then 

         ier = 2

         goto 99

      end if 

      goto 30 

99    t4 = xh2o**2

      xco = -(d2*t4*xh2o + d3*xh2o*t11)/
     *       (d4*t10*xh2o - d7*xh2*t4 - d8*t25)
c                                 is new xh2o same as guess?:
      if (dabs((xh2o-r1)/xh2o).lt.0.1d-6) goto 9999

      jt = jt + 1

      if (jt.gt.100) then 

         ier = 2

         goto 9999

      end if 

      goto 100 

9999  end

      subroutine evlxh3 (c1,c2,c3,c5,c6,xo,xc,xh2,xco,xh2o,ier)
c----------------------------------------------------------------------
      implicit none

      integer ier,jt,it

      double precision c1,c2,c3,c5,c6,c7,xo,xh2,xco,xh2o,r1,g1,
     *                 g2,r0,t39,t43,t45,t27,t49,t61,t65,t71,
     *                 t10,t11,f2,f3,f4,f7,f8,t4,
     *                 f1,t32,f5,f6,f,t47,df,g0,g3,g4,g5,g6,g7,
     *                 g8,g9,g10,g11,g12,g13,c11,c15,c16,c17,c18,c19,
     *                 c20,c25,c26,c27,t1,t2,c8,c9,c10,c12,c14,c21,c22,
     *                 c23,t5,t21,c13,t16,t17,t19,t33,c,t12,t42,t101,
     *                 xc,t46,t58,t60,t62,t79,t81,t87,t91,t93,t95,t99,
     *                 t107,t111,t115,dc,t3,t59,t63,t76,t7
c----------------------------------------------------------------------

      jt = 0 
      ier = 0 
      g0 = 3d0*c5
      g1 = 2d0*c5
      g2 = xo*g1
      g3 = 3d0*xo
      g4 = 2d0*xo
      g5 = g4*c3
      g6 = 2d0*c2
      g7 = g4*c2
      g8 = xo*c1
      g9 = 4d0*xo*c6
      g10 = 6d0*xo
      g11 = 3d0*g4
      g12 = 3d0*g5
      g13 = 6d0*c5
      c11 = 3d0*c3
      c15 = c11 + 2d0
      c16 = 2d0*g3
      c17 = 3d0*g2
      c18 = 3d0*g1
      c19 = 2d0*g6
      c20 = 2d0*g7
      c25 = 2d0*c1
      c26 = 2d0*g8
      c27 = 5d0*g9

100   r1 = xh2o
      t1 = xh2o**2
      t2 = t1*xh2o
 
      c7 = g1*t2
      c8 = g2*t2
      c9 = g0*t1
      c10 = 3d0*xh2o
      c12 = c2*xh2o
      c14 = g13*t1
      c21 = c6/xh2o
      c22 = g7*t1
      c23 = g6*t1

      it = 0 
      ier = 0 
c                                 solve c for xh2, guessed xh2o
10    r0 = xh2
c                                 evaluate c:
      t4 = xh2**2
      t5 = t4*t1
      t21 = t4**2
      t10 = t4*xh2
      c13 = t10/xh2o
      t11 = t10*xh2o
      t16 = c7 + t5 - c8 - g3*t5 - g4*t11 - g5*t11
      t17 = t1*xh2
      t19 = t4*xh2o
      t32 = (g6-g7)*t17+t19+(c1-xo-g8)*t19-g9*t21*xh2
      t33 = t16/t32
      t39 = c12*t33/xh2
      t45 = c21*t33*t10
      t47 = c1*t33

      c = (-t33 - t39 - t45 - t47)/
     *    (-3d0*t39 - 2d0*t33 + c9/t4 + c10 - 3d0*t47 + 2d0*xh2 
     *     -5d0*t45 + c11*xh2) - xc
c                                 evaluate dc:
      t12 = 2d0*t17 - g10*t17 - g11*t19 - g12*t19
      t27 = t12/t32
      t42 = c7 + t5 - c8 -g3*t5 - g4*t11 - g5*t11
      t43 = t32**2
      t101 = t42/t32
      t46 = xh2*xh2o
      t58 = c23 + 2d0*t46 + c25*t46  -c22 - g4*t46 - c26*t46 - c27*t21
      t60 = t42/t43*t58
      t62 = t32*xh2
      t65 = c12*t12/t62
      t71 = c12/xh2*t60
      t76 = c12*t101/t4
      t79 = c6*c13/t32
      t81 = t12*t79
      t87 = c6*c13*t60
      t91 = c21*t101*t4
      t93 = c1*t27
      t95 = c1*t60
      t99 = c12*t42/t62
      t107 = c1*t101
      t111 = t42*t79
      t115 = -3d0*(t99 + t107) + 2d0*(xh2 - t101) + c9/t4 + c10  
     *       -5d0*t111 + c11*xh2

      dc = (-t27+t60-t65+t71+t76-t81+t87-3*t91-t93+t95)
     *     /t115 - (-t101 - t99 - t111 - t107)/t115**2        
     *     *(+ 3d0*(t71 - t65  + t76 - t93 + t95) + 2d0*(t60 - t27)
     *       -c14/t10  + 5d0*(t87- t81) -15d0*t91 + c15)

      xh2 = r0 - c/dc

      if (xh2.lt.0d0) xh2 = r0/2d0
c                                 converged:
      if (dabs((xh2-r0)/xh2).lt.0.1d-6) goto 40

      it = it + 1

      if (it.gt.100) then 

         ier = 2

         goto 40

      end if 

      goto 10 

40    it = 0 
c                                 use xh2 to refine guesssed xh2o
      t4 = xh2**2 
      t10 = t4*xh2
      t27 = t4**2
      f1 = c5/t4
      f2 = c3*xh2 + xh2 -1d0
      f3 = g9*xh2
      f4 = xo*t4
      f5 = c2/xh2
      f6 = + t4 + c1*t4 - f4 - g8*t4
      f7 = g1/t4
      f8 = c6*t10

30    r0 = xh2o
c                                 evaluate f:
      t1 = xh2o**2
      t2 = t1*xh2o
      t17 = t1*xh2
      t5 = t4*t1
      t11 = t10*xh2o
      t19 = t4*xh2o

      t7 = g1*t2 + t5 - g2*t2 - g3*t5 - g4*t11 - g5*t11
      t3 = g6*t17 + t19 + c1*t19 - g7*t17 - xo*t19 - g8*t19 - t27*f3
      t33 = t7/t3

      f = -t33 - f5*xh2o*t33 - f8*t33/xh2o - c1*t33
     *    + f1*t1 + xh2o + f2
c                                 evaluate df:
      t16 = c18*t1 + 2d0*t19- c17*t1- c16*t19 - g4*t10 - g5*t10
      t32 = t16/t3
      t49 = xh2*xh2o
      t59 = c19*t49 - c20*t49 - f6 
      t61 = t7/t3**2*t59
      t63 = c2*t3/xh2

      df = -t32 + t61 - t7*t63 - xh2o*t16*t63 + f5*xh2o*t61
     *     - f8*t32/xh2o + f8/xh2o*t61 + f8*t7/t3/t1 - c1*t32 
     *     + c1*t61 + f7*xh2o + 1d0

      xh2o = r0 - f/df

      if (xh2o.lt.0d0) then
         xh2o = r0/2d0
      else if (xh2o.ge.1d0) then
         xh2o = r0 + (1d0 - r0)/2d0
      end if         
c                                 converged:
      if (dabs((xh2o-r0)/xh2o).lt.0.1d-6) goto 99

      it = it + 1

      if (it.gt.100) then 

         ier = 2

         goto 99

      end if 

      goto 30 

99    xco = -((g1-g2)*xh2o**2+((1d0-g3)*xh2o-(g4+g5)*xh2)*xh2**2)*xh2o/
     *       ((((g6-g7)*xh2o+(1d0+c1-xo-g8)*xh2)*xh2o-g9*xh2**4)*xh2)
c                                 is new xh2o same as guess?:
      if (dabs((xh2o-r1)/xh2o).lt.0.1d-6) goto 9999

      jt = jt + 1

      if (it.gt.100) then 

         ier = 2

         goto 9999

      end if 

      goto 100 

9999  end

      subroutine hh2ork (fo2)
c----------------------------------------------------------------------
c program to calculate fh2o, fo2 for H2-H2O mixtures using hsmrk/mrk
c hybrid EoS
c----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer ins(nsp), jns(3)

      double precision fo2,ghh2o,kh2o

      double precision fh2o,fh2
      common/ cst11 /fh2o,fh2

      double precision p,t,xv,u1,u2,tr,pr,r,ps
      common/ cst5 /p,t,xv,u1,u2,tr,pr,r,ps

      double precision vol
      common/ cst26 /vol

      double precision gmh2o,gmco2,gmch4,vm
      common/ cstchx /gmh2o,gmco2,gmch4,vm(3)

      double precision xh2o,xco2,xco,xch4,xh2,xh2s,xo2,xso2,xcos,xn2,
     *                 xnh3,gh2o,gco2,gco,gch4,gh2,gh2s,go2,gso2,gcos,
     *                 gn2,gnh3,v
      common / cstcoh /xh2o,xco2,xco,xch4,xh2,xh2s,xo2,xso2,xcos,xn2,
     *                 xnh3,gh2o,gco2,gco,gch4,gh2,gh2s,go2,gso2,gcos,
     *                 gn2,gnh3,v(nsp)
      save ins, jns

      data ins, jns/1, 5, 9*0, 1, 2*0/
c----------------------------------------------------------------------
      xh2 = xv
      xh2o = 1d0 - xh2
c                                check if xo2 is <1, >0,
c                                reset if necessary.
      if (xh2.gt.0.9999999999d0) then
         xh2 = 0.9999999999d0
      else if (xh2.lt.1d-8) then
         xh2 = 1d-8
      end if 
c                                get pure species fugacities
      call hsmrkp (ins, 2, jns, 1)

      ghh2o = gh2o/gmh2o
c                                get mrk fugacities:
      call mrkmix (ins, 2)
c                                evaluate lnk's
      kh2o = -7.028214449d0 + 30607.34044d0/t - 475034.4632d0/t/t 
     *                      + 50879842.55d0/t/t/t
c                                 
      gh2o = ghh2o * gh2o

      fh2o = dlog(gh2o*p*xh2o)

      fh2 = dlog(gh2*p*xh2)
  
      fo2 = 2d0 * (fh2o - fh2 - kh2o)

      vol = vol + xh2o * vm(1)
 
      end

      subroutine cohfit (fo2)
c----------------------------------------------------------------------
      implicit none

c subroutine which returns ln(f2o,fco2) from functions fit to the
c values obtained from cohhyp for fo2 => xh2o max.

c the functions are of the form:

c ln(f) = a*t + b*p + c/t/t + d*p*t + e*p*p + f*t*t + g*sqrt(p*t)
c       + h*t**3 + i*p**3 + j*p/t/t + k ln t + l ln p 
c       + m/p**2 + n*p*p/t + o*p/t + pp*t/p + q*t*t/p 
c       + rp*t*ln(t) + s*p*ln(t) + tp

      double precision fo2,ah,bh,ch,dh,eh,fh,gh,hh,ih,jh,kh,lh,mh,nh,
     *                 oh,ph,qh,rh,sh,th,ac,bc,cc,dc,ec,fc,gc,hc,ic,jc,
     *                 kc,lc,mc,nc,oc,pc,qc,rc,sc,tc,ao,bo,co,do,eo,fo,
     *                 go,ho,io,jo,ko,lo,mo,no,oo,po,qo,ro,so,to,lp,
     *                 spt,p2,t2,lt

      double precision fh2o,fco2
      common/ cst11 /fh2o,fco2

      double precision p,t,xc,u1,u2,tr,pr,r,ps
      common/ cst5 /p,t,xc,u1,u2,tr,pr,r,ps
 
      save ah,bh,ch,dh,eh,fh,gh,hh,ih,jh,kh,lh,mh,nh,oh,ph,qh,rh,sh,th

      save ac,bc,cc,dc,ec,fc,gc,hc,ic,jc,kc,lc,mc,nc,oc,pc,qc,rc,sc,tc

      save ao,bo,co,do,eo,fo,go,ho,io,jo,ko,lo,mo,no,oo,po,qo,ro,so,to

      data th,ah,bh,ch,dh,eh,fh,gh,hh,ih,jh,kh,lh,mh,nh,oh,ph,qh,rh,sh/
     *-121.5649d0  , -.5498738d-01, -.8052569d-02, -169883.7d0  ,
     *-.5150895d-06, 0.2909217d-08, 0.1484028d-04, 0.1595388d-02,
     *-.2286740d-08, -.4611758d-14, -118.8630d0  ,  24.90956d0  ,
     *-1.283717d0  ,  126339.8d0  , -.1875289d-05,  1.141895d0  ,
     *-1.661033d0  , 0.7550874d-03, 0.9051986d-03, 0.1093571d-02/

      data tc,ac,bc,cc,dc,ec,fc,gc,hc,ic,jc,kc,lc,mc,nc,oc,pc,qc,rc,sc/
     *-68.24622d0  , -.2797826d-01, -.5658539d-02, -221752.4d0  ,
     *-.2227993d-06, -.4785067d-08, -.2949820d-05, -.3942711d-02,
     *0.8136084d-09, 0.6607593d-13, -126.2944d0  ,  12.42835d0  ,
     *-.1328584d0  , -168530.0d0  , -.1849930d-05,  1.058393d0  ,
     * 2.131351d0  , -.9849674d-03, 0.3118428d-02, 0.8233771d-03/
 
      data to,ao,bo,co,do,eo,fo,go,ho,io,jo,ko,lo,mo,no,oo,po,qo,ro,so/
     *-804.2316d0  , -.1652445d0  , -.5376252d-02, -4037433d0    ,
     *-.2091203d-06, -.4638105d-08, 0.3753368d-04, -.3853404d-02,
     *-.5442896d-08, 0.6484263d-13, -121.6754d0  ,  127.5998d0  ,
     *-.1486220d0  , -164866.6d0  , -.1863209d-05, 0.9622612d0  ,
     *  2.097447d0 , -.9838123d-03, 0.3077560d-02, 0.7829503d-03/

      lp = dlog(p)
      lt = dlog(t)
      spt = dsqrt(p*t)
      p2 = p*p
      t2 = t*t
  
      fh2o = th + t*(ah + dh*p + t*(fh + hh*t) + (ph+qh*t)/p +
     *               rh*lp) 
     *          + p*(bh + p*(eh + ih*p) + sh*lt)
     *          + p/t*(jh/t + nh*p + oh)
     *          + kh*lt + lh*lp + ch/t2 + gh*spt + mh/p2

      fco2 = tc + t*(ac + dc*p + t*(fc + hc*t) + (pc+qc*t)/p +
     *               rc*lp) 
     *          + p*(bc + p*(ec + ic*p) + sc*lt)
     *          + p/t*(jc/t + nc*p + oc)
     *          + kc*lt + lc*lp + cc/t2 + gc*spt + mc/p2

      fo2  = to + t*(ao + do*p + t*(fo + ho*t) + (po+qo*t)/p +
     *               ro*lp) 
     *          + p*(bo + p*(eo + io*p) + so*lt)
     *          + p/t*(jo/t + no*p + oo)
     *          + ko*lt + lo*lp + co/t2 + go*spt + mo/p2

      end

      subroutine hocgra (fo2)
c----------------------------------------------------------------------
c  program to calculate GCOH fluid properties as a function of XO 
c  using HSMRK/MRK hybrid see Connolly and Cesare (1992) for details.

c  modified to account for diamond stability and to use CORK for
c  h2o and co2, 4/27/04, JADC.
c----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer ins(nsp),nit,ier

      double precision tol,oh2o,ghh2o,ghco2,ghch4,kh2o,kch4,kco,kco2,
     *                 xt,ek1,ek2,ek3,ek10,ek20,ek30,fo2

      double precision p,t,xo,u1,u2,tr,pr,r,ps
      common / cst5 /p,t,xo,u1,u2,tr,pr,r,ps

      double precision vol
      common/ cst26 /vol

      double precision gmh2o,gmco2,gmch4,vm
      common/ cstchx /gmh2o,gmco2,gmch4,vm(3)

      double precision xh2o,xco2,xco,xch4,xh2,xh2s,xo2,xso2,xcos,xn2,
     *                 xnh3,gh2o,gco2,gco,gch4,gh2,gh2s,go2,gso2,gcos,
     *                 gn2,gnh3,v
      common / cstcoh /xh2o,xco2,xco,xch4,xh2,xh2s,xo2,xso2,xcos,xn2,
     *                 xnh3,gh2o,gco2,gco,gch4,gh2,gh2s,go2,gso2,gcos,
     *                 gn2,gnh3,v(nsp)

      double precision fh2o,fco2
      common/ cst11 /fh2o,fco2

      integer ibuf,hu,hv,hw,hx   
      double precision dlnfo2,elag,gz,gy,gx
      common/ cst100 /dlnfo2,elag,gz,gy,gx,ibuf,hu,hv,hw,hx

      save tol, ins

      data tol, ins/ .0001d0, 1,2,3,4,5,6*0/
 
      nit = 0
      oh2o = 2d0

      call setup (ghh2o,ghco2,ghch4,kh2o,kco2,kco,kch4)

      xt = 1d0 - xo

      ek30 = dexp (kch4) * p
      ek10 = dexp (kco2 - 2d0*kco) * p 
      ek20 = dexp (kh2o - kco) * p
c                                 solve 
10    ek1 = ek10 * gco**2/gco2 
      ek2 = ek20 * gco * gh2/gh2o
      ek3 = ek30 * gh2**2/gch4 
c                                 solve for xh2
      call evalxh (ek1,ek2,ek3,xt,xh2,ier)
      if (ier.eq.1) goto 99
c                                 solve for xco
      call evalxc (ek1,ek2,ek3,xt,xh2,xco)

      xch4 = ek3 * xh2**2 
      xh2o = ek2 * xh2 * xco
      xco2 = ek1 * xco**2
 
      nit = nit + 1

      if (nit.gt.100) then 
         call warn (176,xh2o,nit,'HOCGRA')
         goto 99          
      end if

      if (dabs(xh2o-oh2o).lt.tol*xh2o) goto 90

      oh2o = xh2o

      call mrkmix (ins, 5)

      gh2o = ghh2o * gh2o
      gco2 = ghco2 * gco2 
      gch4 = ghch4 * gch4 

      goto 10 

90    goto (91), hu

      fh2o = dlog(gh2o*p*xh2o)
      fco2 = dlog(gco2*p*xco2)
      fo2 = 2d0*(dlog(gco*p*xco) - kco)

      goto 99

91    fh2o = dlog(gh2*p*xh2)
      fco2 = 2d0*(dlog(gco*p*xco) - kco)

99    vol = vol + xh2o * vm(1) + xco2 * vm(2) + xch4 * vm(3)

      end

      subroutine nogcoh (fo2)
c----------------------------------------------------------------------
c  program to calculate COH fluid properties for a specified speciation 
c  using HSMRK/MRK hybrid see Connolly and Cesare (1992) for details.
c----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer ins(nsp)

      double precision ghch4,ghh2o,ghco2,fo2,kh2o,kco2,kco,kch4

      double precision p,t,xo,u1,u2,tr,pr,r,ps
      common / cst5 /p,t,xo,u1,u2,tr,pr,r,ps
     
      double precision vol
      common/ cst26 /vol

      double precision gmh2o,gmco2,gmch4,vm
      common/ cstchx /gmh2o,gmco2,gmch4,vm(3)

      double precision xh2o,xco2,xco,xch4,xh2,xh2s,xo2,xso2,xcos,xn2,
     *                 xnh3,gh2o,gco2,gco,gch4,gh2,gh2s,go2,gso2,gcos,
     *                 gn2,gnh3,v
      common / cstcoh /xh2o,xco2,xco,xch4,xh2,xh2s,xo2,xso2,xcos,xn2,
     *                 xnh3,gh2o,gco2,gco,gch4,gh2,gh2s,go2,gso2,gcos,
     *                 gn2,gnh3,v(nsp)

      double precision fh2o,fco2
      common/ cst11 /fh2o,fco2

      integer ibuf,hu,hv,hw,hx   
      double precision dlnfo2,elag,gz,gy,gx
      common/ cst100 /dlnfo2,elag,gz,gy,gx,ibuf,hu,hv,hw,hx

      save ins

      data ins/ 1,2,3,4,5,6*0/
 
      call setup (ghh2o,ghco2,ghch4,kh2o,kco2,kco,kch4)

      call mrkmix (ins, 5)

      gh2o = ghh2o * gh2o
      gco2 = ghco2 * gco2 
      gch4 = ghch4 * gch4 

      goto (91), hu

      fh2o = dlog(gh2o*p*xh2o)
      fco2 = dlog(gco2*p*xco2)
      fo2 = 2d0*(dlog(gco*p*xco) - kco)

      goto 99

91    fh2o = dlog(gh2*p*xh2)
      fco2 = 2d0*(dlog(gco*p*xco) - kco)

99    vol = vol + xh2o * vm(1)
     *          + xco2 * vm(2)
     *          + xch4 * vm(3)

      end

      subroutine hocmrk (fo2)
c----------------------------------------------------------------------
c  program to calculate GCOH fluid properties as a function of XO using
c  MRK see Connolly and Cesare (1991) for details.

c  modified to account for diamond stability, 4/27/04, JADC.
c----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer ins(nsp),ier,nit

      double precision fo2,tol,t2,t3,oh2o,xt,agph,dg,kh2o,kco2,ek30,kco,
     *                 ek10,ek20,ek1,ek2,ek3

      double precision p,t,xo,u1,u2,tr,pr,r,ps
      common / cst5 /p,t,xo,u1,u2,tr,pr,r,ps

      double precision xh2o,xco2,xco,xch4,xh2,xh2s,xo2,xso2,xcos,xn2,
     *                 xnh3,gh2o,gco2,gco,gch4,gh2,gh2s,go2,gso2,gcos,
     *                 gn2,gnh3,v
      common / cstcoh /xh2o,xco2,xco,xch4,xh2,xh2s,xo2,xso2,xcos,xn2,
     *                 xnh3,gh2o,gco2,gco,gch4,gh2,gh2s,go2,gso2,gcos,
     *                 gn2,gnh3,v(nsp)

      double precision fh2o,fco2
      common/ cst11 /fh2o,fco2

      integer ibuf,hu,hv,hw,hx   
      double precision dlnfo2,elag,gz,gy,gx
      common/ cst100 /dlnfo2,elag,gz,gy,gx,ibuf,hu,hv,hw,hx

      save tol, ins

      data tol, ins/0.0001d0, 1, 2, 3, 4, 5, 6*0/

      t2 = t*t
      t3 = t2 * t
 
      nit = 0
      oh2o = 2d0
c                                check if xo is <1, >0,
c                                reset if necessary.
      xt = 1d0 - xo

      if (xt.gt.0.9999999999d0) then
         xt = 0.9999999999d0
      else if (xt.lt.1d-8) then
         xt = 1d-8
      end if 
c                                correct activity of graphite
c                                for diamond stability if necessary:
      call dimond (agph)
c                                graphite pressure effect:
      dg = p*( 1.8042d-06 + (0.058345d0 - 8.42d-08*p)/t ) + agph
c                                get pure species fugacities
      call mrkpur (ins, 5)
c                                ln k's fitted from robie:
      kh2o = -7.028214449d0 + 30607.34044d0/t - 475034.4632d0/t2 
     *                      + 50879842.55d0/t3
      kco2 = .04078341613d0 + 47681.676177d0/t - 134662.1904d0/t2 
     *                      + 17015794.31d0/t3 + dg 
      kco =  10.32730663d0  + 14062.7396777d0/t - 371237.1571d0/t2  
     *                      + 53515365.95d0/t3  + dg
c                               kch4 * p
      ek30 = dexp (-13.86241656d0 + 12309.03706d0/t - 879314.7005d0/t2 
     *                          + .7754138439d8/t3 + dg) * p
      ek10 = dexp (kco2 - 2d0*kco) * p 
      ek20 = dexp (kh2o - kco) * p
c                                solve 
10    ek1 = ek10 * gco**2/gco2 
      ek2 = ek20 * gco * gh2/gh2o
      ek3 = ek30 * gh2**2/gch4 
c                                 solve for xh2
      call evalxh (ek1,ek2,ek3,xt,xh2,ier)
      if (ier.eq.1) goto 99
c                                 solve for xco
      call evalxc (ek1,ek2,ek3,xt,xh2,xco)

      xch4 = ek3 * xh2**2 
      xh2o = ek2 * xh2 * xco
      xco2 = ek1 * xco**2
 
      nit = nit + 1

      if (nit.gt.100) then 
         call warn (176,xh2o,nit,'HOCMRK') 
         goto 99          
      end if

      if (dabs(xh2o-oh2o).lt.tol*xh2o) goto 90

      oh2o = xh2o

      call mrkmix (ins, 5)

      goto 10 

90    goto (91), hu

      fh2o = dlog(gh2o*p*xh2o)
      fco2 = dlog(gco2*p*xco2)
      fo2 = 2d0*(dlog(gco*p*xco) - kco)

      goto 99

91    fh2o = dlog(gh2*p*xh2)
      fco2 = 2d0*(dlog(gco*p*xco) - kco)

99    end

      subroutine evalxh (k1,k2,k3,xt,xh,ier)
c----------------------------------------------------------------------
      implicit none

      integer ier,it

      double precision k1,k2,k3,xt,xh,sign,g,dg,r0
c----------------------------------------------------------------------
      sign = 1d0

20    xh = 0.01d0
      it = 0 
      ier = 0 

10    r0 = xh

      call evalg (k1,k2,k3,xt,xh,g,dg,sign)

      xh = r0 - g/dg

      if (dabs((xh-r0)/xh).lt.0.1d-6) then
c                                 converged:
         if (xh.gt.0d0) goto 999
c                                 xh < 0.
            if (sign.lt.0d0) then
               call warn (176,xh,it,'EVALXH') 
               ier = 1
               goto 999
            else
               sign = -1d0
               goto 20
            end if
      end if 

      it = it + 1

      if (it.gt.100) then 

c                             uncommenting these lines would make
c                             evalxh try the second root, however
c                             my experience is that this doesn't 
c                             help.
c         if (sign.gt.0d0) then 
c            write (*,*) ' evalxh, did not converge on root 1'
c            sign = -1d0
c            goto 20 
c         end if 
         
         call warn (176,xh,it,'EVALXH')
         ier = 1
         goto 999 

      end if 

      goto 10 

999   end 

      subroutine evalg (k1,k2,k3,xt,xh,g,dg,sign)
c----------------------------------------------------------------------
      implicit none

      double precision k1,k2,k3,xt,xh,g,dg,sign,u1,k2x,xk2x,t8,t9,t15,
     *                 t20,t21,t24,t32,t34,t36,t40,t41,t43,t53,t54,t66,
     *                 t68,k22
c----------------------------------------------------------------------

      u1 = xt*k1
      k2x = k2*xh
      xk2x = xt*k2x
      k22 = k2**2
      t8 = xh**2
      t9 = k22*t8
      t15 = xt**2
      t20 = k3*t8
      t21 = k1*t20
      t24 = k1*xh

      t32 = dsqrt  (4d0*(t9 - xk2x) 
     *        + t15*(6d0*k2x + 9d0*t9 + 1d0 - 32d0*t21 - 16d0*t24) 
     *        + xt*(32d0*t21 + 16d0*t24 - 12d0*t9))

      t34 = - 2d0*k2x + 3d0*xk2x + xt - sign * t32
      t36 = t34/u1
      t40 = xt*k2
      t41 = t34**2
      t43 = k22*xh
      t53 = k3*xh
      t54 = k1*t53
      t66 = - 2d0*k2 + 3d0*t40 - (4d0*t43 
     *       + xt*(32d0*t54-12d0*t43) - 2d0*t40  
     *       + t15*(9d0*t43 + 3d0*k2 - 32d0*t54 - 8d0*k1)  
     *       + 8d0*u1 )/t32

      t68 = t66/u1

      g = -k2x*t36/4d0 + t41/k1/t15/16d0 + t20 - t36/4d0 + xh - 1d0 

      dg = (-k2/u1*t34 - k2x*t68 + t34/k1/t15*t66/2d0)/4d0
     *      + 2d0*t53 - t68/4d0 + 1d0

      end

      subroutine evalxc (k1,k2,k3,xt,xh,xco)
c----------------------------------------------------------------------
      implicit none

      integer ier

      double precision k1,k2,k3,xt,xh,xco,k2x,xk2x,t8,t9,t15,t21,t24,
     *                 t32,k22
c----------------------------------------------------------------------
      k2x = k2*xh
      xk2x = xt*k2x
      k22 = k2**2
      t8 = xh**2
      t9 = k22*t8
      t15 = xt**2
      t21 = k1*k3*t8
      t24 = k1*xh
      t32 = dsqrt (4d0*(t9  - xk2x)
     *      + t15*(9d0*t9 + 6d0*k2x + 1d0 - 32d0*t21 - 16d0*t24)
     *      + xt*(32d0*t21 - 12d0*t9 + 16d0*t24))

      xco = (2d0*k2x - 3d0*xk2x - xt + t32)/xt/k1/4d0

      if (xco.le.0d0) then 
         xco = -1d0/xt/k1*(- 2d0*k2x + 3d0*xk2x + xt + t32)/4d0
         if (xco.le.0d0) then 
            call warn (176,xh,ier,'EVALXC')
            stop
         end if       
      end if 

      end 

      subroutine fo2buf (fo2)
c----------------------------------------------------------------------
c this routine returns the ln(fO2) of buffers as a function of P-T.
c corrections for graphite activity and delta fo2 are made from 
c cst100.

c ibuf - 1 - fit to aQFM from Holland and Powell in the range
c            298-1200 K, probably not valid above aQ/bQ trans.
c            should be refit to revised hp data.

c ibuf - 2 - fit of fo2 to obtain maximum H2O content.

c ibuf - 3 - fo2 input by user

c ibuf - 4 - fit of rutile-titantite-a-quartz-calcite-graphite 
c            holland & powell 1993. 
c            expansivity and compressibility ignored.

c ibuf - 5 - user buffer function
c----------------------------------------------------------------------
      implicit none

      double precision t2,t3,p2,fo2,lp,lt

      double precision p,t,xo,uc,u2,tr,pr,r,ps
      common / cst5  /p,t,xo,uc,u2,tr,pr,r,ps

      double precision ab,bb,cb,db,eb
      common/ cst112 /ab,bb,cb,db,eb

      integer ibuf,hu,hv,hw,hx   
      double precision dlnfo2,elag,gz,gy,gx
      common/ cst100 /dlnfo2,elag,gz,gy,gx,ibuf,hu,hv,hw,hx

      double precision ao,bo,co,do,eo,fo,go,ho,io,jo,ko,lo,mo,no,oo,po,
     *                 qo,ro,so,to

      save ao,bo,co,do,eo,fo,go,ho,io,jo,ko,lo,mo,no,oo,po,qo,ro,so,to

      data to,ao,bo,co,do,eo,fo,go,ho,io,jo,ko,lo,mo,no,oo,po,qo,ro,so/
     *-804.2316d0  , -.1652445d0  , -.5376252d-02, -4037433d0    ,
     *-.2091203d-06, -.4638105d-08, 0.3753368d-04, -.3853404d-02,
     *-.5442896d-08, 0.6484263d-13, -121.6754d0  ,  127.5998d0  ,
     *-.1486220d0  , -164866.6d0  , -.1863209d-05, 0.9622612d0  ,
     *  2.097447d0 , -.9838123d-03, 0.3077560d-02, 0.7829503d-03/

      t2 = t*t
      t3 = t2 * t
      p2 = p*p

      if (ibuf.eq.1) then 

         fo2 = 13.5029012d0 + (-46704.69695d0 +.2190281453d0*p)/t
     *         -6145687.892d0/t2 + 754294046.5d0/t3

      else if (ibuf.eq.2) then

         lp = dlog(p)
         lt = dlog(t)

         fo2  = to + t*(ao + do*p + t*(fo + ho*t) + (po+qo*t)/p +
     *               ro*lp) 
     *          + p*(bo + p*(eo + io*p) + so*lt)
     *          + p/t*(jo/t + no*p + oo)
     *          + ko*lt + lo*lp + co/t2 + go*dsqrt(p*t) + mo/p2

      else if (ibuf.eq.3) then

         fo2 = dlnfo2
         return

      else if (ibuf.eq.4) then

         fo2 = 16.8582d0 + (0.2131248d0*p - 53946.36d0)/t 
     *                    - 767509.6d0/t2 + 0.9371923d0/t3

      else if (ibuf.eq.5) then
 
         fo2 = ab + (bb + cb*p)/t + db/t2 + eb/t3

      else

         call error (28,r,ibuf,'FO2BUF') 
       
      end if 

      fo2 = fo2 + dlnfo2
  
      end

      subroutine cohgra (fo2)
c----------------------------------------------------------------------
c subroutine to compute H2O and CO2 fugacities in a COH fluid
c consistent with graphite saturatuion and an oxygen fugacity
c buffer specified by ibuf in routine fo2buf.
c----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer ins(nsp),nit

      double precision fo2,tol,t2,t3,kco2,kco,kh2o,kch4,oh2o,qb,qa

      double precision p,t,xc,u1,u2,tr,pr,r,ps
      common/ cst5 /p,t,xc,u1,u2,tr,pr,r,ps

      double precision xh2o,xco2,xco,xch4,xh2,xh2s,xo2,xso2,xcos,xn2,
     *                 xnh3,gh2o,gco2,gco,gch4,gh2,gh2s,go2,gso2,gcos,
     *                 gn2,gnh3,v
      common / cstcoh /xh2o,xco2,xco,xch4,xh2,xh2s,xo2,xso2,xcos,xn2,
     *                 xnh3,gh2o,gco2,gco,gch4,gh2,gh2s,go2,gso2,gcos,
     *                 gn2,gnh3,v(nsp)

      double precision fh2o,fco2
      common/ cst11 /fh2o,fco2

      integer ibuf,hu,hv,hw,hx   
      double precision dlnfo2,elag,gz,gy,gx
      common/ cst100 /dlnfo2,elag,gz,gy,gx,ibuf,hu,hv,hw,hx

      save tol,ins

      data tol,ins/.001, 1,2,3,4,5,6*0/

      t2 = t * t
      t3 = t2 * t
 
      nit = 0
c                                modified to return fo2 = ln(fo2), 11/17/2010
      call fo2buf (fo2)
c                                evaluate k CO2, CO:
      kco2 = dexp(.04078341613d0 + (47681.676177d0+.06372383931d0*p)/t  
     *        + elag - 134662.1904d0/t2 + 17015794.31d0/t3 + fo2)/p
      kco = dexp(10.32730663d0 + (14062.7396777d0+.06372383931d0*p)/t   
     *        + elag - 371237.1571d0/t2 + 53515365.95d0/t3 + fo2/2d0)/p
c                                get pure species fugacities
      call mrkpur (ins, 5)
c                                check for graphite saturation:
      xco2 =  kco2/gco2
      xco = kco/gco

      if (xco2+xco.ge.1d0) then 
 
         write (*,1000) fo2,p,t
         fco2 = dlog(p*gco2)
         xco2 = 1d0
         xco = 0d0
         return

      end if 
c                                evaluate other lnk's:
      kh2o = dexp(-7.028214449d0 + 30607.34044d0/t - 475034.4632d0/t2 
     *                           + 50879842.55d0/t3 + fo2/2d0)

      kch4 = dexp(-13.86241656d0 + (12309.03706d0+.06372383931d0*p)/t 
     *            + elag - 879314.7005d0/t2 + .7754138439d8/t3)*p
c                                solve for x's
      oh2o = 2d0

      do 

         xco2 =  kco2/gco2
         xco = kco/gco
c                                make quadratic 0 = qa * xh2**2 
c                                 + qb * xh2 + qc
         qb = kh2o * gh2/gh2o + 1d0
         qa = kch4 * gh2**2/gch4

         xh2 = (-qb + dsqrt(qb**2 - 4d0*qa*(xco + xco2 -1d0)))/2d0/qa
         xch4 = kch4 * gh2**2 * xh2**2/gch4
         xh2o = kh2o * gh2 * xh2/gh2o

         nit = nit + 1

         if (nit.gt.100) then 
            call warn (176,xh2o,nit,'COHGRA')
            if (xco2+xco.gt.0.9999d0) then
               xco2 = 1d0
               xh2o = 1d-20
               call mrkpur (ins, 5)
               exit 
            else 
               stop
            end if             
         end if 

         if (dabs(xh2o-oh2o).lt.tol*xh2o) exit

         oh2o = xh2o

         call mrkmix (ins, 5)

      end do 

      xc = xco2 

      if (hu.ne.1) then 

         fh2o = dlog(gh2o*p*xh2o)
         fco2 = dlog(gco2*p*xco2)

      else 

         fh2o = dlog(gh2*p*xh2)
         fco2 = fo2

      end if 

1000  format ('**warning ver222** routine cohgra, specified lnfO2 (',
     *        g12.6,')',/,'is inconsistent with graphite saturation',
     *       ' at P(bar)=',g12.6,' T(K)=',g12.6,/,'XCO2=1 assumed.') 
      end

      subroutine cohhyb (fo2)
c----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer ins(nsp),nit

      double precision fo2,tol,ghh2o,ghco2,ghch4,kh2o,kco2,kco,kch4,qa,
     *                 qb,oh2o

      double precision p,t,xc,u1,u2,tr,pr,r,ps
      common/ cst5 /p,t,xc,u1,u2,tr,pr,r,ps

      double precision vol
      common/ cst26 /vol 

      double precision gmh2o,gmco2,gmch4,vm
      common/ cstchx /gmh2o,gmco2,gmch4,vm(3)

      double precision xh2o,xco2,xco,xch4,xh2,xh2s,xo2,xso2,xcos,xn2,
     *                 xnh3,gh2o,gco2,gco,gch4,gh2,gh2s,go2,gso2,gcos,
     *                 gn2,gnh3,v
      common / cstcoh /xh2o,xco2,xco,xch4,xh2,xh2s,xo2,xso2,xcos,xn2,
     *                 xnh3,gh2o,gco2,gco,gch4,gh2,gh2s,go2,gso2,gcos,
     *                 gn2,gnh3,v(nsp)

      double precision fh2o,fco2
      common/ cst11 /fh2o,fco2

      integer ibuf,hu,hv,hw,hx   
      double precision dlnfo2,elag,gz,gy,gx
      common/ cst100 /dlnfo2,elag,gz,gy,gx,ibuf,hu,hv,hw,hx

      save tol,ins

      data tol,ins/.001, 1,2,3,4,5,6*0/

      nit = 0

      call fo2buf (fo2)

      call setup (ghh2o,ghco2,ghch4,kh2o,kco2,kco,kch4)
c                                evaluate k CO2, CO:
      kco2 = dexp(kco2 + fo2)/p
      kco  = dexp(kco  + fo2/2d0)/p
c                                check for graphite saturation:
      xco2 = kco2/gco2
      xco  = kco/gco

      if (xco2+xco.ge.1d0) then 
 
         write (*,1000) fo2,p,t
         fco2 = dlog(p*gco2)
         xco2 = 1d0
         xco = 0d0
         return

      end if  
c                                evaluate other k's:
      kh2o = dexp(kh2o + fo2/2d0)
      kch4 = dexp(kch4)*p
c                                solve for x's
      oh2o = 2d0

      do 
         xco2 =  kco2/gco2
         xco = kco/gco
c                                make quadratic 0 = qa * xh2**2 
c                                 + qb * xh2 + qc
         qb = kh2o * gh2/gh2o + 1d0
         qa = kch4 * gh2**2/gch4

         xh2 = (-qb + dsqrt(qb**2 - 4d0*qa*(xco + xco2 -1d0)))/2d0/qa
         xch4 = kch4 * gh2**2 * xh2**2/gch4
         xh2o = kh2o * gh2 * xh2/gh2o
 
         nit = nit + 1

         if (nit.gt.100) then 
            call warn (176,xh2o,nit,'COHHYB')
            if (xco2+xco.gt.0.9999d0) then
               xco2 = 1d0
               xh2o = 1d-20
               call mrkpur (ins, 5)
               exit 
            else 
               stop
            end if 
            
         end if 

         if (dabs(xh2o-oh2o).lt.tol*xh2o) exit

         oh2o = xh2o

         call mrkmix (ins, 5)

         gh2o = ghh2o * gh2o
         gco2 = ghco2 * gco2 
         gch4 = ghch4 * gch4 

      end do  

      vol = vol + xh2o * vm(1)
     *          + xco2 * vm(2)
     *          + xch4 * vm(3)

      xc = xco2 

      if (hu.ne.1) then 

         fh2o = dlog(gh2o*p*xh2o)
         fco2 = dlog(gco2*p*xco2)

      else 

         fh2o = dlog(gh2*p*xh2)
         fco2 = fo2

      end if 

1000  format ('**warning ver222** routine cohhyb, specified lnfO2 (',
     *        g12.6,')',/,'is inconsistent with graphite saturation',
     *        ' at P(bar)=',g12.6,' T(K)=',g12.6,/,'XCO2=1 assumed.') 

      end 

      subroutine hsmrkp (ins, isp, jns, jsp)
c---------------------------------------------------------------------
c subprogram to get volume and fugacity of pure H2O, CO2, and CH4
c fluids from HSMRK EOS of Kerrick and Jacobs (1981) and Jacobs and
c Kerrick (1981).
c---------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer ins(nsp),jns(3),isp,jsp,ij(3),k,i,j

      double precision fg(3),bw,bc,bm,t15,rtt,t2,b,c,d,e,yz,fugp
 
      double precision gm,vm
      common/ cstchx /gm(3),vm(3)

      double precision x,g,v
      common/ cstcoh /x(nsp),g(nsp),v(nsp)

      double precision pbar,tk,xc,u1,u2,tr,pr,rcal,ps
      common/ cst5 /pbar,tk,xc,u1,u2,tr,pr,rcal,ps

      double precision p,t,t12,r
      common/ cst85 /p,t,t12,r

      double precision f
      common/ cst11 /f(2)

      save bw, bc, bm

      data bw, bc, bm, ij /29d0, 58d0, 60d0, 1, 2, 4/

      t = tk
      p = pbar
      t15 = dsqrt(t**3)
      t12 = dsqrt(t)
      rtt = r*t15
      t2 = t*t

      call mrkpur (ins,isp)

      do k = 1, jsp

         i = jns(k)

         j = ij(i)
         
         if (i.eq.1) then 
           b = bw
           c = 290.78d6-0.30276d6*t+0.00014774d6*t2
           d = -8374d6+19.437d6*t-0.008148d6*t2
           e = 76600d6-133.9d6*t+0.1071d6*t2
         else if (i.eq.2) then 
           b = bc 
           c = 28.31d6+0.10721d6*t-0.00000881d6*t2
           d = 9380d6-8.53d6*t+0.001189d6*t2
           e = -368654d6+715.9d6*t+0.1534d6*t2
         else 
           b = bm 
           c = 13.403d6 + 9.28d4 * t + 2.7d0 * t2
           d = 5.216d9 - 6.8d6 * t + 3.28d3 * t2
           e = -2.3322d11 + 6.738d8 * t + 3.179d5 * t2
         end if 

         vm(i) = -v(j)
         gm(i) = g(j)
         call nurap (b,c,d,e,yz,v(j))
         vm(i) = vm(i) + v(j)
         fg(i) = dlog(p) + fugp (rtt,b,yz,c,d,e,v(j))
         g(j) = dexp(fg(i))/p
         if (i.lt.3) f(i) = fg(i)

      end do 
 
      end

      subroutine hscrkp (ins, isp, jns)
c---------------------------------------------------------------------
c subprogram to get fugacity of pure H2O, CO2 from CORK and of pure CH4
c fluids from HSMRK EOS of Kerrick and Jacobs (1981) and Jacobs and
c Kerrick (1981).

c this routine was made to replace hsmrkp, 4/27/04 JADC
c---------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer ins(nsp),jns(3),isp,i

      double precision fg(3),bm,t15,rtt,t2,c,d,e,yz,fugp
 
      double precision gm,vm
      common/ cstchx /gm(3),vm(3)

      double precision x,g,v
      common/ cstcoh /x(nsp),g(nsp),v(nsp)

      double precision pbar,tk,xc,u1,u2,tr,pr,rcal,ps
      common/ cst5 /pbar,tk,xc,u1,u2,tr,pr,rcal,ps

      double precision p,t,t12,r
      common/ cst85 /p,t,t12,r

      double precision f
      common/ cst11 /f(2)

      save bm

      data bm /6d1/

      t = tk
      p = pbar
      t15 = dsqrt(t**3)
      t12 = dsqrt(t)
      rtt = r*t15
      t2 = t*t
c                                 first get mrk props
      call mrkpur (ins,isp)
c                                 water:
      vm(1) = -v(1)
      gm(1) = g(1)
      call crkh2o (p,t,v(1),fg(1)) 
      g(1) = dexp(fg(1))/p
      vm(1) = vm(1) + v(1)
      f(1) = fg(1)
c                                 co2:
      vm(2) = -v(2)
      gm(2) = g(2)
      call crkco2 (p,t,v(2),fg(2)) 
      g(2) = dexp(fg(2))/p
      vm(2) = vm(2) + v(2)
      f(2) = fg(2)
c                                 ch4:
      i = jns(3) 
         
      c = 13.403d6 + 9.28d4 * t + 2.7d0 * t2
      d = 5.216d9 - 6.8d6 * t + 3.28d3 * t2
      e = -2.3322d11 + 6.738d8 * t + 3.179d5 * t2

      vm(i) = -v(4)
      gm(i) = g(4)

      call nurap (bm,c,d,e,yz,v(4))

      vm(i) = vm(i) + v(4)
      fg(i) = dlog(p) + fugp (rtt,bm,yz,c,d,e,v(4))
      g(4) = dexp(fg(i))/p

      end

      subroutine nurap (b,c,d,e,yz,vi)
c----------------------------------------------------------------------
c newton-raphson iteration to solve for hsmrk volume, my
c idea here was to evaluate all the constants outside of 
c the iteration loop, which might make sense if a lot of
c iterations were necessary, as it is i'm unsure. someone
c should do a comparison with my old nurap routine (xnurap).
c                                 jadc, july 96.
c----------------------------------------------------------------------
      implicit none

      integer k

      double precision b,c,d,e,yz,vi,s1,s2,s3,p0,b2,q0,q1,q2,q3,q4,q5,
     *                 q6,q7,q8,q9,p1,p2,p3,p4,p5,p6,p7,p8,cor
 
      double precision p,t,t12,r
      common/ cst85 /p,t,t12,r
c----------------------------------------------------------------------
      s1 = r*t*t12
      s2 = b*s1
      s3 = t12*p*b
      p0 = -256d0*s1
      b2 = b*b
      q0 = 256d0*t12*p
      q1 = 256d0*(s3 - s1)
      q2 = (-160d0*s3 - 512d0*s1)*b + 256d0*c
      q3 = (-80d0*s3 + p0)*b2 + 256d0*d
      q4 = ((65d0*s3 + 8d0*s1)*b - 160d0*c)*b2 + 256d0*e
      q5 = -b2*(((14d0*s3 - 15d0*s1)*b - 80d0*c)*b + 160d0*d)
      q6 = b2*((((s3 + 6d0*s1)*b - 15d0*c)*b + 80d0*d)*b - 160d0*e)
      q7 = b**3*(((-s1*b + c)*b - 15d0*d)*b + 80d0*e)
      q8 = b**4*(-15d0*e + d*b)
      q9 = e*b**5
      p1 = 512d0*c-768d0*s2
      p2 = (-832d0*s2-256d0*c)*b+768d0*d
      p3 = ((-368d0*s2 - 64d0*c)*b - 256d0*d)*b + 1024d0*e 
      p4 = -b*(((33d0*s2 - 64d0*c)*b + 224d0*d)*b + 256d0*e)
      p5 = 2d0*b2*(b*((s2-c)*7d0*b + 72d0*d) - 192d0*e)
      p6 = -b**3*(b*((s2-c)*b + 29d0*d) - 224d0*e)
      p7 = 2d0*b**4*(d*b-22d0*e)
      p8 = 3d0*q9

      do k = 1, 50

         cor = ((((((((((q0*vi+q1)*vi+q2)*vi+q3)*vi+q4)*vi+q5)*vi
     *         +q6)*vi+q7)*vi+q8)*vi+q9)*vi)/((((((((p0*vi+p1)*vi
     *         +p2)*vi+p3)*vi+p4)*vi+p5)*vi+p6)*vi+p7)*vi+p8)
         vi = vi + cor
         if (dabs(cor).lt.1d-2) goto 99

      end do 
 
99    yz = vi * p/r/t
 
      end

      subroutine mrkmix (ins, isp)
c-----------------------------------------------------------------------
c subroutine to calculate the log fugacities and volume of mixed
c species fluids using the RK/MRK EoS. 

c input:

c        ins(i) -  pointers indicating the species are to be calculated.
c        isp     - the number of species to be calculated.
c        p,t     - input from cst5, p(bars), t(K)

c output (to common cstcoh):

c        g(i)    - fugacity coefficient of ith species
c        v(i)    - volume of the ith species

c species indices:

c         1 = H2O
c         2 = CO2
c         3 = CO
c         4 = CH4 
c         5 = H2
c         6 = H2S
c         7 = O2
c         8 = SO2
c         9 = COS
c        xx = C2H6 a = 90d6, b = 20.
c        10 = N2
c        11 = NH3
c-----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer ins(nsp),i,j,k,l,iroots,isp
 
      double precision b(nsp),a(nsp),f(nsp),aj2(nsp),ev(3),r,c1,c2,t2,
     *                 c3,vmin,vmax,d1,d2,d3,d4,d5,d6,rt,t3,t4,dsqrtt,
     *                 ch,bx,aij
 
      double precision p,t,xco2,u1,u2,tr,pr,rcal,ps
      common/ cst5 /p,t,xco2,u1,u2,tr,pr,rcal,ps

      double precision fg
      common/ cst11 /fg(2) 

      double precision x,g,v
      common/ cstcoh /x(nsp),g(nsp),v(nsp)

      double precision vol
      common/ cst26 /vol
 
      save a, b, r
c                                 r = cm3*bar/k
      data r / 83.1441 /,
     *     a /0d0, 0d0, 16.98d6, 32.154811d6, 2.821d5, 89d6,
     *        17.4d6,133.1d6, 130d6, 136d5 , 631d5 /,
     *     b /14.6, 29.7, 27.38, 29.681, 15.7699, 29.94,
     *        22.1, 37.4, 43d0, 23.42, 18.84 /
 
      t2 = t*t
      t3 = t2*t
      t4 = t3*t
      dsqrtt = dsqrt(t)
      rt = r*t

      a(1) =  .1452535403d8 +306893.3587d0*t 
     *       -307.9995871d0*t2 +.09226256008d0*t3-.2930106337d-5*t4
c                             compute dispersion term for co2
      a(2) =  92935540d0 - 82130.73d0*t + 21.29d0*t2
 
      ch = dexp(-11.218d0 + 6032d0/t - 2782000d0/t2 + 4.708d8/t3) * 
     *          6912.824964d0 * t2 * dsqrtt + 79267647d0
c                             composition dependent mrk-terms
      bx = 0d0
      aij = 0d0

      do k = 1, isp
         i = ins(k)
         aj2(i) = 0d0
         bx = bx + b(i)*x(i)
      end do 
 
      do k = 1, isp
         i = ins(k)
         do l = 1, isp
            j = ins(l)
 
            if (i.eq.1.and.j.eq.2.or.i.eq.2.and.j.eq.1) then
               aij = aij + x(i)*x(j)*ch/2d0
               aj2(i) = aj2(i) + x(j)*ch
            else
               aij = aij + x(i)*x(j)*dsqrt(a(i)*a(j))
               aj2(i) = aj2(i) + 2d0*x(j)*dsqrt(a(i)*a(j))
            end if
         end do 
      end do 
c                                 solve for molar volume of the mix
      c1 = -rt/p
      c3 = -aij*bx/p/dsqrtt
      c2 = c1*bx + aij/dsqrtt/p - bx*bx

      call roots3 (c1,c2,c3,ev,vmin,vmax,iroots)

      if (iroots.eq.3) then
         vol = vmax
      else
         vol = ev(1)
      end if
c                                 segment to compute the
c                                 fugacities.
      d2 = dlog((vol+bx)/vol)
      d1 = rt*dsqrtt*bx
      d3 = d2 -bx/(bx+vol)
      d4 = vol -bx
      d5 = aij*d3/d1/bx
      d6 = dlog(rt/d4)
 
      do 70 i = 1, isp

         l = ins(i)
 
         if (x(l).gt.0d0) goto 80
         g(l) = 1d0
         goto 75
80       f(l) = dlog(x(l))+b(l)/d4-aj2(l)/d1*d2+b(l)*d5+d6
         g(l) = dexp(f(l))/p/x(l)
75       if (l.lt.3) fg(l) = f(l)
70    continue
  
      end

      subroutine crkh2o (pbar,t,vol,fh2o)
c-----------------------------------------------------------------------
c compute ln(f[h2o], bar) and volume h2o (kj/bar) from CORK EoS Holland 
c & Powell CMP 109:265-273. Input pbar - pressure (bars); tk - temp (K).
c                                 J.A.D. Connolly, 1992.
c-----------------------------------------------------------------------
      implicit none

      double precision x(3),b,r,p0,turd,rt,rtp,t12,psat,t,pbar,vol,
     *                 fh2o,a1,a2,a3,xmin,xmax,cc,gam,dp,c,d,e,vmin,
     *                 vmax,gam2,a,p

      integer iroots,i

      save b,r,p0,turd

      data b,r,p0,turd /1.465d0,8.314d-3,2d0,0.666666666666667d0/
c----------------------------------------------------------------------

      p = pbar/1d3
      rt = r*t
      rtp = rt/p
      t12 = dsqrt(t)

      if (t.lt.695d0) then
         psat = -13.627d-3 + t**2*(0.729395d-6 - 0.234622d-8*t 
     *          + 0.483607d-14*t**3)

         if (p.lt.psat.and.t.lt.673d0) then
c                          this is a(gas)
             a = 16138.87d0 
     *           - t*(69.66291d0 - t*(0.1161905d0 - 0.68133d-4*t))
         else
            if (t.lt.673d0) then 
               a = -1449.009d0
     *             + t*(12.70068d0 - t*(0.02208648d0 - 0.13183d-4*t))
            else
               a = 1036.975d0 
     *             + t*(0.5306079d0 - t*(0.7394203d-3 - 0.17791d-6*t))
            end if
         end if
      else 
          psat = 0d0 
          a = 1036.975d0 
     *        + t*(0.5306079d0 - t*(0.7394203d-3 - 0.17791d-6*t))
      end if

      a1 = -rtp
      a2 = a/t12/p - b*(rtp+b)
      a3 = -a*b/t12/p

      call roots3 (a1,a2,a3,x,xmin,xmax,iroots) 

      if (iroots.eq.1) then
         vol = x(1)
      else 
         if (p.lt.psat) then
            vol = xmax
         else if (t.lt.7d2.and.xmin.gt.0d0) then
c                                 this seems hokey, buy there must be
c                                 a reason for it.
            vol = xmin
         else 
c                                 cork has 3 roots sometimes at
c                                 high P, this is a fitting artifact
c                                 and in my experience the only real
c                                 root is positive.
            do i = 1, 3
               if (x(i).gt.0d0) then
                  vol = x(i)
                  goto 2
               end if
            end do 
         end if
      end if 

2     cc = a/b/rt/t12

      gam = vol/rtp - 1d0 - dlog((vol-b)/rtp) - cc*dlog(1d0+b/vol)

      if (p.gt.p0) then
c                            new tjbh cork, 97:
          dp = p - p0
          c = 1.9853d-3*dp
          d = -8.909d-2*dsqrt(dp)
          e = 8.0331d-2*dp**0.25d0

          vol = vol + c + d + e

          gam = gam + dp*(c/2d0 + d*turd + 0.8d0*e)/rt

      end if 
c                              add check to keep T > 273
      if (t.lt.695d0.and.p.gt.psat.and.t.gt.273d0) then
c                              tinkham version, Sept. 12, 2002
         p = psat
         rtp = rt/p
c
         a1 = -rtp
         a2 = a/t12/p - b*(rtp+b)
         a3 = -a*b/t12/p

         call roots3 (a1,a2,a3,x,vmin,vmax,iroots)
c                             gamma liq 
         gam2 = vmin/rtp-1d0-dlog((vmin-b)/rtp)-cc*dlog(1d0+b/vmin)
c
         if (t.lt.673d0) then 
c                             gas phase has a different a, recalculate
c                             vmax 
             a = 16138.87d0  - t*(69.66291d0  
     *                       - t*(0.1161905d0 - 0.68133d-4*t))
c                             prior to Jun 11, 2004, cc was not
c                             updated for new a value, pj gorman.
             cc = a/b/rt/t12

             a1 = -rtp
             a2 = a/t12/p - b*(rtp+b)
             a3 = -a*b/t12/p        
             call roots3 (a1,a2,a3,x,vmin,vmax,iroots)  
c                             could check that are really three roots
         end if 

         gam = vmax/rtp-1d0-dlog((vmax-b)/rtp)-cc*dlog(1d0+b/vmax) 
     *         - gam2 + gam

      end if 

      fh2o = gam + dlog(pbar)

      end

      subroutine crkco2 (pbar,t,vol,fco2)
c-----------------------------------------------------------------------
c compute ln(f[co2], bar) and volume co2 (kj/bar) from CORK EoS Holland 
c & Powell CMP 109:265-273. Input pbar - pressure (bars); tk - temp (K).
c                                 J.A.D. Connolly, 1992.
c-----------------------------------------------------------------------
      implicit none

      integer i,iroots

      double precision x(3),pbar,t,vol,fco2,b,r,p0,p,dp,rt,rtp,t12,a,
     *                 cc,a1,a2,a3,xmin,xmax

      save b,r,p0

      data b,r,p0/3.057d0,8.314d-3,5d0/
c----------------------------------------------------------------------
      p = pbar/1d3
      rt = r*t
      rtp = rt/p
      t12 = dsqrt(t)

c      a = 741.2 - t*(0.10891 + 3.4203d-4*t)
c                                 a from roger:
      a = 659.8 + 0.21078 * t - 6.3976d-4 * t * t
c
      a1 = -rtp
      a2 = a/t12/p - b*(rtp+b)
      a3 = -a*b/t12/p 
c                                 get volume:
      call roots3 (a1,a2,a3,x,xmin,xmax,iroots) 

      if (iroots.eq.1) then
         vol = x(1)
      else         
c                                 cork has 3 roots sometimes at
c                                 high P or T, this is a fitting 
c                                 artifact and in my experience 
c                                 the only real root is positive.
         do i = 1, 3
            if (x(i).gt.0d0) then
               vol = x(i)
               goto 2
            end if
         end do

         call error (999,xmax,iroots,'CRKCO2')

      end if 

2     cc = a/b/rt/t12

      fco2 = dlog(pbar) + vol/rtp - 1d0 
     *     - dlog((vol-b)/rtp) - cc*dlog(1d0+b/vol)

      if (p.gt.p0) then
c                                 add virial component:
c                                 coefficients from tjbh '95
          dp = p - p0
c                       
c         d = 5.40776d-3 - 1.59046d-6*t
c         c = -1.78198d-1 + 2.45317d-5*t

c         fco2 = fco2 + (2d0*c*dp**(1.5d0)/3d0
c     *               + d/2d0*dp*dp)/rt 

          fco2 = fco2 
     *          + dp*((0.1967099672d-2 - 14.28899046d0/t)*dsqrt(dp)
     *          + (0.3252201107d0/t - 0.9564950686d-4)*dp)

      end if 

      end


      subroutine xrkco2 (pbar,t,fco2)
c-----------------------------------------------------------------------
c compute ln(f[co2], bar) from Eq 8 of Holland 
c & Powell CMP 109:265-273. Input pbar - pressure (bars); tk - temp (K).
c                                 J.A.D. Connolly, 1992.
c this approximation assumes p-t conditions are always in the 1-phase
c field for the RK, i.e., T > 373 K
c
c apparently thermocalc does not use this simplification.
c----------------------------------------------------------------------
      implicit none 

      double precision b,r,p0,pbar,t,fco2,rt,bp,p,ab,dp,c,d

      save b,r,p0

      data b,r,p0 /3.7852d0,8.314d-3,5d0/
c----------------------------------------------------------------------
      p = pbar/1d3
      rt = r*t
      bp = b*p

c     a = (5.45963d-5*tc - 8.6392d-6*t)*tc**(1.5d0)/pc
c     a = 1194.001504d0 - 0.6210920651d0*t
c     ab = a/b

      ab = 315.4394758d0 - 0.1640843456d0*t

      fco2 = dlog(pbar) + (bp + ab/dsqrt(t)*(dlog(rt+bp)
     *       - dlog(rt+2d0*bp)))/rt 

c                       cork classic?
c      c = (-3.30558d-5*tc + 2.30524d-6*t)/pc**(1.5d0)
c      d = (6.93054d-7*tc - 8.38293d-8*t)/pc/pc
c      with tc = 304.2 and pc = 0.0738 gives:

c                       tjbh cork '97

      if (p.gt.p0) then
c                       add virial component:
          dp = p - p0

c         c = 5.40776d-3 - 1.59046d-6*t
c         d = -1.78198d-1 + 2.45317d-5*t
c         then the virial contribution to ln(f) is 
c         dp*(
c         or:
c         dp*[{.3252201107/t-.9564950686d-4}*dp
c             + {.1967099672d-2 - 14.28899046/t}*dsqrt(dp)]
c 
c                        cork classic:
          c = -0.5015593595d0 + 0.1149824621d-3*t
          d = .3870914337d-1 - 0.1539157688d-4*t
c                        new parms:

          d = 5.40776d-3 - 1.59046d-6*t
          c = -1.78198d-1 + 2.45317d-5*t


          fco2 = fco2 + dp*(d*dp/2d0 + c*2d0/3d0*dsqrt(dp))/rt

      end if 

      end

      subroutine roots3 (a1,a2,a3,x,vmin,vmax,iroots)
c----------------------------------------------------------------------
c returns real roots (in x) of: x**3 + a1*x**2 + a2*x + a3
c----------------------------------------------------------------------
      implicit none 

      integer iroots,i

      double precision x(3),a1,a2,a3,a4,a5,a6,rr,qq,vmin,vmax,dif,phi,
     *                 a7,dphi,v
c----------------------------------------------------------------------
      qq = (a1**2 - 3d0 * a2) / 9d0
      rr = (a1 * (2d0 * a1**2 - 9d0*a2) + 27d0 * a3) / 54d0
      a5  = a1 / 3d0

      dif = qq**3 - rr**2

      if (dif.ge.0d0) then

         phi = dacos( rr / qq**(1.5d0) )
         a4  = -2d0 * dsqrt(qq)
         a6  = phi / 3d0

         dphi = 0d0
         vmin = 1d9
         vmax = -1d9

         do i = 1, 3
            v = a4 * dcos(a6 + dphi) - a5
            if ( v.gt.vmax ) vmax = v
            if ( v.lt.vmin ) vmin = v
            x(i) = v
            dphi = dphi + 2.094395102497915d0
         end do 
         iroots = 3

      else

         a7 = ( dsqrt(-dif) + dabs(rr) )**(1d0/3d0)
         x(1) = -rr / dabs(rr) * ( a7 + qq/a7 ) - a5
         iroots = 1

      end if 

      end

      subroutine lomrk (ins, isp)
c-----------------------------------------------------------------------
c a semi-fudged (see comments below) MRK to calculate the fugacities
c of mixed species fluids in the vicinity of the water critical point. 

c input:

c        ins(i) -  pointers indicating the species are to be calculated.
c        isp     - the number of species to be calculated.
c        p,t     - input from cst5, p(bars), t(K)

c output (to common cstcoh):

c        g(i)    - fugacity coefficient of ith species
c        v(i)    - volume of the ith species

c species indices:

c         1 = H2O
c         2 = CO2
c         3 = CO
c         4 = CH4 
c         5 = H2
c         6 = H2S
c         7 = O2
c         8 = SO2
c         9 = COS
c        10 = N2
c        11 = NH3
c-----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer ins(nsp),i,j,k,l,isp,iroots
 
      double precision b(nsp),a(nsp),f(nsp),aj2(nsp),ev(3),r,t2,rt,d2,
     *                 dsqrtt,ch,bx,aij,c1,c2,c3,aij12,vmin,vmax,vol,
     *                 d1,d3,d4,d5,d6

      double precision p,t,xco2,u1,u2,tr,pr,rcal,ps
      common/ cst5 /p,t,xco2,u1,u2,tr,pr,rcal,ps

      double precision fg
      common/ cst11 /fg(2) 
 
      double precision x,g,v
      common/ cstcoh /x(nsp),g(nsp),v(nsp)

      save a, b, r
 
      data r / 83.1441d0 /,
     *     a /0d0, 0d0, 16.98d6, 32.154811d6, 2.821d5, 89d6,
     *        17.4d6,133.1d6, 130d6, 136d5 , 631d5 /,
     *     b /14.6d0, 29.7d0, 27.38d0, 29.681, 15.7699d0, 29.94d0,
     *        22.1d0, 37.4d0, 43d0, 23.42d0, 18.84d0 /
c----------------------------------------------------------------------
      t2 = t*t
      dsqrtt = dsqrt(t)
      rt = r*t
c                             this is a cheap trick the a-fit 
c                             was derived using b=15, then b
c                             was adjusted to lower the H2-H2O
c                             critical T, however the fugacities
c                             seem reasonable so who knows?
      a(1) =  .3930568949d9 - .1273025840d7 * t + 2049.978752 * t2
     *       -1.122350458 * t2 * t
c                             compute dispersion term for co2
      a(2) =  0.9293554d8 - 0.8213073d5*t + 0.2129d2*t2
 
      ch = dexp(-11.218d0 + 6032d0/t - 2782d3/t2 + 4.708d8/t2/t) * 
     *          6912.824964d0 * t2 * dsqrtt + 79267647d0
c                             composition dependent mrk-terms
      bx = 0d0
      aij = 0d0
 
      do k = 1, isp
         i = ins(k)
         aj2(i) = 0d0
         bx = bx + b(i)*x(i)
      end do 
 
      do k = 1, isp
         i = ins(k)
         do l = 1, isp
            j = ins(l)
 
            if (i.eq.1.and.j.eq.2.or.i.eq.2.and.j.eq.1) then
               aij = aij + x(i)*x(j)*ch/2d0
               aj2(i) = aj2(i) + x(j)*ch
            else
               aij12 = x(j)*dsqrt(a(i)*a(j))
               aij = aij + x(i)*aij12
               aj2(i) = aj2(i) + 2d0*aij12
            end if
         end do 
      end do 
c                                 solve for molar volume of mixture
      c1 = -rt/p
      c3 = -aij*bx/p/dsqrtt
      c2 = c1*bx + aij/dsqrtt/p - bx*bx

      call roots3 (c1,c2,c3,ev,vmin,vmax,iroots)

      if (iroots.eq.3) then
         vol = vmax
      else
         vol = ev(1)
      end if
c                                 segment to compute the
c                                 fugacities.
      d2 = dlog((vol+bx)/vol)
      d1 = rt*dsqrtt*bx
      d3 = d2 -bx/(bx+vol)
      d4 = vol -bx
      d5 = aij*d3/d1/bx
      d6 = dlog(rt/d4)
 
      do 70 i = 1, isp

         l = ins(i)
 
         if (x(l).gt.0d0) goto 80
         f(l) = 0d0
         g(l) = 1d0
         goto 75
80       f(l) = dlog(x(l))+b(l)/d4-aj2(l)/d1*d2+b(l)*d5+d6
         g(l) = dexp(f(l))/p/x(l)
75       if (l.lt.3) fg(l) = f(l)
70    continue
  
      end

      subroutine mrkpur (ins, isp)
c-----------------------------------------------------------------------
c subroutine to calculate the log fugacities and volume of single
c species fluids using the RK/MRK EoS. 

c input:

c        ins(i) -  pointers indicating the species are to be calculated.
c        isp     - the number of species to be calculated.
c        p,t     - input from cst5, p(bars), t(K)

c output (to common cstcoh):

c        g(i)    - fugacity coefficient of ith species
c        v(i)    - volume of the ith species

c species indices:

c         1 = H2O
c         2 = CO2
c         3 = CO
c         4 = CH4 
c         5 = H2
c         6 = H2S
c         7 = O2
c         8 = SO2
c         9 = COS
c        10 = N2
c        11 = NH3
c-----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'
 
      double precision b(nsp),a(nsp),f(nsp),ev(3),r,t2,t3,t4,dsqrtt,rt,
     *                 d1,d2,d3,d4,bx,vmin,vmax,aij,c1,c2,c3

      integer ins(nsp),isp,k,iroots,i
 
      double precision p,t,xco2,u1,u2,tr,pr,rc,ps
      common/ cst5  /p,t,xco2,u1,u2,tr,pr,rc,ps

      double precision fg
      common/ cst11 /fg(2) 

      double precision x,g,v
      common/ cstcoh /x(nsp),g(nsp),v(nsp)

      double precision vol
      common/ cst26 /vol
 
      save a, b, r
 
      data r / 83.1441d0 /,
     *     a /0d0, 0d0, 16.98d6, 32.154811d6, 2.821d5, 89d6,
     *        17.4d6,133.1d6, 130d6, 136d5 , 631d5 /,
     *     b /14.6d0, 29.7d0, 27.38d0, 29.681d0, 15.7699d0, 29.94d0,
     *        22.1d0, 37.4d0, 43d0, 23.42d0, 18.84d0 /
c----------------------------------------------------------------------
      t2 = t*t
      t3 = t2*t
      t4 = t3*t
      dsqrtt = dsqrt(t)
      rt = r*t

      do k = 1, isp
         i = ins(k)
         if (i.eq.1) then 
            a(1) = .1452535403d8 +306893.3587d0*t -307.9995871d0*t2
     *              +.09226256008d0*t3-.2930106337d-5*t4
         else if (i.eq.2) then 
c                             compute dispersion term for co2
            a(2) =  92935540d0 - 82130.73d0*t + 21.29d0*t2
 
         end if

         aij = a(i)
         bx = b(i)

         c1 = -rt/p
         c3 = -aij*bx/p/dsqrtt
         c2 = c1*bx + aij/dsqrtt/p - bx*bx

         call roots3 (c1,c2,c3,ev,vmin,vmax,iroots)

         if (iroots.eq.3) then
            vol = vmax
         else
            vol = ev(1)
         end if
c                                 compute fugacities.
         d2 = dlog((vol + bx)/vol)
         d1 = rt*dsqrtt*bx
         d3 = d2 - bx/(bx + vol)
         d4 = vol - bx

         v(i) = vol
         f(i) = bx/d4 - 2d0*aij/d1*d2 + bx*aij*d3/d1/bx + dlog(rt/d4)
         if (i.lt.3) fg(i) = f(i)
         g(i) = dexp(f(i))/p 
      end do 

      end

      subroutine setfs2 (fs2,kh2s,kso2,kcos)
c-----------------------------------------------------------------------
c fs2, kh2s, kso2, kcos calculation.
c-----------------------------------------------------------------------
      implicit none

      double precision fs2,kh2s,kso2,kcos,xf

      integer ibuf,hu,hv,hw,hx
      double precision rat,elag,gz,gy,gx
      common/ cst100 /rat,elag,gz,gy,gx,ibuf,hu,hv,hw,hx

      double precision p,t,xo,u1,u2,tr,pr,r,ps
      common / cst5 /p,t,xo,u1,u2,tr,pr,r,ps
c                                get sulfur fugacity according to
c                                the value of ibuf:
      if (ibuf.eq.1) then 
c                                get po-py 1/2 ln sulfur fugacity:
c                                from simon poulson:
         fs2 = .005388049d0*t + 10.24535d0 - 15035.91d0/t 
     *                        + 0.03453878d0/t*p

      else if (ibuf.eq.2) then
c                                get suflur fugacity from fe/s ratio
c                                of po, expression derived from 
c                                toulmin & barton 1964, with p
c                                correction from Craig & Scott 1982.
c                                (this only takes into account V(S2),
c                                hope it's right.
         xf = rat/( rat + 1d0)
         fs2 = 197.6309d0*xf + 45.2458d0*dsqrt(1d0- 1.9962d0*xf) 
     *         - 94.33691d0
     *         + (80624.79d0 + 0.2273782d0*p - 197630.9d0*xf)/t
      
      else 

         fs2 = rat/2d0

      end if
c                                k's from ohmoto and kerrick
      kh2s = 10115.3d0/t - 0.791d0 * dlog (t) + 0.30164d0
      kcos = 10893.52964d0/t - 9.988613730d0
      kso2 = 43585.63147d0/t - 8.710679055d0

      end 

      subroutine hosmrk (fo2, fs2)
c-----------------------------------------------------------------------
c program to calculate H-O-S speciation as a function of XO using
c an MRK/HSMRK hybrid. Specifically for high (po+py) fs2.
c Species are H2 H2O H2S SO2.
c-----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer ins(nsp),jns(3),i,j,nit

      double precision fo2,fs2,f,df,kh2s,kso2,kcos,c1,c2,c3,xom,xop,
     *                 xos,kh2o,a,b,c0,d,ghh2o,turd,c4,xi,xl,c

      double precision gmh2o,vm
      common/ cstchx /gmh2o,vm(5)

      double precision vol
      common/ cst26 /vol

      double precision xh2o,xco2,xco,xch4,xh2,xh2s,xo2,xso2,xcos,xn2,
     *                 xnh3,gh2o,gco2,gco,gch4,gh2,gh2s,go2,gso2,gcos,
     *                 gn2,gnh3,v
      common / cstcoh /xh2o,xco2,xco,xch4,xh2,xh2s,xo2,xso2,xcos,xn2,
     *                 xnh3,gh2o,gco2,gco,gch4,gh2,gh2s,go2,gso2,gcos,
     *                 gn2,gnh3,v(nsp)

      double precision p,t,xo,u1,u2,tr,pr,r,ps
      common / cst5 /p,t,xo,u1,u2,tr,pr,r,ps

      double precision fh2o,fco2
      common/ cst11 /fh2o,fco2

      save ins,jns

      data ins, jns/ 1,5,6,8,7*0,1,2*0/   
c                                check if xo is <1, >0,
c                                reset if necessary
      if (xo.gt.0.9999999999d0) then
         xo = 0.9999999999d0
      else if (xo.lt.1d-8) then
         xo = 1d-8
      end if 
c                                this fs2 = 1/2 ln (fs2),
c                                k's are ln(k)
      call setfs2 (fs2,kh2s,kso2,kcos)

      kh2o = -7.028214449d0 + 30607.34044d0/t - 475034.4632d0/t/t
     *                      + 50879842.55d0/t/t/t
      c1 = dexp (kh2s + fs2)
      c3 = dexp (kso2 - 2d0*kh2o + fs2)/p
    
      xom = xo - 1d0
      xop = xo + 1d0
      xos = xo * xo

      a = 8d0*xo*xom**2
      b = 4d0*xom*(3d0*xos + 1d0) 
      c0 = 2d0*xo*(3d0*xos - 1d0) + 4d0
      d = xom*xop**2
c                                 get first gammas 
      call hsmrkp (ins, 1, jns, 1)
c                                 hybrid gamma factor for water:
      ghh2o = gh2o/gmh2o

      call mrkpur (ins, 4) 

      gh2o = gh2o * ghh2o
c                                 get first guess:
      turd = 1d0/3d0

      if (xo.lt.turd) then 
         xl = 2d0 *  xo/(1d0-xo)
      else if (xo.gt.turd) then
         xl = 2d0 * (1d0-xo)/xop
      end if
c                                 outer iteration loop:
      do j = 1, 20

         c2 = gh2/gh2s
         c4 = gh2o**2/gso2/gh2**2
         c =  c0 - 8d0*c3*c4*(1d0+c1*c2)**2
         xh2o = xl
         xi = xl

         do i = 1, 30
c                                 inner iteration loop:
            f = a + b * xh2o + c * xh2o**2 + d * xh2o**3
    
            df = b + 2d0 * c * xh2o + 3d0 * d * xh2o ** 2
            xh2o = xi - f/df

            xh2  = (-xo*xh2o-xh2o-2d0*xop)/(1d0+c1*c2)/2d0
            xh2s = c1*c2*xh2
            xso2 = c3*c4*xh2o**2/xh2**2
 
            if (dabs((xi-xh2o)/xh2o).lt.1d-6) goto 20
            if (xh2o.ge.1d0) xh2o = xi + (1d0-xi)/2d0
            xi = xh2o

         end do 

         goto 50 

20       xh2  = -0.5d0*(xo*xh2o+xh2o+2d0*xo-2d0)/(1d0+c1*c2)
         if (xh2.le.1d-5.and.xo.gt.turd) goto 50
         xh2s = c1*c2*xh2
         xso2 = c3*c4*xh2o**2/xh2**2

         if (j.gt.1.and.dabs((xl-xh2o)/xh2o).lt.1d-6) goto 40

         call mrkmix (ins, 4)
         gh2o = gh2o * ghh2o
         xl = xh2o
         xi = xh2o 

      end do 

      call warn (176,xh2o,nit,'HOSMRK')
      stop 

40    fh2o = dlog(gh2o*p*xh2o) 
      fo2 = 2d0 * (fh2o - dlog(gh2 * p * xh2) - kh2o)
      vol = vol + xh2o * vm(3)
      goto 99
c                                if xo.gt.turd, at high fs2
c                                the fluid will be binary:
50    xh2o = -2d0*xom/xop
      xso2 = 1d0 - xh2o
      xh2s = 0d0
      xh2 = 0d0
      call mrkmix (ins, 4)
      vol = vol + xh2o * vm(3)
      gh2o = gh2o * ghh2o
      fh2o = dlog(gh2o*p*xh2o) 
      fo2 = dlog(gso2*p*xso2) - kso2 - fs2

99    end

      subroutine hosrk5 (fo2)
c-----------------------------------------------------------------------
c program to calculate H-O-S speciation as a function of XO using
c an MRK/HSMRK hybrid. Species are H2 O2 H2O H2S SO2.
c-----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      double precision fo2,fs2,ek1,ek2,kcos,ek3,xom,xop,xos,c0,c1,c2,c3,
     *                 c4,c5,c6,c7,a,b,c,d,ghh2o,turd,xl,xi,f,df

      integer ins(nsp), jns(3),j,i,nit

      double precision gmh2o,vm
      common/ cstchx /gmh2o,vm(5)

      double precision vol
      common/ cst26 /vol

      double precision xh2o,xco2,xco,xch4,xh2,xh2s,xo2,xso2,xcos,xn2,
     *                 xnh3,gh2o,gco2,gco,gch4,gh2,gh2s,go2,gso2,gcos,
     *                 gn2,gnh3,v
      common/ cstcoh /xh2o,xco2,xco,xch4,xh2,xh2s,xo2,xso2,xcos,xn2,
     *                xnh3,gh2o,gco2,gco,gch4,gh2,gh2s,go2,gso2,gcos,
     *                gn2,gnh3,v(nsp)


      double precision p,t,xo,u1,u2,tr,pr,r,ps
      common / cst5 /p,t,xo,u1,u2,tr,pr,r,ps

      double precision fh2o,fco2
      common/ cst11 /fh2o,fco2

      save ins,jns

      data ins, jns/ 1,5,6,7,8,6*0,1,2*0/
c                                check if xo is <1, >0,
c                                reset if necessary
      if (xo.gt.0.9999999999d0) then
         xo = 0.9999999999d0
      else if (xo.lt.1d-8) then
         xo = 1d-8
      end if
c                                this fs2 = 1/2 ln (fs2),
c                                k's are ln(k)
      call setfs2 (fs2,ek1,ek2,kcos)
c                                kh2o from robie:
      ek3 = dexp(-7.028214449d0+30607.34044d0/t-475034.4632d0/t/t 
     *                         +50879842.55d0/t/t/t)
    
      xom = xo - 1d0
      xop = xo + 1d0
      xos = xo * xo

      c1 = dexp(ek1 + fs2)
      c3 = dexp(ek2 + fs2)
      c5 = 1d0/p/ek3/ek3
      a = -8d0*xo*xom**3
      b = -4d0*(3d0*xos+1d0)*xom**2 
      c0 = 2d0*xom*(-xop * (3d0*xo*xom + 2d0))
      c7 = 8d0*xom*c5
      d = -xom**2 * xop**2
c                                 get first gammas 
      call hsmrkp (ins, 1, jns, 1)
c                                 hybrid gamma factor for water:
      ghh2o = gh2o/gmh2o

      call mrkpur (ins, 5) 

      gh2o = gh2o * ghh2o
c                                 get first guess:
      turd = 1d0/3d0

      if (xo.lt.turd) then 
         if (xo.gt.0.3333333333333333d0) xo = 0.3333333333333333d0
         xl = 2d0 *  xo/(1d0-xo)
      else if (xo.gt.turd) then
         if (xo.lt.0.3333334d0) xo = 0.3333334d0
         xl = 2d0 * (1d0-xo)/(1d0 + xo)
      end if
c                                 outer iteration loop:
      do 30 j = 1, 20

         c2 = gh2/gh2s
         c4 = go2/gso2
         c6 = gh2o**2/gh2**2/go2
         c =  c0 + c7*c6*(1d0+c1*c2)**2*(1d0+c3*c4)
         xh2o = xl
         xi = xl

         do 10 i = 1, 30
c                                 inner iteration loop:
            f = a + b * xh2o + c * xh2o**2 + d * xh2o**3
    
            df = b + 2d0 * c * xh2o + 3d0 * d * xh2o ** 2
            xh2o = xi - f/df

            xh2  = -0.5d0*(xo*xh2o+xh2o+2d0*xo-2d0)/(1d0+c1*c2)
            xh2s = c1*c2*xh2
            xo2 = c5*c6*(xh2o*xh2o)/(xh2*xh2)
            xso2 = c3*c4*xo2
 
            if (dabs((xi-xh2o)/xh2o).lt.1d-6) goto 20
            if (xh2o.ge.1d0) xh2o = xi + (1d0-xi)/2d0
10          xi = xh2o

         call warn (176,xh2o,nit,'HOSRK5')
         stop 

20       xh2  = -0.5d0*(xo*xh2o+xh2o+2d0*xo-2d0)/(1d0+c1*c2)
         xh2s = c1*c2*xh2
         xo2 = c5*c6*(xh2o*xh2o)/(xh2*xh2)
         xso2 = c3*c4*xo2

         if (j.gt.1.and.dabs((xl-xh2o)/xh2o).lt.1d-6) goto 40

         call mrkmix (ins, 5)
         gh2o = gh2o * ghh2o
         xl = xh2o
         xi = xh2o 
30    continue
      call warn (176,xh2o,nit,'HOSRK5')
      stop 

40    fh2o = dlog(gh2o*p*xh2o) 
      vol = vol + xh2o * vm(3)
      if (xo2.lt.xh2) then
         fo2 = 2d0 * (fh2o - dlog(gh2 * p * xh2) - dlog(ek3))
      else
         fo2 = dlog (go2 * p * xo2)
      end if
      end  

      subroutine homrk (fo2)
c-----------------------------------------------------------------------
c program to calculate H-O speciation as a function of XO using
c an MRK/HSMRK hybrid. 
c-----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      double precision fo2,k,turd,c1,c10,c11,c12,c13,c14,ghh2o,xl,xi,
     *                 x12

      integer ins(nsp), jns(3),i,j,nit

      double precision gmh2o,vm
      common/ cstchx /gmh2o,vm(5)

      double precision xh2o,xco2,xco,xch4,xh2,xh2s,xo2,xso2,xcos,xn2,
     *                 xnh3,gh2o,gco2,gco,gch4,gh2,gh2s,go2,gso2,gcos,
     *                 gn2,gnh3,v
      common / cstcoh /xh2o,xco2,xco,xch4,xh2,xh2s,xo2,xso2,xcos,xn2,
     *                 xnh3,gh2o,gco2,gco,gch4,gh2,gh2s,go2,gso2,gcos,
     *                 gn2,gnh3,v(nsp)

      double precision vol
      common/ cst26 /vol

      double precision p,t,xo,u1,u2,tr,pr,r,ps
      common / cst5 /p,t,xo,u1,u2,tr,pr,r,ps

      double precision fh2o,fco2
      common/ cst11 /fh2o,fco2

      save ins,jns

      data ins, jns/ 1,5,7,8*0,1,2*0/
c                                check if xo is <1, >0,
c                                reset if necessary
      if (xo.gt.0.9999999999d0) then
         xo = 0.9999999999d0
      else if (xo.lt.1d-8) then
         xo = 1d-8
      end if 

      k = dexp(-7.028214449d0 + 30607.34044d0/t - 475034.4632d0/t/t
     *                        + 50879842.55d0/t/t/t)

      turd = 1d0/3d0

      c1 = 1d0/dsqrt(p)/k

      c10 = (xo - 1d0)/2d0
      c11 = 1d0 - xo
      c12 = 1d0 + c10
c                                 get first gammas 
      call hsmrkp (ins, 1, jns, 1)
c                                 hybrid gamma factor for water:
      ghh2o = gh2o/gmh2o

      call mrkpur (ins, 3) 

      gh2o = gh2o * ghh2o

      if (xo.lt.turd) then 
         if (xo.gt.0.3333333333333333d0) xo = 0.3333333333333333d0
         xl = 2d0 *  xo/c11
      else if (xo.gt.turd) then
         if (xo.lt.0.3333334d0) xo = 0.3333334d0
         xl = 2d0 * c11/(1d0 + xo)
      end if 
c                                 outer iteration loop:
      do 30 j = 1, 10
c                                 
         c13 = c1 * gh2o/gh2/dsqrt(go2)
         c14 = c10 * c13/2d0
         xi = xl

         do 10 i = 1, 10
c                                 inner iteration loop:
            xo2 = xo + c10 * xh2o

            if (xo2.gt.1d-9) then  

               x12 = dsqrt (xo2)

               xh2o = xi + 
     *               (c11 - c12 * xh2o - c13 * xh2o/x12) /
     *               (c12 + c13 * x12 + c14 * xh2o/x12)

            else 

               xh2o = 2d0 *  xo/c11 

            end if 

            if (dabs((xi-xh2o)/xh2o).lt.1d-6) goto 20
            if (xh2o.ge.1d0) xh2o = xi + (1d0-xi)/2d0
10          xi = xh2o

         call warn (176,xh2o,nit,'HOMRK')
         stop 

20       if (xo2.lt.0d0) xo2 = 0d0
         xh2 = 1d0 - xo2 - xh2o
         if (j.gt.1.and.dabs((xl-xh2o)/xh2o).lt.1d-6) goto 40
         call mrkmix (ins, 3)
         gh2o = gh2o * ghh2o
         xl = xh2o
         xi = xh2o 
30    continue

      call warn (176,xh2o,nit,'HOMRK')
      stop 

40    fh2o = dlog(gh2o*p*xh2o)
      vol = vol + xh2o * vm(3) 
      
      if (xo2.lt.xh2) then
         fo2 = 2d0 * (fh2o - dlog(gh2 * p * xh2) - dlog(k))
      else
         fo2 = dlog (go2 * p * xo2)
      end if

      end 

      double precision function fugp (rtt,b,yz,c,d,e,v)
c----------------------------------------------------------------------
c streamlined JADC July 96.
c----------------------------------------------------------------------
      implicit none

      double precision y,y1,vpb,dvbv,rtt,b,yz,c,d,e,v
c----------------------------------------------------------------------
  
      y = b/4d0/v
      vpb = v + b
      dvbv = dlog(vpb/v)
      y1 = 1d0 - y

      fugp = ((4d0-3d0*y)*y + (2d0-y)*2d0*y/y1)/y1/y1
     *     + (d*(dvbv/b + (4d0*y + 2d0)/vpb - 3d0/v)
     *      - c*(dvbv + b/vpb)
     *      + e*((4d0/b-2d0/v)/v - dvbv/b/b 
     *         + ((2d0*y - 1.5d0)/v - 3d0/b)/vpb)
     *        )/rtt/b - dlog(yz)

      end

      function fug (rtt,cij,dij,eij,x1,x2,b,yz,c,d,e,b1,c1,d1,e1)
c---------------------------------------------------------------------
c streamlined JADC July 96.
c---------------------------------------------------------------------
      implicit none

      double precision rtt,cij,dij,eij,x1,x2,b,yz,c,d,e,b1,c1,d1,e1,y,
     *                 vpb,dvbv,y1,dvbvb,vi,vi2,fug
 
      double precision v
      common/ cst26 /v
c----------------------------------------------------------------------
      y = b/4d0/v
      vpb = v + b
      dvbv = dlog(vpb/v)
      y1 = 1d0 - y
      dvbvb = dvbv/b
      vi = 1d0/v
      vi2 = .5d0/v/v

      fug =  ((4d0-3d0*y)*y + b1/b*(2d0-y)*y*2d0/y1)/y1/y1
     *     + (c*b1*(dvbvb - 1d0/vpb)
     *     - (c1*x1+cij*x2)*2d0*dvbv
     *     + (2d0*(x1*d1+dij*x2)+d)*(dvbvb - vi)
     *     + d*b1*((vi+2d0/b)/vpb - 2d0*dvbvb/b)
     *     + 2d0*(e1*x1+eij*x2+e)*((vi - dvbvb)/b - vi2) 
     *     + e*b1*((vi2 - (1.5d0/v+3d0/b)/b)/vpb + 3d0*dvbvb/b/b)
     *       )/rtt/b-dlog(yz)
 
      end
 
      subroutine brmrk
c-----------------------------------------------------------------------
c brmrk routine to calculate molar volume and fugacity of co2 from
c bottinga and richet 1981, ajs v 281.
c                                 j. connolly 1988.
c
c  for the unitiated, input and output is done through common blocks
c  cst5, cst11, and cst26, the relevant variables are:
c
c  for input:
c               p    = pressure in bars
c               t    = temperature in kelvins
c               r    = gas constant
c               xco2 = mole fraction of co2 in fluid phase
c  for output:
c               v    = molar volume (cm3/mole) at p and t
c               fco2 = the natural log of the co2 fugacity
c-----------------------------------------------------------------------
      implicit none

      double precision vdpdv,v1,v2,f1,f2

      double precision p,t,xco2,u1,u2,tr,pr,r,ps
      common/ cst5  /p,t,xco2,u1,u2,tr,pr,r,ps

      double precision v
      common/ cst26 /v

      double precision fh2o,fco2
      common/ cst11 /fh2o,fco2
c                                 external function to calculate
c                                 the product v(dp/dv)
      external vdpdv
 
      if (xco2.ne.1d0) then
         xco2 = 1
         call warn (35,xco2,0,'BRMRK ')
      end if
c                                 call brvol to calculate volume
c                                 of co2.
      call brvol (1d0,t,v1)
c
      call brvol (p,t,v2)
c                                 call qromb to evaluate integral
c                                 of (dp/dv)dv
      if (v2.ge.180d0) then
c                                 if b&r equation is continuous
c                                 through limits v1 to v do 
c                                 integration in one chunk.
         call qromb (vdpdv,v1,v2,fco2)
c
      else if (v2.gt.47.22d0) then
c                                 else do the integration in parts
         call qromb (vdpdv,v1,180d0,f1)
         call qromb (vdpdv,180d0,v2,f2)
         fco2 = f1 + f2
c
      else
c
         call qromb (vdpdv,v1,180d0,f1)
         call qromb (vdpdv,180d0,47.22d0,f2)
         call qromb (vdpdv,47.22d0,v2,fco2)
         fco2 = fco2 + f1 + f2
 
      end if
 
      v = v2
      fco2 = fco2/(10d0*r*t)
 
      end
 
      subroutine brvol (p,t,vol)
c-----------------------------------------------------------------------
c brvol function to calculate molar volume of co2 by newton-raphson
c iteration of eq 3 of bottinga and richet 1981, ajs v 281.
 
c input:  p = pressure in bars, t = temperature in kelvins, v = molar
c         volume of co2 (cm3) estimated by the mrk equation of state.
 
c output: brvol = molar volume of co2 in (cm3/mole)
 
c                                 j. connolly 1988.
c-----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer ins(nsp),itic

      double precision dv,a1,a2,a3,rbar,rt,t12,b1,b2,a,b,vp,bp,fv,p,
     *                 dpdv,t,ap,vol

      double precision v
      common/ cst26 /v
 
      save rbar, dv, a1, a2, a3, ins
 
      data rbar,dv/83.143d0,0.001d0/,a1,a2,a3/6.566d7,7.276d7,37.3d0/,
     *     ins/2,10*0/
c---------------------------------------------------------------------
c                                 get initial v estimate.
      call mrkpur (ins, 1)

      rt = rbar * t
      t12 = dsqrt(t)
      itic = 0
c                                 brvol appoximates the derivative dp/dv
c                                 by finite difference with dv (in cm3)
      dv = 0.00005d0
c                                 choose parameters for b&r's equation
10    if (v.le.47.22d0) then
         b1 = 1.856669d0
         b2 = 0.0637935d0
      else if (v.lt.180d0) then
         b1 = 11.707864d0
         b2 = 0.363955d0
      else
         b1 = 7.352629d0
         b2 = 0.241413d0
      end if
c                                 at v:
      b = (dlog(v/a3)+b1)/b2
      a = a1*( (a3/v)**3 - (a3/v)**6 ) + a2
c                                 and at vp:
      vp = v + dv
c
      bp = (dlog(vp/a3)+b1)/b2
      ap = a1*( (a3/vp)**3 - (a3/vp)**6 ) + a2
c
      fv = rt/(v-b) - a/(v*(v+b)*t12) - p
      dpdv = (fv - (rt/(vp-bp) - ap/(vp*(vp+bp)*t12) - p))/dv
c                                 refine estimate:
      v = v + fv/dpdv
c                                 if the change from the last estimate
c                                 is less than 0.001 cm3 leave.
      if (dabs(fv/dpdv).lt.1d-3) goto 99
      itic = itic + 1
      if (itic.gt.50) goto 999
 
      goto 10
 
999   call warn (176,ap,itic,'BRVOL')
      stop
99    vol = v
      end
 
      function vdpdv (v)
c-----------------------------------------------------------------------
c dpdv function to calculate the finite difference approximation of
c the product v(dp/dt) for the equation of bottinga and richet 1981,
c ajs v 281, eq 3.
c input: v - molar volume of co2 in j/bar
c        t - temperature in k (common block cst5)
c output:vdpdv - the approximation of v(dp/dv)

c                                 j. connolly 1988.
c-----------------------------------------------------------------------
      implicit none

      double precision rbar,dv,a1,a2,a3,t12,b1,b2,v,bp,ap,vdpdv,rt,a,b,
     *                 vp,pp

      double precision p,t,xco2,u1,u2,tr,pr,r,ps
      common/ cst5  /p,t,xco2,u1,u2,tr,pr,r,ps
 
      save rbar, dv, a1, a2, a3
 
      data rbar,dv/83.143d0,1d-3/a1,a2,a3/6.566d7,7.276d7,37.3d0/
c---------------------------------------------------------------------
 
      rt = rbar * t
      t12 = dsqrt(t)

      if (v.le.47.22d0) then
         b1 = 1.856669d0
         b2 = 0.0637935d0
      else if (v.lt.180d0) then
         b1 = 11.707864d0
         b2 = 0.363955d0
      else
         b1 = 7.352629d0
         b2 = 0.241413d0
      end if

      b = (dlog(v/a3)+b1)/b2
      a = a1*( (a3/v)**3 - (a3/v)**6 ) + a2
 
      vp = v + dv
 
      bp = (dlog(vp/a3)+b1)/b2
      ap = a1*( (a3/vp)**3 - (a3/vp)**6 ) + a2
 
      pp = rt/(v-b) - a/(v*(v+b)*t12)
      vdpdv = -v*(pp - (rt/(vp-bp) - ap/(vp*(vp+bp)*t12) ))/dv
 
      end
 
      subroutine simps (func,a,b,dx,ss)
c------------------------------------------------------------------
c subroutine to numerically integrate the function func over the
c limits a to b, in n increments by simpsons method, the integral
c is returned as ss. from conte and deboor 1981.
c                               jadc, aug 1990.
c------------------------------------------------------------------
      implicit none
 
      integer i,n

      double precision func,b,a,dx,ss,x,h,hover2,half
 
      external func
 
      n = idint (dabs(b-a)/dx)
      if (n.lt.100) n = 100
 
      h = (b-a)/dfloat(n)
      hover2 = h/2d0
      ss = 0d0
 
      half = func (a + hover2)
 
      do i = 1, n-1
         x = a + h * dfloat(i)
         ss = ss + func(x)
         half = half + func (x + hover2)
      end do 
 
      ss = (h/6d0) * (func(a) + 4d0*half + 2d0*ss + func(b))
 
      end
 
      subroutine qromb (func,a,b,ss)
c-----------------------------------------------------------------------
c subroutine to numerically integrate a function func over the limits
c a to b by romberg's method, the value of the integral is returned as
c ss.

c eps is the relative error acceptable for the estimate.
c jmax is the number of iterations permitted.
c k is the minimum number of iterations(?)
c
c from numerical recipes by press et al. 1988.
c                                 jadc
c-----------------------------------------------------------------------
      implicit none

      integer j,jmax,jmaxp,k

      double precision func,eps,a,b,ss,dss

      parameter (eps=1d-8, jmax = 20, jmaxp = jmax+1, k = 5)

      double precision s(jmaxp), h(jmaxp)
 
      external func
  
      h(1) = 1d0
      do j = 1, jmax
         call trapzd (func,a,b,s(j),j)
         if (j.ge.k) then
            call polint(h,s,j,0d0,ss,dss)
            if (dabs(dss).lt.eps*dabs(ss)) return
         end if
         s(j+1)= s(j)
         h(j+1)= h(j)/4d0
      end do 

      write (*,*) '**error ver410** didnt converge in qromb'
      stop
      end
c
      subroutine polint (h,s,k,x,ss,dss)
c-----------------------------------------------------------------------
c subroutine to extrapolate a polynomial of degree k - 1 to obtain its
c value ss at x, where dss is an estimate of the error in ss.
c the array s contains the values of the function at the corresponding
c values of the array h.
c
c from numerical recipes by press et al. 1988.
c                                 jadc
c-----------------------------------------------------------------------
      implicit none

      integer i,k,ns,m

      double precision s(k),h(k),c(40),d(40),x,ss,dss,dif,dift,ho,hp,w,
     *                 den 

      if (k.gt.40) then
         write (*,*) '**error ver409** ugabugga polint k=',k
         stop
      end if

      ns = 1
      dif = dabs(x-h(1))
      do i = 1, k
         dift = dabs(x-h(i))
         if (dift.lt.dif) then
            ns = i
            dif = dift
         end if
         c(i)=s(i)
         d(i)=s(i)
      end do 

      ss = s(ns)
      ns = ns - 1
      do m = 1, k-1
         do i = 1, k-m
            ho = h(i) - x
            hp = h(i+m) - x
            w = c(i+1) - d(i)
            den = ho - hp
            if (den.eq.0d0) then
               write (*,*) '**error ver498** polint'
               stop
            end if
            den = w/den
            d(i) = hp * den
            c(i) = ho * den
         end do 
         if (2*ns.lt.k-m) then
            dss = c(ns+1)
         else
            dss = d(ns)
            ns = ns - 1
         end if
         ss = ss + dss

      end do 

      end

      subroutine trapzd (func,a,b,s,j)
c-----------------------------------------------------------------------
c subroutine to compute the j'th stage of refinement of an extended
c trapezoidal rule, returned as s, of the function func between a and b

c from numerical recipes by press et al. 1988.
c                                 jadc
c-----------------------------------------------------------------------
      implicit none

      integer i,j,it

      double precision func,a,b,s,tnm,del,x,sum
 
      external func
 
      if (j.eq.1) then
         s = (b-a)*(func(a)+func(b))/2d0
      else  
         it = j
         tnm = it
         del = (b-a)/tnm
         x = a + del/2d0
         sum = 0d0
 
         do i = 1, it
            sum = sum + func(x)
            x = x + del
         end do 
         s = (s+(b-a)*sum/tnm)/2d0
         it = it * 2
      end if
 
      end
 
      subroutine hprk
c-----------------------------------------------------------------------
c hprk routine to compute h2o-co2 fugacities from the holland and
c powell (cmp 1991)
c                                 j. connolly 1992.
 
c  for the unitiated input and output is done through common blocks
c  cst5, cst11, and cst26, the relevant variables are:
 
c  for input:
c               pbars= pressure in bars
c               t    = temperature in kelvins
c               r    = gas constant
c               xco2 = mole fraction of co2 in fluid phase
c  for output:
c               v    = molar volume (cm3/mole) at p and t
c               fco2 = the natural log of the co2 fugacity
c-----------------------------------------------------------------------
      implicit none

      double precision rt,p,vco2,vol,xh2o,wco2,wh2o,gco2,gh2o
 
      double precision pbars,t,xco2,u1,u2,tr,pr,r,ps
      common/ cst5 /pbars,t,xco2,u1,u2,tr,pr,r,ps

      double precision fh2o,fco2
      common/ cst11 /fh2o,fco2
c----------------------------------------------------------------------
      rt = r*t/1d3
 
      p = pbars/1d3
 
      if (xco2.eq.1d0) then
 
         call crkco2 (pbars,t,vco2,fco2) 

      else if (xco2.eq.0d0) then
 
         call crkh2o (pbars,t,vol,fh2o) 

      else

         call crkco2 (pbars,t,vco2,fco2) 
         call crkh2o (pbars,t,vol,fh2o) 
  
         xh2o = 1d0 - xco2
 
         wco2 = (13.2d0 - .290d0 * dsqrt(t)) * p**0.25d0
         wh2o = (7.0d0  - 0.15d0 * dsqrt(t)) * p**0.25d0
 
         gco2 = xh2o*xh2o*(wco2+2d0*xco2*(wh2o-wco2))/rt
         gh2o = xco2*xco2*(wh2o+2d0*xh2o*(wco2-wh2o))/rt
 
         fco2 = fco2 + gco2 + dlog(xco2)
         fh2o = fh2o + gh2o + dlog(xh2o)
 
      end if
      end

      subroutine mrk
c---------------------------------------------------------------------
c  routine to calculate properties of H2O-CO2 mixtures using the
c  MRK EoS.
c---------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer ins(nsp), jns(nsp)

      double precision p,t,xc,u1,u2,tr,pr,r,ps
      common / cst5 /p,t,xc,u1,u2,tr,pr,r,ps

      double precision x,g,v
      common/ cstcoh /x(nsp),g(nsp),v(nsp)
 
      save jns 
 
      data jns/ 1, 2, 9*0/
 
      if (xc.eq.1d0) then
         ins(1) = 2
         call mrkpur (ins, 1)
         goto 99          
      else if (xc.eq.0d0) then
         ins(1) = 1
         call mrkpur (ins, 1)
         goto 99
      end if

      x(2) = xc
      x(1) = 1d0 - xc
      call mrkmix (jns, 2)
99    end
 
      subroutine hsmrk
c---------------------------------------------------------------------
c  main program and subprograms written by gary k. jacobs june 1980
c  modified for therm april 1982      jadc
c---------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer jns(3), ins(nsp)
 
      double precision bc,bw,xw,t15,rtt,t2,cc,dc,ec,cw,dw,ew,bm,cij,
     *                 dij,eij,xc2,xw2,xwc2,cm,dm,em,yzm,fug

      double precision pbar,tk,xc,u1,u2,tr,pr,r,ps
      common/ cst5 /pbar,tk,xc,u1,u2,tr,pr,r,ps

      double precision p,t,t12,rr
      common/ cst85 /p,t,t12,rr

      double precision fh2o,fco2
      common/ cst11 /fh2o,fco2
 
      save bw, bc
 
      data bw, bc/ 29d0, 58d0/
c----------------------------------------------------------------------
      if (xc.eq.1d0) then
         ins(1) = 2
         jns(1) = 2
         call hsmrkp (ins, 1, jns, 1)
         goto 99          
      else if (xc.eq.0d0) then
         ins(1) = 1
         jns(1) = 1
         call hsmrkp (ins, 1, jns, 1)
         goto 99
      end if
 
      xw = 1d0 - xc
      p = pbar
      t = tk
      t15 = dsqrt(t**3)
      t12 = dsqrt(t)
      rtt = rr*t15
      t2 = t*t
 
      cc = 28.31d6+0.10721d6*t-0.00000881d6*t2
      dc = 9380d6-8.53d6*t+0.001189d6*t2
      ec = -368654d6+715.9d6*t+0.1534d6*t2
      cw = 290.78d6-0.30276d6*t+0.00014774d6*t2
      dw = -8374d6+19.437d6*t-0.008148d6*t2
      ew = 76600d6-133.9d6*t+0.1071d6*t2
 
      bm = bc*xc+bw*xw
 
      cij = cc * cw
      dij = dc * dw
      eij = ec * ew
      if (dij.lt.0d0.or.eij.lt.0d0.or.cij.lt.0d0) then
         write (*,1000) p,t
         eij = 0d0
         dij = 0d0
         cij = 0d0
      else
         cij = dsqrt(cij)
         dij = dsqrt(dij)
         eij = dsqrt(eij)
      end if
 
      xc2 = xc*xc
      xw2 = xw*xw
      xwc2 = 2d0*xc*xw
      cm = cc*xc2+cw*xw2+xwc2*cij
      dm = dc*xc2+dw*xw2+xwc2*dij
      em = ec*xc2+ew*xw2+xwc2*eij
c                                 get initial volume estimate for
c                                 newrap from mrk, implicit in newrap
 
c                                 solve for hsmrk volume
      call newrap (bm,cm,dm,em,yzm)
c                                 calculate hsmrk (log) fugacities:
      fco2 = dlog(xc*p)+ fug(rtt,cij,dij,eij,xc,xw,bm,yzm,cm,
     *                      dm,em,bc,cc,dc,ec)
      fh2o = dlog(xw*p)+ fug(rtt,cij,dij,eij,xw,xc,bm,yzm,cm,
     *                      dm,em,bw,cw,dw,ew)
 
1000  format ('**warning ver678** p,t (',g9.3,1x,g9.3,
     *        ') conditions are out of range for HSMRK',/,
     *        'your results may be incorrect.')
 
99    end
 
      subroutine newrap (b,c,d,e,yz)
c----------------------------------------------------------------------
      implicit none

      integer k

      double precision x,y,bi,bi2,vi2,vi3,x3,y3,pn,pa1,d1,d3,df,yz,
     *                 diff,v,b,c,d,e
 
      double precision p,t,t12,r
      common/ cst85 /p,t,t12,r

      double precision vi
      common/ cst26 /vi
c----------------------------------------------------------------------
c                                 call mrk to get initial volume
      call mrk
 
      do k = 1, 50
 
      y = b/4d0/vi
      x = 1d0 - y
 
      bi = vi + b
      bi2 = bi * bi
      vi2 = vi * vi
      vi3 = vi2 * vi
      x3 = x**3
      y3 = y**3
 
      pn = 1d0 + y + y*y - y3
      pa1 = c + d/vi + e/vi2
 
      d1 = -.75d0 * b/vi3/x/x3  - 1d0/vi2/x3
      d3 = (-b/4d0/vi2 - 2d0 * b * b/16d0/vi3
     *     + 0.046875d0 * b**3/vi/vi3 )/ vi/x3
 
      df = ( pn * d1 + d3 )*r*t
     *      - (pa1 * (-1d0/vi/bi2 - 1d0/vi2/bi)
     *      + ( -d/vi2 - 2d0 * e/vi3)/ vi/bi )/t12
 
      v = vi - (pn/vi/x3 * r * t - pa1/t12/vi/bi - p)/df
      diff = dabs(v-vi)
      vi = v
 
      if (diff.lt.0.01d0) goto 99

      end do 
 
99    yz = vi * p/83.14d0/t
 
      end
 
      subroutine qrkmrk
c---------------------------------------------------------------------
c  qrkmrk calculates the log of water and co2 fugacities using the hsmrk
c  for pure fluids, and the mrk for the acivities of h2o and co2 in
c  mixtures
c-----------------------------------------------------------------------
      implicit none

      double precision bw,bc,xw,t15,t2,dlp,rtt,cc,dc,ec,cw,dw,ew,fmh2o,
     *                 xmc,yzm,fmco2,tfh2o,fug

      double precision pbar,tk,xc,u1,u2,tr,pr,rcal,ps
      common/ cst5 /pbar,tk,xc,u1,u2,tr,pr,rcal,ps

      double precision p,t,t12,r
      common/ cst85 /p,t,t12,r

      double precision fh2o,fco2
      common/ cst11 /fh2o,fco2
 
      save bw, bc
 
      data bw, bc/29d0, 58d0/
c-----------------------------------------------------------------------
      t = tk
 
      if (xc.ge.1d0) then
         call hsmrk
         goto 99
      else if (xc.le.0d0) then
         call hsmrk
         goto 99
      end if
 
      xw = 1d0 - xc
      p = pbar
      t15 = dsqrt(t**3)
      t12 = dsqrt(t)
      t2 = t*t
      dlp  = dlog(p)
      rtt = r*t15
 
      cc = 28.31d6+0.10721d6*t-0.00000881d6*t2
      dc = 9380d6-8.53d6*t+0.001189d6*t2
      ec = -368654d6+715.9d6*t+0.1534d6*t2
      cw = 290.78d6-0.30276d6*t+0.00014774d6*t2
      dw = -8374d6+19.437d6*t-0.008148d6*t2
      ew = 76600d6-133.9d6*t+0.1071d6*t2
c                                 mixed volatiles
c                                 call mrk to get ln fugacities of
c                                 h2o and co2 in binary mixes,
c                                 save as fmh2o and fmco2:
      call mrk
      fmh2o = fh2o
      fmco2 = fco2
      xmc = xc
c                                 call mrk (this call is now 
c                                 implicit in newrap) to get pure 
c                                 f(h2o) & estimate V for hsmrk
      xw = 1d0 
      xc = 0d0 
c                                 call newrap for hsmrk h2o volume:
      call newrap (bw,cw,dw,ew,yzm)
c                                 calculate water fugacity save as
c                                 th2o.
      tfh2o = dlp + fmh2o - fh2o
     *     + fug(rtt,cw,dw,ew,xw,xc,bw,yzm,cw,dw,ew,bw,cw,dw,ew)
c                                 co2
      xc = 1d0
      xw = 0d0
 
      call newrap (bc,cc,dc,ec,yzm)
      fco2 = dlp + fmco2 - fco2
     *     + fug(rtt,cc,dc,ec,xc,xw,bc,yzm,cc,dc,ec,bc,cc,dc,ec)
      fh2o = tfh2o
 
      xc = xmc
 
99    end
 
      subroutine haar
c-----------------------------------------------------------------------
c     this code is modified from a source file obtained from
c     Bern Univerisity and written by Christian DeCapitani at ubc.
 
c     for a documented and more general program see
c     post 1984 steam tables.
 
c haar routine to calculate molar volume and fugacity of h2o from the
c equation of haar et al (steam tables).
 
c                                 jadc 1989.
 
c  for the unitiated input and output is done through common blocks
c  cst5, cst11, and cst26, the relevant variables are:
 
c  for input:
c               p    = pressure in bars
c               t    = temperature in kelvins
c               rref = gas constant
c               xco2 = mole fraction of co2 in fluid phase
c  for output:
c               vh2o = molar volume (cm3/mole) at p and t
c               fh2o = the natural log of the h2o fugacity
c-----------------------------------------------------------------------
      implicit none

      double precision r,t0,amh2o,b,bb,ps,rhn,rh,rh2,y,er,y3,aly,rt,
     *                 bety,f1,f2,pr,dpr,s,del,rhoi2,tau,abc,q10,qm,
     *                 x,dp,dr,gh2o,aid,gid,aa

      integer i,loo,nlow,nhigh
 
      double precision vh2o
      common/ cst26 /vh2o

      double precision fh2o,fco2
      common/ cst11 /fh2o,fco2

      double precision p,t,v,tref,pref,rref,v4
      common/ cst5 /p,t,v(3),tref,pref,rref,v4
 
      integer ki(40), li(40)

      double precision taui(0:6), ermi(0:9), gi(40)
      double precision rhoi(37:40),ttti(37:40),alpi(37:40),beti(37:40)
 
c -----gi are in (bar cc / g)  =  10 * (j / g)
 
      save ki, li, gi, rhoi, ttti, alpi, beti, r, t0, amh2o
 
      data gi /-.53062968529023d4, .22744901424408d5, .78779333020687d4,
     1     -.69830527374994d3, .17863832875422d6, -.39514731563338d6,
     2     .33803884280753d6, -.13855050202703d6, -.25637436613260d7,
     3     .48212575981415d7, -.34183016969660d7, .12223156417448d7,
     4     .11797433655832d8, -.21734810110373d8, .10829952168620d8,
     5     -.25441998064049d7, -.31377774947767d8, .52911910757704d8,
     6     -.13802577177877d8, -.25109914369001d7, .46561826115608d8,
     7     -.72752773275387d8, .41774246148294d7, .14016358244614d8,
     8     -.31555231392127d8, .47929666384584d8, .40912664781209d7,
     9     -.13626369388386d8, .69625220862664d7, -.10834900096447d8,
     *     -.22722827401688d7, .38365486000660d7, .68833257944332d5,
     1     .21757245522644d6, -.26627944829770d5, -.70730418082074d6,
     2     -.225d1, -1.68d1, .055d1, -93.0d1/
 
      data ki /4*1, 4*2, 4*3, 4*4, 4*5, 4*6, 4*7, 4*9, 2*3, 1, 5, 3*2,
     1     4/
 
      data li /1, 2, 4, 6, 1, 2, 4, 6, 1, 2, 4, 6, 1, 2, 4, 6, 1, 2, 4,
     1     6, 1, 2, 4, 6, 1, 2, 4, 6, 1, 2, 4, 6, 0, 3*3, 0, 2, 0, 0/
 
      data rhoi /0.319d0, 0.310d0, 0.310d0, 1.55d0/
      data ttti /640d0, 640d0, 641.6d0, 270d0/
      data alpi /34d0, 40d0, 30d0, 1050d0/
      data beti /2d4, 2d4, 4d4, 25d0/
      data r, t0, amh2o/4.6152d0,647.073d0,18.0152d0/
 
      rt = r * t
      nlow = 40
      nhigh = 20
      if (t .lt. 449.35d0) nhigh = 40
 
c -----the values (t/t0)**i are stored in the array taui(i)
 
      taui(0) = 1d0
      taui(1) = t/t0
 
      do i = 2, 6
         taui(i) = taui(i - 1) * taui(1)
      end do 
 
      b = -0.3540782d0 * dlog(taui(1)) + 0.7478629d0 +0.007159876d0 /
     1    taui(3) - 0.003528426d0/taui(5)
      bb = 1.1278334d0 - 0.5944001d0/taui(1) - 5.010996d0/taui(2) +
     1     0.63684256d0/taui(4)
c
      ps = 220.55d0
      if (t .le. 647.25d0) call psat2(t, ps)
c                                 get initial guess for volume from
c                                 mrk:
      call mrk
 
      rhn = 1d0/vh2o * amh2o
 
c -----find the true(?) rh(t,p)
c -----note: pr = pressure corresponding to guessed rh
c            dpr = (dp/drh)
c            the values (1-exp(-rh))**i are stored in the array ermi(i)
 
      do loo = 1, 100
        rh = rhn
        if (rh .le. 0d0) rh = 1d-8
        if (rh .gt. 1.9d0) rh = 1.9d0
        rh2 = rh** 2
        y = rh * b/4d0
        er = dexp(-rh)
        y3 = (1d0 - y)** 3
        aly = 11d0 * y
        bety = 44.33333333333333d0 * y**2
        f1 = (1d0 + aly + bety)/y3
        f2 = 4d0 * y * (bb/b - 3.5d0)
        ermi(0) = 1d0
        ermi(1) = 1d0 - er
        do i = 2, 9
           ermi(i) = ermi(i - 1) * ermi(1)
        end do 
  
        pr = 0d0
        dpr = 0d0
        do i = 1, 36
          s = gi(i)/taui(li(i)) * ermi(ki(i) - 1)
          pr = pr + s
          dpr = dpr + (2d0 + rh*(ki(i)*er - 1d0)/ermi(1)) * s
        end do 

        do i = nlow, nhigh
          del = rh/rhoi(i) - 1d0
          rhoi2 = rhoi(i) * rhoi(i)
          tau = t/ttti(i) - 1d0
          abc = -alpi(i) * del** ki(i) - beti(i) * tau** 2
          if (abc .gt. - 1d2) then
            q10 = gi(i) * del** li(i) * dexp(abc)
          else
            q10 = 0d0
          end if
          qm = li(i)/del - ki(i) * alpi(i) * del** (ki(i) - 1)
          s = q10 * qm * rh2/rhoi(i)
          pr = pr + s
          dpr = dpr + s * (2d0/rh + qm/rhoi(i)) - rh2/rhoi2 * q10 *
     1    (li(i)/del/del + ki(i)*(ki(i) - 1)*alpi(i)*del**(ki(i) - 2))
        end do 
        pr = rh * (rh*er*pr + rt*(f1 + f2))
        dpr = rh * er * dpr + rt * ((1d0 + 2d0*aly + 3d0*bety)/y3 
     *        + 3d0*y*f1/(1d0 - y) + 2d0*f2)
 
        if (dpr .le. 0d0) then
          if (p .le. ps) then
            rhn = rhn * 0.95d0
          else
            rhn = rhn * 1.05d0
          end if
        else
          if (dpr .lt. 1d-2) dpr = 1d-2
          x = (p - pr)/dpr
          if (dabs(x) .gt. 0.1d0) x = 1d-1 * x/dabs(x)
          rhn = rh + x
        end if
        dp = dabs(1d0 - pr/p)
        dr = dabs(1d0 - rhn/rh)
        if (dp .lt. 5d-2 .and. dr .lt. 5d-2) go to 60
      end do 
   60 rh = rhn
 
      y = rh * b/4d0
      x = 1d0 - y
      er = dexp(-rh)
      ermi(0) = 1d0 
      ermi(1) = 1d0 - er
 
      do i = 2, 9
         ermi(i) = ermi(i - 1) * ermi(1)
      end do 
 
c -----calculate base function
 
      aa = rt * (-dlog(x) - 43.33333333333333d0/x 
     *           + 28.16666666666667d0/x/x 
     *           + 4d0*y*(bb/b - 3.5d0) + 15.16666666666667d0
     *           + dlog(rh*rt/1.01325d0) )
 
c -----calculate residual function
 
      do i = 1, 36
         aa = aa + gi(i)/ki(i)/taui(li(i)) * ermi(ki(i))
      end do 
 
      do i = nlow, nhigh
        del = rh/rhoi(i) - 1d0
        tau = t/ttti(i) - 1d0
        abc = -alpi(i) * del** ki(i) - beti(i) * tau**2
        if (abc .gt. - 1d2) then
          aa = aa + gi(i) * del** li(i) * dexp(abc)
        else
          aa = aa
        end if
      end do 
 
      call aideal (t/1d2,rt,aid)
 
      aa = aa + aid
 
      gid = (aid  * amh2o * 1d-1) + rref * t
      gh2o = (aa + p/rh) * amh2o * 1d-1
      fh2o = (gh2o - gid)/rref/t
 
c                           to correct to 1 bar 298 gf +
c                           sliding scale in t ideal gas
c                           gref should be 182051 j / mol
c
      vh2o = amh2o/rh
 
      end

c----------------------------------------------------------------
      subroutine psat2(t, ps)

      implicit none
 
      double precision t, ps, a(8), w, wsq, v, ff

      integer i
 
      save a
 
      data a /-7.8889166d0, 2.5514255d0, -6.716169d0, 33.239495d0,
     1     -105.38479d0, 174.35319d0, -148.39348d0, 48.631602d0/
 
      if (t .le. 314.00d0) then
        ps = dexp(6.3573118d0 - 8858.843d0/t + 607.56335d0/(t**0.6d0))
      else
         v = t/647.25d0 
         w = dabs(1d0 - v)
         wsq = dsqrt(w)
         ff = 0d0 
         do i = 1, 8
            ff = ff + a(i) * w
            w = w * wsq
         end do 
         ps = 220.93d0 * dexp(ff/v)
      end if
 
      end
c----------------------------------------------------------------
      subroutine aideal (tr,rt,aid)
 
c subroutine to compute the helmoltz free energy of ideal steam.
 
      implicit none

      integer i
 
      double precision ci(18),tr,rt,aid,w
 
      save ci
 
      data ci /.19730271018d2, .209662681977d2, -.483429455355d0,
     1         .605743189245d1, 22.56023885d0, -9.87532442d0,
     2         -.43135538513d1, .458155781d0, -.47754901883d-1,
     3         .41238460633d-2, -.27929052852d-3, .14481695261d-4,
     4         -.56473658748d-6, .16200446d-7, -.3303822796d-9,
     5         .451916067368d-11,-.370734122708d-13,.137546068238d-15/
 
      w = tr** (-3)
 
      aid = 1d0 + (ci(1)/tr + ci(2)) * dlog(tr)
 
      do i = 3, 18
         aid = aid + ci(i) * w
         w = w * tr
      end do 
 
      aid = -rt * aid
 
      end
 
      subroutine trkmrk
c---------------------------------------------------------------------
c  trkmrk calculates the log of water and co2 fugacities using the haar
c  equation of state for pure water and the hsmrk for co2 and
c  the mrk for activities of h2o and co2 in mixtures
c-----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer ins(nsp)

      double precision fh2o,fco2,p,t,xc,vv,xmc,fmh2o,fmco2,ah2o,aco2,
     *                 tfh2o

      common / cst11 /fh2o, fco2/ cst5  /p,t,xc,vv(6)

      data ins/ 1, 2, 9*0/
 
      if (xc.le.0d0) then
c                                 for pure h2o:
         xc = 0d0
         call haar
         goto 99
 
      else if (xc.ge.1d0) then
c                                 for pure co2:
         call hprk
         goto 99
 
      end if
c                                 mixed volatiles
 
c                                 call mrk to get ln fugacities of
c                                 h2o and co2 in binary mixtures,
c                                 save as fmh2o and fmco2:
      xmc = xc
      call mrk
      fmh2o=fh2o
      fmco2=fco2
c                                 now get activities fugacities:
      call mrkpur (ins, 2)
      ah2o = fmh2o - fh2o
      aco2 = fmco2 - fco2
c                                 calculate pure water fugacity
      call haar
      tfh2o = fh2o + ah2o
c                                 calculate pure CO2 fugacity
      xc = 1d0
      call hprk
      fco2 = fco2 + aco2
      fh2o = tfh2o

      xc = xmc
 
99    end

      subroutine delany
c---------------------------------------------------------------------
c  delany calculates ln(fh2o) at P>10 KB using the delaney and
c  helgeson fit (AJS ca 81?), routine by S. Poli
c-----------------------------------------------------------------------
      implicit none

      double precision p0,b(5,5),c(5,5),gh2o(2),tc

      integer j,l

      double precision p,tk,xc,u1,u2,tr,pr,r,ps
      common / cst5 /p,tk,xc,u1,u2,tr,pr,r,ps

      double precision fh2o,fco2
      common/ cst11 /fh2o,fco2

      save p0, b, c

c     data for delany & helgeson 1974 eos for h2o above 10 kbar

      data b/-5.6130073d0,-1.5285559, -2.6092451d0, 1.7140501d0,
     *  -6.0126987d0,3.8101798d0,1.3752390d0,3.5988857d0,-1.6860893d0,
     *  0d0,-2.1167697d0,-1.5586868d0,-2.7916588d0,0d0,0d0,2.0266445d0,
     *  6.6329577d0, 0d0, 0d0, 0d0,-8.3225572d0,0d0, 0d0, 0d0, 0d0/
c
      data c/4d0,1d0,-2d0,-5d0,-9d0,-1d0,-4d0,-8d0,-11d0,0d0,-6d0,-9d0,
     *    -14d0,0d0,0d0,-11d0,-15d0,0d0,0d0,0d0,-17d0,0d0,0d0,0d0,0d0/
 
      if (p.le.1d4) then
         call hsmrk
         goto 99
      end if 

      p0 = p
      p = 1d4
      call hsmrk
      p = p0
      p0 = 1d4

      tc = tk - 273.15d0

      gh2o(1) = 0d0
      gh2o(2) = 0d0

      do j = 1, 5
         do l = 1, 6 - j 
           gh2o(1) = gh2o(1)+(b(j,l)*10**c(j,l))*(tc**(j-1))*(p**(l-1))
           gh2o(2) = gh2o(2)+(b(j,l)*10**c(j,l))*(tc**(j-1))*(p0**(l-1))
         end do 
      end do 

      fh2o = ((gh2o(1)-gh2o(2))/(1.9872d0*tk)) + fh2o

99    end 


      subroutine dhhsrk
c---------------------------------------------------------------------
c  dhhsrk calculates the log of water and co2 fugacities using the haar
c  equation of state for pure water and the hsmrk for co2 and
c  the mrk for activities of h2o and co2 in mixtures
c-----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer ins(nsp)

      double precision fh2o,fco2,p,t,xc,vv,xmc,fmh2o,fmco2,ah2o,aco2,
     *                 tfh2o

      common / cst11 /fh2o, fco2/ cst5  /p,t,xc,vv(6)

      data ins/ 1, 2, 9*0/
 
      if (xc.le.0d0) then
c                                 for pure h2o:
         xc = 0d0
         call delany
         goto 99
 
      else if (xc.ge.1d0) then
c                                 for pure co2:
         call hsmrk
         goto 99
 
      end if
c                                 mixed volatiles
 
c                                 call mrk to get ln fugacity
c                                 of h2o and co2 in binary mixes,
c                                 save as fmh2o and fmco2:
      xmc = xc
      call mrk
      fmh2o=fh2o
      fmco2=fco2
c                                 now get activities fugacities:
      call mrkpur (ins, 2)
      ah2o = fmh2o - fh2o
      aco2 = fmco2 - fco2
c                                 calculate pure water fugacity
      call delany
      tfh2o = fh2o + ah2o
c                                 calculate pure CO2 fugacity
      xc = 1d0
      call hsmrk
      fco2 = fco2 + aco2
      fh2o = tfh2o

      xc = xmc
 
99    end

      subroutine dhcork
c---------------------------------------------------------------------
c  dhhsrk calculates the log of water and co2 fugacities using the haar
c  equation of state for pure water and the cork for co2 and
c  the mrk for activities of h2o and co2 in mixtures
c-----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer ins(nsp)

      double precision fh2o,fco2,p,t,xc,vv,xmc,fmh2o,fmco2,ah2o,aco2,
     *                 tfh2o

      common / cst11 /fh2o, fco2/ cst5 /p,t,xc,vv(6)

      data ins/ 1, 2, 9*0/
 
      if (xc.le.0d0) then
c                                 for pure h2o:
         xc = 0d0
         call delany
         goto 99
 
      else if (xc.ge.1d0) then
c                                 for pure co2:
         call hprk
         goto 99
 
      end if
c                                 mixed volatiles
 
c                                 call mrk to get ln fugacity
c                                 of h2o and co2 in binary mixes,
c                                 save as fmh2o and fmco2:
      xmc = xc
      call mrk
      fmh2o=fh2o
      fmco2=fco2
c                                 now get activities fugacities:
      call mrkpur (ins, 2)
      ah2o = fmh2o - fh2o
      aco2 = fmco2 - fco2
c                                 calculate pure water fugacity
      call delany
      tfh2o = fh2o + ah2o
c                                 calculate pure CO2 fugacity
      xc = 1d0
      call hprk
      fco2 = fco2 + aco2
      fh2o = tfh2o

      xc = xmc
 
99    end
 
      subroutine lohork (fo2)
c----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      double precision fo2,kh2o,ghh2o

      integer ins(nsp), jns(3)

c           program to calculate fh2o, fo2 for H2-H2O
c           mixtures.

      double precision fh2o,fh2
      common/ cst11 /fh2o,fh2

      double precision p,t,xv,u1,u2,tr,pr,r,ps
      common/ cst5 /p,t,xv,u1,u2,tr,pr,r,ps

      double precision xh2o,xco2,xco,xch4,xh2,xh2s,xo2,xso2,xcos,xn2,
     *                 xnh3,gh2o,gco2,gco,gch4,gh2,gh2s,go2,gso2,gcos,
     *                 gn2,gnh3,v
      common / cstcoh /xh2o,xco2,xco,xch4,xh2,xh2s,xo2,xso2,xcos,xn2,
     *                 xnh3,gh2o,gco2,gco,gch4,gh2,gh2s,go2,gso2,gcos,
     *                 gn2,gnh3,v(nsp)

      double precision vol
      common/ cst26 /vol

      double precision gmh2o,gmco2,gmch4,vm
      common/ cstchx /gmh2o,gmco2,gmch4,vm(3)

      save ins

      data ins, jns / 1, 5, 9*0, 1, 2*0/

      xh2 = xv
      xh2o = 1d0 - xh2
c                                check if xo2 is <1, >0,
c                                reset if necessary.
      if (xh2.gt.0.9999999999d0) then
         xh2 = 0.9999999999d0
      else if (xh2.lt.1d-8) then
         xh2 = 1d-8
      end if 
c                                get pure species fugacities
      call hsmrkp (ins, 2, jns, 1)

      ghh2o = gh2o/gmh2o
c                                get mrk fugacities:
      call lomrk (ins, 2)
c                                evaluate lnk's
      kh2o = -7.028214449d0 + 30607.34044d0/t - 475034.4632d0/t/t
     *                      + 50879842.55d0/t/t/t                               
      gh2o = ghh2o * gh2o

      fh2o = dlog(gh2o*p*xh2o)

      fh2 = dlog(gh2*p*xh2)

      fo2 = 2d0 * (fh2o - fh2 - kh2o)

      vol = vol + xh2o * vm(1)
 
      end

      subroutine saxfei
c---------------------------------------------------------------------
c       subroutine to calculate compressibilities and fugacity coefs
c       according to saxena & fei (1987a, b, 1988) for species in the
c       c-o-h system
 
c       literature: saxena s.k. & fei y. (1987a):
c                   fluids at crustal pressures and temperatures. contr
c                   mineral. petrol., vol. 95, pp 370 - 375.
c
c                   saxena s.k. & fei y. (1987b):
c                   high pressure and hig temperature fluid fugacities.
c                   geochim. cosmochim,. acta, vol. 51, pp 783 - 791.
c
c                   saxena s.k. & fei y. (1988):
c                   the pressure-volume-temperature equation of hydrogen
c                   geochim. cosmochim. acta, vol. 52, pp 1195 - 1196.
c---------------------------------------------------------------------
c       written by peter ulmer, geophysical lab, ciw, june, 1988
c       modified for vertex/frendly by j. connolly, may, 1989.
c       never tested.
c---------------------------------------------------------------------
c          z = compressibility = pv/rt
c             species are: 1 = co2
c                          2 = co
c                          3 = ch4
c                          4 = o2
c                          5 = h2o
c                          6 = h2
c---------------------------------------------------------------------
      implicit none
 
      double precision tcr(6),pcr(6),fcoeff(6),a(3),b(2),c(3),d(2),
     *                 aw(4),bw(3),cw(4),dw(4),at(6),tr,
     *                 bt(6),ct(6),dt(6),pr1(6),pr2(6)
 
      double precision p,t,xco2,u1,u2,trr,prr,r,ps
      common/ cst5 /p,t,xco2,u1,u2,trr,prr,r,ps

      double precision f
      common/ cst11 /f(2)
 
      save tcr, pcr, a, b, c, d, aw, bw, cw, dw
 
      data tcr / 304.2d0, 133.15d0, 190.7d0, 154.8d0, 647.3d0, 33.1d0/
      data pcr / 73.9d0, 35d0, 46.4d0, 50.8d0, 221.3d0, 13d0/
 
      data a / 2.0614, -2.2351, -0.39411/
      data b / 5.5125d-2, 3.9344d-2/
      data c / -1.8935d-6, -1.1092d-5, -2.1892d-5/
      data d / 5.0527d-11, -6.3033d-21/
 
      data aw / 1.4937d0, -1.8626d0, 0.80003d0, -0.3941d0/
      data bw / 4.2410d-2, 2.4097d-2, -8.9634d-3/
      data cw / -9.016d-7, -6.1345d-5, 2.2380d-5, 5.2335d-7/
      data dw / -7.6707d-9, 4.1108d-8, -1.4798d-8, -6.3033d-21/
c---------------------------------------------------------------------
 
c       calculation of the a, b, c, d terms for the different species
 
c       calculation for co2, co, ch4, and o2  ** change to index i
c       the indices on lhs of equalities.
 
        if (p.lt.5d3) then
           write (*,*) 'this version of saxfei is invalid at ',
     *                 'pressures less than 5000 bars.'
        end if
 
           tr = t/tcr(1)
           at(1) = a(1) + a(2)*tr**(-2) + a(3)*dlog(tr)
           bt(1) = b(1)/tr + b(2)*tr**(-2)
           ct(1) = c(1)/tr + c(2)*tr**(-2) + c(3)*tr**(-3)
           dt(1) = d(1)/tr + d(2)*tr**3

c---------------------------------------------------------------------
c       calculation of a, b, c, d for h2o
 
        tr = t/tcr(5)
        at(5) = aw(1) + aw(2)*tr**(-2) + aw(3)*tr**(-3) + aw(4)*dlog(tr)
        bt(5) = bw(1)/tr + bw(2)*tr**(-2) + bw(3)*tr**(-3)
        ct(5) = cw(1)/tr + cw(2)*tr**(-2) + cw(3)*tr**(-3) +
     .          cw(4)*dlog(tr)
        dt(5) = dw(1)/tr + dw(2)*tr**(-2) + dw(3)*tr**(-3) +
     .          dw(4)*tr**3
 
c       calculation of the fugacity coefficients according to
c       saxena & fei (1987b) for co2
 
        pr1(1) = p/pcr(1)
        pr2(1) = 5d3/pcr(1)
        fcoeff(1) = r*t * (at(1)*dlog(pr1(1)/pr2(1)) +
     .              bt(1)*(pr1(1)-pr2(1)) +
     .    ct(1)*(pr1(1)**2 - pr2(1)**2)/2d0 + dt(1)*
     .    (pr1(1)**3 - pr2(1)**3)/3) - r*t*dlog(p)
     .    + 1d3*(-40.468d0 + 0.06702d0*t + 8.3481d0*dlog(t))
        fcoeff(1) = fcoeff(1)/(r*t)
        fcoeff(1) = dexp(fcoeff(1))
 
      if (xco2.ne.0d0) then
         f(2) = dlog(xco2 * fcoeff(1) * p)
      else
         f(2) = 0d0
      end if
 
c      calculation of the fugacity coefficients according to
c      saxena & fei (1987b) for h2o
 
      pr1(5) = p/pcr(5)
      pr2(5) = 5d3/pcr(5)
      fcoeff(5) = r*t * (at(5)*log(pr1(5)/pr2(5)) +
     .              bt(5)*(pr1(5)-pr2(5)) +
     .    ct(5)*(pr1(5)**2 - pr2(5)**2)/2d0 + dt(5)*
     .    (pr1(5)**3 - pr2(5)**3)/3d0) - r*t*dlog(p)
     .    + 1d3*(-130.517d0 + 0.06497d0*t + 19.4831d0*dlog(t))
      fcoeff(5) = fcoeff(5)/(r*t)
      fcoeff(5) = dexp(fcoeff(5))
 
      if (xco2.ne.1d0) then
         f(1) = dlog( (1d0-xco2) * fcoeff(5) * p)
      else
         f(1) = 0d0
      end if
 
      end

      subroutine browoo
c---------------------------------------------------------------------
c  browoo calculates the log of water and co2 fugacities using the
c  Brodholt & Wood, 1993 equation of state for pure water and
c  the hsmrk for co2 and the mrk for activities of h2o and co2 in mixtures
c  this and ancillary subroutines were written by 
c  Stefano Poli, Milan, 1996. modified, but untested, July 96, JADC.
c-----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer ins(nsp)

      double precision fh2o,fco2,p,t,xc,vv,xmc,fmh2o,fmco2,ah2o,aco2,
     *                 tfh2o

      common / cst11 /fh2o, fco2/ cst5  /p,t,xc,vv(6)

      save ins

      data ins/ 1, 2, 9*0/
c-----------------------------------------------------------------------
      if (xc.le.0d0) then
c                                 for pure h2o:
         xc = 0d0
         call browop
         goto 99

      else if (xc.ge.1d0) then
c                                 for pure co2:
         call hsmrk
         goto 99

      end if
c                                 mixed volatiles

c                                 call mrk to get ln fugacity
c                                 of h2o and co2 in binary mixes,
c                                 save as fmh2o and fmco2:
      xmc = xc
      call mrk
      fmh2o=fh2o
      fmco2=fco2
c                                 now get activities fugacities:
      call mrkpur (ins, 2)

      ah2o = fmh2o - fh2o
      aco2 = fmco2 - fco2
c                                 calculate pure water fugacity
      call browop 

      tfh2o = fh2o + ah2o
c                                 calculate pure CO2 fugacity
      xc = 1d0
      call hsmrk
      fco2 = fco2 + aco2
      fh2o = tfh2o

      xc = xmc

99    end

      subroutine browop           
c-----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      double precision rr,a1,a2,a3,a4,c1,c2,c3,c4,b1,b2,p0,f0,vbw,t2,a,
     *                 rt,t12,t15,t25,b,e0,e1,e3,v1,pdv,cor

      integer ins(nsp),jns(3),i

      double precision x,g,v
      common/ cstcoh /x(nsp),g(nsp),v(nsp)

      double precision fh2o,fco2
      common/ cst11 /fh2o,fco2

      double precision p,t,xc,u1,u2,tr,pr,r,ps
      common/ cst5 /p,t,xc,u1,u2,tr,pr,r,ps

      save rr,a1,a2,a3,a4,c1,c2,c3,c4,b1,b2,ins,jns

      data rr,a1,a2,a3,a4,c1,c2,c3,c4,b1,b2/83.144126d0,-582468d0,
     *     -3038.79d0,-9.24574d-3,3.02674d9,36490.5d0,-1.02451d7,
     *     -1.79681d8,2.18437d9,-3.90463d-2,-0.991078d0/

      data ins,jns/nsp*1,1,1,1/
c-----------------------------------------------------------------------
c                                at p < 10000 kerrick      
      if (p.lt.1d4) then
         call hsmrk
         goto 9999
      end if
c                                get portion of fh2o below 10 kbar from hsmrk
      p0 = p
      p = 1d4
      call hsmrkp (ins, 1, jns, 1)
      f0 = fh2o
c                                brodholdt & wood part:
c                                call mrk to get initial guess for volume 
      vbw = v(1)

      t2 = t*t
      a = a1 + t*(a2 + a3*t) + a4/t2
      rt = rr*t
      t12 = dsqrt (t)
      t15 = t*t12
      t25 = t2*t12

      do i = 1, 100
         b = b1 + b2*vbw
         e0 = vbw - b
         e1 = b + vbw
         e3 = 1d0 + b2

         cor = (rt/e0+(c1-a/t12/e1+(c2+(c3+c4/vbw)/vbw)/vbw)/vbw - p) 
     *         / 
     *         ((((-4d0*c4/vbw-3d0*c3)/vbw-2d0*c2)/vbw-c1)/vbw**2
     *         -rt*e3/e0/e0 
     *         +(e3/e1+1d0/vbw)/vbw/e1*(a4/t25+a2*t12+a1/t12+a3*t15))

         vbw = vbw - cor

         if (dabs(cor).lt.1d-3) goto 99

      end do 
c                                 compute integral vdp by parts to get fugacity
c                                 vdP = V2*P2 - V1*P1 - (integral of PdV)
c                                 do integral of PdV for V1 first.
99    b = b1 + b2*vbw

      pdv = rt/(1d0-b2)*dlog(vbw-b) + a/t12/b1*dlog((vbw+b)/vbw)
     *    + c1*dlog(vbw) - (c2 + (c3/2d0 + c4/vbw/3d0)/vbw)/vbw
c                                 v1 is vbw at 10 kb
      v1 = vbw
c                                 v at p = p bar
      p = p0
      call mrkpur (ins, 1)
      vbw = v(1)

      do 110  i = 1, 100

         b = b1 + b2*vbw
         e0 = vbw - b
         e1 = b + vbw
         e3 = 1d0 + b2

         cor = (rt/e0+(c1-a/t12/e1+(c2+(c3+c4/vbw)/vbw)/vbw)/vbw - p) 
     *         / 
     *         ((((-4d0*c4/vbw-3d0*c3)/vbw-2d0*c2)/vbw-c1)/vbw**2
     *         -rt*e3/e0/e0 
     *         +(e3/e1+1d0/vbw)/vbw/e1*(a4/t25+a2*t12+a1/t12+a3*t15))

         vbw = vbw - cor

110      if (dabs(cor).lt.1d-3) goto 999

999   b = b1 + b2*vbw

      fh2o =  (vbw*p - v1*1d4 - a/t12/b1*dlog((vbw+b)/vbw)
     *    - c1*dlog(vbw) + (c2 + (c3/2d0 + c4/vbw/3d0)/vbw)/vbw
     *    + pdv ) / rt + f0 - dlog(vbw-b)/(1d0-b2)

9999  end

      subroutine hcrk
c---------------------------------------------------------------------
c  hcrk calculates the log of water and co2 fugacities using the
c  Halbach Chatterjee 82 equation of state for pure water and
c  the hsmrk for co2 and the mrk for activities of h2o and co2 in 
c  mixtures. this and ancillary subroutines were written by 
c  Stefano Poli, Milan, 1996. modified, but untested, July 96, JADC.
c-----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer ins(nsp)

      double precision fh2o,fco2,p,t,xc,vv,xmc,fmh2o,fmco2,ah2o,aco2,
     *                 tfh2o

      common / cst11 /fh2o, fco2/ cst5  /p,t,xc,vv(6)

      save ins

      data ins/ 1, 2, 9*0/
c-----------------------------------------------------------------------
      if (xc.le.0d0) then
c                                 for pure h2o:
         xc = 0d0
         call hcrkp
         goto 99

      else if (xc.ge.1d0) then
c                                 for pure co2:
         call hsmrk
         goto 99

      end if
c                                 mixed volatiles:
c                                 call mrk to get ln fugacity
c                                 of h2o and co2 in binary mixes,
c                                 save as fmh2o and fmco2:
      xmc = xc
      call mrk
      fmh2o=fh2o
      fmco2=fco2
c                                 now get activities fugacities:
      call mrkpur (ins, 2)

      ah2o = fmh2o - fh2o
      aco2 = fmco2 - fco2
c                                 calculate pure water fugacity
      call hcrkp

      tfh2o = fh2o + ah2o
c                                 calculate pure CO2 fugacity
      xc = 1d0
      call hsmrk
      fco2 = fco2 + aco2
      fh2o = tfh2o

      xc = xmc

99    end

      subroutine hcrkp 
c----------------------------------------------------------------------
      implicit none

      double precision rcm,pdisc,p0,a,b,pincr,volhc,vdp,aincr,c,d,pres

      integer nincr,i

      double precision fh2o,fco2
      common/ cst11 /fh2o,fco2

      double precision p,t,xc,u1,u2,tr,pr,rr,ps
      common/ cst5 /p,t,xc,u1,u2,tr,pr,rr,ps

      save rcm, pdisc, nincr

      data rcm, pdisc, nincr/ 83.144126d0, 1d3, 1000/
c----------------------------------------------------------------------
c                        at p < pdisc  kerrick
      if (p.lt.pdisc) then
         call hsmrk
         goto 9999
      end if
c                        get portion of fh2o below 10 kbar from MRK 
      p0 = p
      p = pdisc
      call hsmrk
      p = p0
c                        now Halbach & Chatterjee part
      a = 2d0
      b = 4d0
c                        Newton-Raphson numerical integration
      pincr = (p - pdisc) / nincr
      vdp =  pincr * (volhc(pdisc,t) - volhc(p,t))/3d0 
      aincr = pincr 

      do i = 1, nincr - 1
         d = b
         c = a
         b = c
         a = d
         pres = pdisc + aincr
         vdp = vdp + a*pincr*volhc(pres,t)/3d0
         aincr = aincr + pincr
      end do 

         fh2o =  vdp/rcm/t + fh2o

9999  end

      function volhc (p,t)
c--------------------------------------------------------------
      implicit none

      integer iroots

      double precision ev(3),rcm,a1,a2,a3,b1,b2,b3,b4,b5,b6,p,t,
     *                 volhc,t12,ahc,bhc,c1,c2,c3,vmin,vmax

      save rcm,a1,a2,a3,b1,b2,b3,b4,b5,b6

      data rcm,a1,a2,a3,b1,b2,b3,b4,b5,b6/83.144126d0,1.616d8,-4.989d4,
     *     -7.358d9,3.4505d-4,3.898d-9,-2.7756d-15,6.3944d-2,2.3776d-5,
     *     4.5717d-10/
c--------------------------------------------------------------
      t12 = dsqrt (t)

      ahc = (a1 + a2*t + a3/t)/ p / t12

      bhc = (1d0 + p*(b1 + p*(b2 + b3*p))) 
     *      / (b4 + p*(b5 + b6*p))

      c1 = -rcm*t / p   
      c2 = ahc - rcm*bhc/p - bhc**2
      c3 = -ahc*bhc

      call roots3 (c1,c2,c3,ev,vmin,vmax,iroots)

      if (iroots.eq.3) then
         volhc = vmax
      else
         volhc = ev(1)
      end if

      end

      subroutine cohngr (fo2)
c----------------------------------------------------------------------
c subroutine to compute speciation and fugacites in graphite
c saturated COHN fluid at an oxygen fugacity buffer specified 
c by ibuf in routine fo2buf.

c fo2  - log of the oxygen fugacity (from subroutine fo2buf)
c elag - the natural log of graphite activity
c p    - pressure, bar
c t    - temperature, K
c gz   - molar N/C ratio

c derivation and data sources in maple work sheet num_cohn.mws

c                                 JADC 2/04

c fo2 changed to ln(fo2), JADC 11/17/10
c----------------------------------------------------------------------
      implicit none 

      include 'perplex_parameters.h'

      integer ins(nsp), isp, nit, i

      double precision fo2,tol,t2,t3,x2,x3,d6,d36,d67,df,xt,d678x,x,tx,
     *                 rad,eq9,dxnh3,deq9,dxh2o,sign,c1,c2,c3,c4,c5

      double precision xh2o,xco2,xco,xch4,xh2,xh2s,xo2,xso2,xcos,xn2,
     *                 xnh3,gh2o,gco2,gco,gch4,gh2,gh2s,go2,gso2,gcos,
     *                 gn2,gnh3,v
      common / cstcoh /xh2o,xco2,xco,xch4,xh2,xh2s,xo2,xso2,xcos,xn2,
     *                 xnh3,gh2o,gco2,gco,gch4,gh2,gh2s,go2,gso2,gcos,
     *                 gn2,gnh3,v(nsp)

      double precision fh2o,fco2
      common/ cst11 /fh2o,fco2

      double precision p,t,xc,u1,u2,tr,pr,r,ps
      common/ cst5 /p,t,xc,u1,u2,tr,pr,r,ps

      integer ibuf,hu,hv,hw,hx   
      double precision dlnfo2,elag,gz,gy,gx
      common/ cst100 /dlnfo2,elag,gz,gy,gx,ibuf,hu,hv,hw,hx

      save tol, ins

      data tol, ins/1d-6, 1,2,3,4,5,10,11,4*0/

      t2 = t * t
      t3 = t2 * t
      x = gz
      isp = 7 
 
      nit = 0

      call fo2buf (fo2)
c                                evaluate lnk's and correct for pressure, carbon 
c                                activity and oxygen fugacity
      c1 = p*dexp(-0.1386241656D2+(0.1230903706D5+0.6372383931D-1*p)/t
     *            -0.8793147005D6/t2+0.7754138439D8/t3+elag)
      c2 = dexp(0.4078341613D-1+(0.47681676177D5+0.6372383931D-1*p)/t
     *         -0.1346621904D6/t2+0.1701579431D8/t3 + elag + fo2)/p
      c3 = dexp(0.1032730663D2+(0.140627396777D5+0.6372383931D-1*p)/t
     *         -0.3712371571D6/t2+0.5351536595D8/t3 + elag + fo2/2d0)/p
      c4 = dexp(-0.7028214449D1+0.3060734044D5/t-0.4750344632D6/t2+
     *          0.5087984255D8/t3 + fo2/2d0)
      c5 = dexp(0.2527543051D8/t3-0.4017985659D6/t2+0.7323735697D4/t
     *         -0.1439146998D2)*p**2
c                                get pure species fugacities
      call mrkpur (ins, isp)
c                                check for graphite saturation:
      xco2 = c2/gco2
      xco = c3/gco

      if (xco2+xco.ge.1d0) then 
 
         write (*,1000) fo2,p,t

         if (hu.eq.0) then 

            fco2 = dlog(gco2*p*xco2)

         else
c                                 return f(h2) in fh2o, f(O2) in fco2
c                                 for carbon projection. 
            fco2 = fo2

         end if 

         xco2 = 1d0
         xco = 0d0
         xh2o = 0d0
         xnh3 = 0d0
         xn2 = 0d0
         xch4 = 0d0
         xh2 = 0d0 
         return 

      end if 
c                                since ynh3 is quadratic in yh2o we
c                                have two roots to choose from, differentiated
c                                by the sign on the radical "rad", the 
c                                first root seems to be relevant for 
c                                high f(O2).
      sign = -1d0 

      do i = 1, 2 
c                                guess xh2o, this might not be a bad guess for
c                                oxidixed fluids, but for reduced?
         xh2o = 1d0 - xco - xco2 
         dxh2o = 1d0 
         nit = 0 

         do 
c                                 the problem in this loop is that
c                                 the equation has 4 roots, when we
c                                 have the right root for xnh3 then
c                                 there is only one real root between
c                                 zero and one, if we have the wrong
c                                 root for xnh3 we have two real roots
c                                 between zero and one, but these give
c                                 negative values for nh3, and then there
c                                 are the imaginary roots that i don't 
c                                 even want to think of.
            x2    = xh2o*xh2o 
            x3    = xh2o * x2  

            d6    = c4*gh2/gh2o
            d36   = c1/gch4/c4**2*gh2o**2
            d67   = c4**3/gh2o**3/c5*gnh3**2/gn2
            xt    = xco2 + xco
            df    = (1d0+d6)/d6
            d678x = d67*8d0*x 
            rad   = xh2o*(x3+d678x*(d36*x2+xt))
            if (rad.lt.0d0) then 
               sign = -sign
               exit
            end if 
c                                quadratic root for nh3:
            rad   = sign*dsqrt(rad)
            xnh3  = (-x2+rad)*xh2o/4d0/d67
c                                a negative value for xnh3 is ominous
c                                but does it really mean the end of this
c                                root?  
            if (xnh3.lt.0d0) then 
               sign = -sign
               exit
            end if 
       
            eq9   = 1d0-(d36*xh2o+df)*xh2o-xt
     *                   -xnh3*(1d0+xnh3*d67/x3)
            dxnh3 = ((-3d0*xh2o+1d0/rad*
     *                ((4d0*xh2o+3d0*d678x*d36)*x2
     *                +d678x*xt)/2d0)*xh2o+rad)/d67/4d0
            deq9  = -2d0*d36*xh2o-df-dxnh3
     *              +(3d0*xnh3/xh2o-2d0*dxnh3)*d67*xnh3/x3

            dxh2o = eq9/deq9

            xco2  = c2/gco2
            xco   = c3/gco
            xh2  = xh2o/d6
            xch4 = d36*x2
            xn2  = xnh3**2*d67/x3
            tx = xt + xh2 + xh2o + xch4 + xnh3 + xn2 - 1d0

            nit = nit + 1

            if (nit.gt.100) then
c                                 not converging to much
c                                 of anything, try other root
               write (*,1000) t,p

               sign = -sign

               exit

            else if (dabs(dxh2o).lt.tol.and.dabs(tx).lt.tol) then 
c                                 seems to have converged
               if (xh2o.gt.1d0.or.xh2o.lt.0d0.or.
     *             xnh3.gt.1d0.or.xnh3.lt.0d0) then
c                                 but a bad root
                  sign = -sign
                  exit
               else
c                                 everything seems ok
                  goto 90
               end if 
            end if 
c                                 get new gamma's
            call mrkmix (ins, isp)
            xh2o = xh2o - dxh2o

         end do 
      end do 
c                                 if we get here, no good solution
      write (*,*) 'fd'
      stop

90    if (hu.eq.0) then
 
         fh2o = dlog(gh2o*p*xh2o)
         fco2 = dlog(gco2*p*xco2)

      else
c                                 return f(h2) in fh2o, f(O2) in fco2
c                                 for carbon projection. 
         fh2o = dlog(gh2*p*xh2)
         fco2 = fo2

      end if 

1000  format (/,'**warning ver222** routine COHNGR, specified lnfO2 (',
     *        g12.6,')',/,'is inconsistent with graphite saturation',
     *       ' at P(bar)=',g12.6,' T(K)=',g12.6,/,'XCO2=1 assumed.',/) 
      end

      subroutine hcneos (gex,x3,x1,x2)
c----------------------------------------------------------------------
c subroutine to compute excess energy (gex) of a H2O-CO2-NaCl
c mixture. x3 = mol fraction NaCl; x2 = mol fraction CO2; 
c x1 = mol fraction H2O. This routine is for the true ternary
c fluid. see routine waddah for h2o-co2 with constant mole
c or weight fraction of salt.
c----------------------------------------------------------------------
      implicit none 

      double precision pbar,t,xco2,u1,u2,tr,pr,r,ps,alpha,
     *                 w2,w3,w4,w5,a1,gex,x1,x2,x3,fh2o,fco2,
     *                 p,v1,v2,rt,rid,sid,tid,uid,vid

      common/ cst5  /pbar,t,xco2,u1,u2,tr,pr,r,ps

c                                 supposedly these routines 
c                                 return volume in J/bar
      call crkco2 (pbar,t,v2,fco2) 
      call crkh2o (pbar,t,v1,fh2o)
c                                 leonya needs cm3/mol
      v2 = v2*1d1
      v1 = v1*1d1
      rt = r*t

      p = pbar/1d3

      w2 = 906.12d0 - 57.277d0 * p
      w3 = 101788d0 - 2916d0 * p
      w4 = 38007d0  + 2445d0 * p
      w5 = -37371d0 + 916d0 * p

      alpha = dexp(4.04d0 - 0.1611d0*v1) - 134.2d0 * p/t

      if (alpha.lt.0d0) then 
         alpha = 0d0
      else if (alpha.gt.1d0) then 
         alpha = 1d0
      end if 
         
      a1 = 1d0 + alpha

      sid = 0d0
      tid = sid
      uid = sid
      vid = sid

      if (x1.gt.1d-8) sid = x1*dlog(x1)
      if (x2.gt.1d-8) sid = sid + x2*dlog(x2)  
      if (x3.gt.1d-8) then
         sid = sid + x3*dlog(x3)
         rid = x3/(x1+x3)
         vid = x3*(    a1 * dlog(a1/(1d0+alpha*rid))
     *            + alpha * dlog(rid))
     *         -x1*dlog(1d0+alpha*rid)
      end if 

      if (x2+x3.gt.1d-8) uid = (x2*w3+x3*w4)/(x2+x3)
      if (x2+x1.gt.1d-8) tid = 202046.4d0*(x1+x2)/(v1*x1+v2*x2)

      gex = rt*(sid+vid)+x2*(x1*tid+x3*(uid+x1*w5))+x1*x3*w2

      end 

      subroutine waddah 
c----------------------------------------------------------------------
c subroutine to compute fh2o and fco2 for a H2O-CO2-NaCl mixture. 
c using cork (holland and powell '98) for pure h2o and co2 properties
c and leonid aranovich's van-laar model for activities.

c  x3 = mol fraction NaCl
c  x2 = mol fraction CO2 
c  x1 = mol fraction H2O 

c  elag - the salt fraction
c  ibuf - if 1, salt fraction is mass fraction
c         else if 2, salt fraction is mole fraction

c  xco2 - nco2/(nco2+nh2o)
c  fco2 - natural log of co2 fugacity
c  fh2o - natural log of h2o fugacity
c                                 JADC, 4/27/04.
c----------------------------------------------------------------------
      implicit none 

      double precision pbar,t,xco2,u1,u2,tr,pr,r,ps,alpha,w1,
     *                 w2,w3,w4,w5,x1,x2,x3,t0,t1,p,v1,v2,rt,xt,
     *                 wh2o,wco2,wnacl,nh2o,nco2,nnacl,ntot

      common/ cst5  /pbar,t,xco2,u1,u2,tr,pr,r,ps

      double precision fh2o,fco2
      common/ cst11 /fh2o,fco2

      integer ibuf,hu,hv,hw,hx   
      double precision dlnfo2,elag,gz,gy,gx
      common/ cst100 /dlnfo2,elag,gz,gy,gx,ibuf,hu,hv,hw,hx
c                                 molar weights
      save wh2o,wco2,wnacl
      data wh2o,wco2,wnacl/18.016,44.01,58.446/
c                                 convert xco2 and elag to
c                                 mole appropriate mole fractions:
      if (ibuf.eq.1) then
c                                 from weight salt:
         if (xco2.eq.1d0) then 
            nh2o = 0d0
            nco2 = 1d0 
            nnacl = -elag*wco2/wnacl/(elag-1d0)
         else if (xco2.eq.0d0) then 
            nh2o = 1d0
            nco2 = 0d0 
            nnacl = -elag*wh2o/wnacl/(elag-1d0)
         else 
            nh2o = (elag-1d0)*(xco2-1d0)/(xco2*(wco2-wh2o)+wh2o)
            nco2 = xco2*nh2o/(1d0-xco2)
            nnacl = elag/wnacl
         end if 

         ntot = nh2o + nco2 + nnacl
         x1 = nh2o/ntot
         x2 = nco2/ntot
         x3 = 1d0 - x1 - x2

      else if (ibuf.eq.2) then 
c                                 from salt mole fraction:
         x3 = elag
         xt = 1d0 - x3
         x2 = xco2*xt
         x1 = 1d0 - x2 - x3

      else
c                                 program or input error?
         call error (999,t,ibuf,'WADDAH')
      end if
c                                 supposedly these routines 
c                                 return volume in J/bar
      call crkco2 (pbar,t,v2,fco2) 
      call crkh2o (pbar,t,v1,fh2o)
       
      if (x1.eq.1d0.or.x2.eq.1d0.or.x3.eq.1d0) return

c                                 leonya needs cm3/mol
      v2 = v2*1d1
      v1 = v1*1d1
      rt = r*t

      p = pbar/1d3

      w1 = 202046.4d0
      w2 = 906.12d0 - 57.277d0 * p
      w3 = 101788d0 - 2916d0 * p
      w4 = 38007d0  +  2445d0 * p
      w5 = -37371d0 + 916d0 * p

      alpha = dexp(4.04d0 - 0.1611d0*v1) - 134.2d0 * p/t
c                                 modified 6/6/05 to restict
c                                 alpha to physical values. JADC
      if (alpha.lt.0d0) then 
         alpha = 0d0
      else if (alpha.gt.1d0) then 
         alpha = 1d0
      end if 

      t0 = (v1*x1+v2*x2)**2
      t1 = x2 + x3
c                                 this is ln(fH2O)
      if (x1.ne.0d0) then 
         fh2o = fh2o + ( w2*x3*t1 - w5*x2*(x1-x2-x3)*x3
     *        - x2*x3*(w3*x2+w4*x3)/t1
     *        + w1*x2*(v1*x1**2*x3+v2*x2*(x1+x2+x1*x3))/t0)/rt
     *        + dlog(x1*(x1+x3)/(1d0+x3*alpha))
      else 
         fh2o = 0d0
      end if 
c                                 this is ln(aCO2)
      if (x2.ne.0d0) then 
         fco2 = fco2 + ( w5*x1*x3*(x1-x2+x3) - w2*x1*x3 
     *        + w1*x1*(v2*x2**2*x3+v1*x1*(x1+x2+x2*x3))/t0
     *        + x3/t1**2*(w4*x3*(-x2**2+x1*x3+x3**2)
     *        + w3*x2*(2d0*x3*t1+x1*(t1+x3))))/rt + dlog(x2)
      else 
         fco2 = 0d0
      end if 

      end 

      subroutine dimond (agph)
c-----------------------------------------------------------------------
c dimond tests if p-t conditions are in the diamond stability field
c if they are it computes the activity of graphite needed to represent
c diamond stability for C-O-H fluid speciation routines. 


c  elag - natural log of the activity of the stable C polymorph
c         requested by the user (usually 0).
        
c  agph - natural log of graphite activity, this is adjusted
c         to account for deviations imposed by the user via
c         the input variable elag.

c polynomial functions fit by S. Poli, 4/27/04
c                                 JADC, 4/27/04
c-----------------------------------------------------------------------
      implicit none 

      double precision ptrans,agph

      integer ibuf,hu,hv,hw,hx      
      double precision dlnfo2,elag,gz,gy,gx
      common/ cst100 /dlnfo2,elag,gz,gy,gx,ibuf,hu,hv,hw,hx

      double precision p,t,xco2,u1,u2,tr,pr,r,ps
      common/ cst5   /p,t,xco2,u1,u2,tr,pr,r,ps

c                                 get transition pressure
c                                 (should really use the G
c                                 function for consistency):

      ptrans = 5284.165053d0 + (33.21515773d0 - .002106330992d0*t)*t

      if (p.lt.ptrans) then 
         agph = elag
      else 
c                                 compute corrected graphite activity
         agph = elag + 0.008423508384179629d0 
     *        + (4.693008650307614d-11 * p - 3.850380793502567d-5)*p
     *        + (1.4126916053951515d-3 + 1.393226795939807d-8*p 
     *        - 5.887505938975768d-7 * t)*t

      end if 

      end 

      subroutine pseos (v,f,iam)
c-----------------------------------------------------------------------
c compute ln(f[iam], bar) and volume (cm3/mol) for pure fluids from Pitzer 
c & Sterner JCP '94. 

c      p   - pressure (bars)
c      t   - temp (K)
c      iam - 1 for H2O, 2 for CO2.

c                                 J.A.D. Connolly, Nov 26, 2010.
c-----------------------------------------------------------------------
      implicit none

      double precision r,prt,rt,f,c1,c2,c3,c4,c5,c6,c7,c8,c9,c0,v,a1,
     *                 a2,a3,c12,c20,c33,c34,c36,c44,c46,c55,c56,c66,
     *                 c64,c53,c42,e1,e2,dv,t2

      integer it,iam

      double precision p,t,xco2,u1,u2,tr,pr,rc,ps
      common/ cst5  /p,t,xco2,u1,u2,tr,pr,rc,ps

      save r
      data r/83.14/
c----------------------------------------------------------------------
      t2 = t*t
c                                 temperature dependent coefficients
      if (iam.eq.1) then 
c                                 h2o 
         c1 = 0.24657688d6/t + 0.51359951d2
         c2 = 0.58638965/t -0.28646939d-2 + 0.31375577d-4*t
         c3 = -0.62783840d1/t + 0.14791599d-1 
     *                      + t*(0.35779579d-3 + 0.15432925d-7*t)
         c4 = -0.42719875 - 0.16325155d-4*t
         c5 = 0.56654978d4/t - 0.16580167d2 + 0.76560762d-1*t
         c6 = 0.10917883
         c7 = ((0.38878656d13/t**2 - 0.13494878d9)/t + 0.30916564d6)/t 
     *                     + 0.75591105d1
         c8 = -0.65537898d5/t + 0.18810675d3
         c9 = ((-0.14182435d14/t**2 + 0.18165390e9)/t - 0.19769068e6)/t 
     *                     - 0.23530318e2
         c0 = 0.92093375d5/t + 0.12246777d3
c                                 CORK volume guess and backup fugacity
         call crkh2o (p,t,v,f) 

      else if (iam.eq.2) then 
c                                 co2 
         c1 = 0.18261340d7/t + 0.79224365d2
         c2 = 0.66560660d-4 + 0.57152798d-5*t + 0.30222363d-9*t2
         c3 = 0.59957845d-2 + 0.71669631d-4*t + 0.62416103d-8*t2
         c4 = -0.13270279d1/t - 0.15210731d0 
     *                         + 0.53654244d-3*t - 0.71115142d-7*t2
         c5 = 0.12456776/t + 0.49045367d1 
     *                         + 0.98220560d-2*t + 0.55962121d-5*t2
         c6 = 0.75522299d0
         c7 = ((-0.39344644d12/t2 +  0.90918237d8)/t + 0.42776716d6)/t 
     *         - 0.22347856d2
         c8 = 0.40282608d3/t + 0.11971627d3
         c9 = (0.22995650d8/t -0.78971817d5)/t -0.63376456d2
         c0 = 0.95029765d5/t + 0.18038071d2
c                                 CORK volume guess and backup fugacity
         call crkco2 (p,t,v,f) 

      else 

         call error (11,xco2,iam,'species (routine pseos)')

      end if 
c                                CORK volumes are J/bar/mol, convert to
c                                cm3/mol for PSEOS
      v = 10d0*v

      c12 = 12d0*c5
      c20 = 20d0*c6
      c46 = 6d0*c4
      c53 = 3d0*c5
      c42 = 2d0*c4
      c64 = 4d0*c6
      c33 = 2d0*c3*c3
      c34 = 8d0*c3*c4
      c36 = -16d0*c3*c6 - c12*c42
      c44 = 8d0*c4*c4 + c3*c12
      c55 = -32d0*c4*c6 - 18d0*c5*c5
      c56 = -c12*c64
      c66 = 32d0*c6*c6

      rt = r*t
      prt = p/rt
      it = 0
c                                 iteration loop for volume
      do

         a1 = c2 + (c3 + (c4 + (c5 + c6/v)/v)/v)/v
         a2 = a1*a1
         a3 = a2*a1
         e1 = c7*dexp(-c8/v)
         e2 = c9*dexp(-c0/v)
c                                 refine guess by dp/(dp/dv)
         dv = 
c                                 (p - p(v))/rt
     *         (prt - (1d0 + (c1 + e1 + e2)/v 
     *          - (c3 + (c42 + (c53 + c64/v)/v)/v)/v/a2)/v)/
c                                 dpdv/rt
     *         ((-1d0 + (2d0*(c3/a2-c1-e1-e2) + (c8*e1 + c0*e2 
     *          + (c46*a1 - c33)/a3 + (a1*c12 - c34 
     *          + (c20*a1 - c44 + (c36 + (c55 + (c56 
     *          - c66/v)/v)/v)/v)/v)/v/a3)/v)/v)/v/v)

         v = v + dv

         if (dabs(dv/v).lt.1d-6) then
c                                 converged, compute ln(fugacity)      
            f = c1/v+1d0/a1-1d0/c2-(e1-c7)/c8-(e2-c9)/c0
     *          + dlog(rt/v) + p*v/rt - 1d0

            exit
          
         else if (v.lt.0d0.or.it.gt.100) then
c                                 use cork fugacities
            write (*,*) 'WARNING: pseos did not converge ',p,t,v

            exit 

         end if 

         it = it + 1

      end do 

      end 

      subroutine pshp
c-----------------------------------------------------------------------
c pshp routine to compute h2o-co2 fugacities from the pitzer & sterner
c (1994) eos, using excess properties from holland & powell (2003).
c                                 JADC, Nov 28 2010.
 
c  for the unitiated input and output is done through common blocks
c  cst5, cst11, and cst26, the relevant variables are:
 
c  for input:
c               pbars= pressure in bars
c               t    = temperature in kelvins
c               r    = gas constant
c               xco2 = mole fraction of co2 in fluid phase
c  for output:
c               fh2o = the natural log of the co2 fugacity
c               fco2 = the natural log of the co2 fugacity
c-----------------------------------------------------------------------
      implicit none

      double precision vh2o,vco2,w,xh2o,whc
 
      double precision pbars,t,xco2,u1,u2,tr,pr,r,ps
      common/ cst5 /pbars,t,xco2,u1,u2,tr,pr,r,ps

      double precision fh2o,fco2
      common/ cst11 /fh2o,fco2
                  
      save whc
      data whc/2525.86d0/
c----------------------------------------------------------------------
      if (xco2.eq.1d0) then
 
         call pseos (w,fco2,2) 

      else if (xco2.eq.0d0) then
 
         call pseos (w,fh2o,1) 

      else

         call pseos (vco2,fco2,2) 
         call pseos (vh2o,fh2o,1) 

         xh2o = 1d0 - xco2
c                                 whc = 2*ahc/R, where ahc is the h2o-co2
c                                 interaction parameter estimated by H&P
c                                 2003, 10.5 kJ/mol  
         w = whc/t/(xh2o*vh2o+xco2*vco2)**2
c                                 ln(gamma) = w*v*x^2
         fco2 = fco2 + w*vco2*xco2**2 + dlog(xco2)
         fh2o = fh2o + w*vh2o*xh2o**2 + dlog(xh2o)
 
      end if

      end


c these are nag routines modified to solve the phase eq problem, whereby
c the basic constraints are 0<=x<=1 and the general constraints are ax=b

c many of the routines no longer perform the functions indicated in the 
c nag documentation or source comments. 

      subroutine lpnag (n,nclin,a,lda,bl,cvec,istate,x,ax,
     *                  clamda,iw,leniw,w,lenw,idead,itmax,istart)

c     a  is a constant  nclin by n  matrix.
c     n  is the number of variables (dimension of x).
c     nclin  is the number of general linear constraints (rows of  a).

      implicit none

      double precision  obj
      integer           idead, iter, lda, leniw, lenw, n, nclin
      double precision  a(lda,*), ax(*), bl(nclin), 
     *                  clamda(n+nclin), cvec(*), w(lenw), x(n)
      integer           istate(n+nclin), iw(leniw)

      double precision  amin,errmax,feamax,feamin,xnorm,dnrm2 

      integer           ianrmj, it, j, jinf, jmax, istart,
     *                  nact1, nactiv, nartif,
     *                  nfree, ngq, nmoved, nrejtd, nrz, numinf,
     *                  nviol, nz, itmax

      logical           done, found, halted, rowerr, unitq

      character*6       msg

      integer loclc
      common/ ae04mf /loclc(15)

      double precision  wmach(9)
      common/ ax02za /wmach

      integer ldq,ldt
      common/ be04nb /ldt,ldq

      double precision  asize,dtmax, dtmin
      common/ de04nb /asize, dtmax, dtmin

      integer nctotl,lkx,lanorm,ld,lgq,lcq,lrlam,lt,lq,lwtinf,lwrk

      save nctotl,lkx,lanorm,ld,lgq,lcq,lrlam,lt,lq,lwtinf,lwrk
c----------------------------------------------------------------------   
      iter = 0

      if (istart.eq.0.or.idead.eq.-1) then 
c                                 cold start (istart = 0) or reusing 
c                                 matrices from a prior optimization 
c                                 (idead = -1)
         nctotl = n + nclin
         lkx = 4 + n
         lanorm = 1 + nclin + n
         ld = lanorm + nclin + nclin
         lgq = ld + n
         lcq = lgq + n
         lrlam = lcq + n
         lt = lrlam + n
         lq = lt + ldt*ldt
         lwtinf = lq + ldq*ldq
         lwrk = lwtinf + n + nclin

         loclc(4) = lanorm
         loclc(5) = lanorm + nclin
         loclc(7) = lanorm + nclin + nclin
         loclc(8) = lgq
         loclc(9) = lcq
         loclc(10) = lrlam
         loclc(12) = lt
         loclc(13) = lq
         loclc(14) = lwtinf
         loclc(15) = lwrk

      end if 

      idead = 0 
c                                     define the initial feasibility tolerances in clamda.
      call f06fbf(n+nclin,wmach(4),w(1),1)
      call e04mfr('i',n,nclin,nmoved,iter,numinf,istate,clamda,w(1),x)

      if (istart.eq.0) then
c                                     true cold start initialization
         ianrmj = lanorm
         do j = 1, nclin
            w(ianrmj) = dnrm2(n,a(j,1),lda)
            ianrmj = ianrmj + 1
         end do 

         call f06flf(nclin,w(lanorm),1,asize,amin)
         call f06flf(nctotl,w(1),1,feamax,feamin)
         call dcopy(nctotl,w(1),1,w(lwtinf),1)
         call dscal(nctotl,1d0/feamin,w(lwtinf),1)

c        define the initial working set.

         call lpinit (nctotl,nactiv,nartif,nfree,n,
     *                istate,iw(4),iw(lkx),x,w(lgq))

c        compute the tq factorization of the working set matrix.

         unitq = .true.
         nz = nfree

         if (nactiv.gt.0) then
            it = nactiv + 1
            nact1 = nactiv
            nactiv = 0
            ngq = 0

            call e04nfq(unitq,1,nact1,it,nactiv,nartif,nz,nfree,
     *                  nrejtd,ngq,n,ldq,lda,ldt,istate,iw(4),
     *                  iw(lkx),wmach(9),a,w(lt),w(lgq),w(lq),w(lwrk),
     *                  w(ld),w(lrlam))

            if (nactiv.eq.0) then 

               write (*,*) 'i am gonna crash, set msg and die, but why?'

            end if             
         end if
      else 
c                                 warm start
         unitq = iw(1) .eq. 1
         nfree = iw(2)
         nactiv = iw(3)
         nz = nfree - nactiv

      end if

c        install the transformed linear term in cq.

      call dcopy(n,cvec,1,w(lcq),1)
      call e04nbw(6,n,nz,nfree,ldq,unitq,iw(lkx),w(lcq),w(lq),w(lwrk))

      jinf = 0
      nrz = 0

c     repeat               (until working set residuals are acceptable)

c     move x onto the constraints in the working set.

   40 call e04mfj(rowerr,unitq,nclin,nactiv,nfree,nz,n,ldq,lda,ldt,
     *            istate,iw(4),iw(lkx),jmax,errmax,xnorm,a,ax,bl,
     *            w(1),w(lt),x,w(lq),w(ld),w(lwrk))

      if (rowerr) then
         msg = 'infeas'
         numinf = 1
         obj = errmax
         go to 60
      end if

      call e04mfz(msg,unitq,iter,itmax,
     *            jinf,nviol,n,nclin,lda,nactiv,nfree,nrz,nz,istate,
     *            iw(4),iw(lkx),obj,numinf,xnorm,a,ax,bl,
     *            cvec,clamda,w(1),x,w)

      found = msg .eq. 'feasbl' .or. msg .eq. 'optiml' .or. msg .eq.
     *        'weak  ' .or. msg .eq. 'unbndd' .or. msg .eq. 'infeas'
      halted = msg .eq. 'itnlim'

      if (found) call e04mfr('o',n,nclin,nmoved,iter,numinf,istate,
     *               clamda,w(1),x)

      done = found .and. nviol .eq. 0 .and. nmoved .eq. 0

      if ( .not. (done .or. halted)) go to 40

      call e04mfk(nfree,n,nctotl,nactiv,iw(4),iw(lkx),
     *            clamda,w(lrlam))

      iw(1) = 0
      if (unitq) iw(1) = 1
      iw(2) = nfree
      iw(3) = nactiv

   60 if (msg.eq.'optiml') then
         idead = 0
      else if (msg.eq.'feasbl') then
         idead = 0
      else if (msg.eq.'weak  ') then
         idead = 0
      else if (msg.eq.'unbndd') then
         idead = 2
      else if (msg.eq.'infeas') then
         idead = 3
      else if (msg.eq.'itnlim') then
         idead = 4
      else if (msg.eq.'errors') then
         idead = 6
      end if

      istart = 1 

      end

      subroutine e04mfk(nfree,n,nctotl,nactiv,kactiv,kx,
     *           clamda,rlamda)
c     mark 16 release. nag copyright 1992.
c     e04mfk   creates the expanded lagrange multiplier vector clamda.

      integer           n, nactiv, nctotl, nfree
      double precision  clamda(nctotl), rlamda(n)
      integer           kactiv(n), kx(n)
      double precision  rlam
      integer           j, k, nfixed, nz

      nz = nfree - nactiv

c     expand multipliers for bounds, linear and nonlinear constraints
c     into the  clamda  array.

      call f06fbf(nctotl,0d0,clamda,1)

      nfixed = n - nfree

      do k = 1, nactiv + nfixed
         if (k.le.nactiv) then
            j = kactiv(k) + n
            rlam = rlamda(nactiv-k+1)
         else
            j = kx(nz+k)
            rlam = rlamda(k)
         end if
         clamda(j) = rlam
      end do

      end

      subroutine e04mfz(msg,unitq,iter,itmax,
     *                  jinf,nviol,n,nclin,lda,nactiv,nfree,nrz,
     *                  nz,istate,kactiv,kx,obj,numinf,xnorm,a,
     *                  ax,bl,cvec,featol,featlu,x,w)

c     e04mfz  is a subroutine for linear programming.
c     on entry, it is assumed that an initial working set of
c     linear constraints and bounds is available.  the arrays  istate,
c     kactiv  and  kx  will have been set accordingly
c     and the arrays  t  and  q  will contain the tq factorization of
c     the matrix whose rows are the gradients of the active linear
c     constraints with the columns corresponding to the active bounds
c     removed.  the tq factorization of the resulting (nactiv by nfree)
c     matrix is  a(free)*q = (0 t),  where q is (nfree by nfree) and t
c     is upper-triangular.

c     over a cycle of iterations, the feasibility tolerance featol
c     increases slightly (from tolx0 to tolx1 in steps of tolinc).
c     this ensures that all steps taken will be positive.

c     after kdegen consecutive iterations, variables within featol of
c     their bounds are set exactly on their bounds and iterative
c     refinement is used to satisfy the constraints in the working set.
c     featol is then reduced to tolx0 for the next cycle of iterations.


c     values of istate(j) for the linear constraints.......

c     istate(j)
c     ---------
c          0    constraint j is not in the working set.
c          1    constraint j is in the working set at its lower bound.
c          2    constraint j is in the working set at its upper bound.
c          3    constraint j is in the working set as an equality.

c     constraint j may be violated by as much as featol(j).

      implicit none 

      double precision  zero, one
      parameter         (zero=0.0d+0,one=1.0d+0)
      character*6       empty
      parameter         (empty='      ')
      double precision  obj, xnorm
      integer           iter, jinf, lda, n, nactiv, nclin, nfree,
     *                  nrz, numinf, nviol, nz
      logical           unitq

      character*6       msg

      double precision  a(lda,*), ax(*), bl(nclin), 
     *                  cvec(*), featlu(n+nclin), featol(n+nclin), w(*),
     *                  x(n)
      integer           istate(n+nclin), kactiv(n), kx(n)

      double precision  alfa, asize,
     *                  dtmax, dtmin,trulam
      integer           isdel, jadd, jdel,ldq, ldt, itmax

      double precision  wmach(9)
      integer           loclc
      double precision  alfap, alfhit, bigalf, biggst, condmx, 
     *                  dinky, dnorm, errmax, flmax,
     *                  gfnorm, grznrm, gznorm, objsiz, smllst,
     *                  suminf, tinyst, trubig, trusml, wssize, zerolm
      integer           iadd, ifix, inform, is, it, j, jbigst,
     *                  jmax, jsmlst, jtiny, kbigst, kdel, ksmlst, lad,
     *                  lanorm, lcq, ld, lgq, lq, lrlam, lt,
     *                  lwrk, lwtinf,
     *                  nctotl, ngq, nmoved, notopt, ntfixd
      logical           firstv, hitlow, move, onbnd, overfl,
     *                  unbndd, fail

      double precision  ddot, dnrm2, f06blf

      common            /ae04mf/loclc(15)
      common            /ax02za/wmach
      common            /be04nb/ldt,ldq
      common            /de04mf/alfa, trulam, isdel, jdel, jadd
      common            /de04nb/asize, dtmax, dtmin

      save              firstv

c     specify the machine-dependent parameters.

      flmax = wmach(7)

      ngq = 2
      it = 1
      lanorm = loclc(4)
      lad = loclc(5)
      ld = loclc(7)
      lgq = loclc(8)
      lcq = loclc(9)
      lrlam = loclc(10)
      lt = loclc(12)
      lq = loclc(13)
      lwtinf = loclc(14)
      lwrk = loclc(15)

c     we need a temporary array when changing the active set.
c     use the multiplier array.

      if (iter.eq.0) then
         jadd = 0
         jdel = 0
         isdel = 0
         firstv = .false.
         alfa = zero
      end if

      nctotl = n + nclin
      nviol = 0
      condmx = flmax

      call e04mfh(n,nclin,lda,istate,numinf,suminf,bl,a,
     *            featol,w(lgq),x,w(lwtinf))

      if (numinf.gt.0) then
         call e04nbw(6,n,nz,nfree,ldq,unitq,kx,w(lgq),w(lq),w(lwrk))
      else 
         call dcopy(n,w(lcq),1,w(lgq),1)
      end if

      if (numinf.eq.0) then
         obj = ddot(n,cvec,1,x)
      else
         obj = suminf
      end if

      msg = empty

c*    ======================start of main loop==========================
c     +    do while (msg .eq. empty)
   20 if (msg.eq.empty) then

         gznorm = zero
         if (nz.gt.0) gznorm = dnrm2(nz,w(lgq),1)

         if (nrz.eq.nz) then
            grznrm = gznorm
         else
            grznrm = zero
            if (nrz.gt.0) grznrm = dnrm2(nrz,w(lgq),1)
         end if

         gfnorm = gznorm
         if (nfree.gt.0 .and. nactiv.gt.0) gfnorm = dnrm2(nfree,w(lgq),
     *       1)

         if (numinf.gt.0) then
            dinky = wmach(2)*abs(suminf)
         else
            objsiz = one + abs(obj)
            wssize = zero
            if (nactiv.gt.0) wssize = dtmax
            dinky = wmach(2)*max(wssize,objsiz,gfnorm)
         end if

c        if the reduced gradient z'g is small enough,
c        lagrange multipliers will be computed.
         if (grznrm.le.dinky) then

c           the point  x  is a constrained stationary point.
c           compute lagrange multipliers.
c           define what we mean by 'tiny' and non-optimal multipliers.

            notopt = 0
            jdel = 0
            zerolm = -dinky
            smllst = -dinky
            biggst = dinky + one
            tinyst = dinky

            call e04mfm(n,lda,ldt,nactiv,nfree,nz,istate,
     *                  kactiv,kx,zerolm,notopt,numinf,trusml,smllst,
     *                  jsmlst,ksmlst,tinyst,jtiny,jinf,trubig,biggst,
     *                  jbigst,kbigst,a,w(lanorm),w(lgq),w(lrlam),w(lt),
     *                  w(lwtinf))

            if (nrz.lt.nz) call e04mfl(n,nrz,nz,zerolm,notopt,
     *                                 numinf,trusml,smllst,jsmlst,
     *                                 tinyst,jtiny,w(lgq))

            if (abs(jsmlst).gt.0) then

c              delete a constraint.

c              e04mfm  or  e04mfl  found a non-optimal multiplier.

               trulam = trusml
               jdel = jsmlst

               if (jsmlst.gt.0) then

c                 regular constraint.

                  kdel = ksmlst
                  isdel = istate(jdel)
                  istate(jdel) = 0
               end if
            else
               if (numinf.gt.0 .and. jbigst.gt.0) then

c                 no feasible point exists for the constraints but
c                 the sum of the constraint violations can be reduced
c                 by moving off constraints with multipliers greater
c                 than 1.

                  jdel = jbigst
                  kdel = kbigst
                  isdel = istate(jdel)
                  if (trubig.le.zero) is = -1
                  if (trubig.gt.zero) is = -2
                  istate(jdel) = is
                  trulam = trubig
                  firstv = .true.
                  numinf = numinf + 1
               end if
            end if

            if (jdel.eq.0) then
               if (numinf.gt.0) then
                  msg = 'infeas'
               else
                  msg = 'optiml'
               end if
               go to 20
            end if

c           constraint  jdel  has been deleted.
c           update the  tq  factorization.

            call e04nfp(unitq,it,n,nactiv,nfree,ngq,nz,nrz,lda,ldq,ldt,
     *                  jdel,kdel,kactiv,kx,a,w(lt),w(lgq),w(lq)
     *                  ,w(ld),w(lrlam),fail)

            if (fail) then
c                                 this error appeared dec 07,
c                                 possibly due to parameter edits?
c                                 JADC 12/07 
               msg = 'infeas'
               goto 20 
            end if 

         else

c           compute a search direction.

            if (iter.ge.itmax) then
               msg = 'itnlim'
               go to 20
            end if

            iter = iter + 1

            call dcopy(nrz,w(lgq),1,w(ld),1)
            call dscal(nrz,(-one),w(ld),1)

            dnorm = dnrm2(nrz,w(ld),1)

            call e04nbw(1,n,nrz,nfree,ldq,unitq,kx,w(ld),w(lq),w(lwrk))
            call dgemv('n',nclin,n,a,lda,w(ld),zero,w(lad))

c           find the constraint we bump into along d.
c           update  x  and  ax  if the step alfa is nonzero.

c           alfhit is initialized to bigalf. if it remains that value
c           after the call to  e04mfs, it is regarded as infinite.

            bigalf = f06blf(1d20,dnorm,overfl)

            call e04mfs(firstv,n,nclin,istate,bigalf,dnorm,
     *                  hitlow,move,onbnd,unbndd,alfhit,alfap,jadd,
     *                  w(lanorm),w(lad),ax,bl,featol,w(ld),x)

            if (unbndd) then
               msg = 'unbndd'
               go to 20
            end if

            alfa = alfhit
            call daxpy(n,alfa,w(ld),1,x)

            call daxpy(nclin,alfa,w(lad),1,ax)
            xnorm = dnrm2(n,x,1)

c           add a constraint to the working set.
c           update the  tq  factors of the working set.
c           use  d  as temporary work space.

            if (jadd.gt.n) then
               iadd = jadd - n
               istate(jadd) = 3              
            else
               if (hitlow) then
                  istate(jadd) = 1
               else
                  istate(jadd) = 2
               end if

               if (alfa.ge.zero) then
                  if (hitlow) then
                     x(jadd) = 0d0
                  else
                     x(jadd) = 1d0
                  end if
               end if
               do ifix = 1, nfree
                  if (kx(ifix).eq.jadd) exit
               end do 
            end if

            call e04nfr(unitq,inform,ifix,iadd,jadd,it,nactiv,nz,
     *                  nfree,ngq,n,lda,ldq,ldt,kx,condmx,a,
     *                  w(lt),w(lgq),w(lq),w(lwrk),w(lrlam),w(ld))

            nz = nz - 1
            nrz = nrz - 1

            if (jadd.le.n) then

c              a simple bound has been added.

               nfree = nfree - 1
            else

c              a general constraint has been added.

               nactiv = nactiv + 1
               kactiv(nactiv) = iadd
            end if

c           increment featol.

            call daxpy(nctotl,0d0,featlu,1,featol)

            if (mod(iter,50).eq.0) then

c              check the feasibility of constraints with non-
c              negative istate values.  if some violations have
c              occurred.  set inform to force iterative
c              refinement and a switch to phase 1.

               call e04mfq(n,nclin,istate,nviol,jmax,errmax,ax,
     *                     bl,featol,x)

            end if

            if (mod(iter,999999).eq.0) then

c              every  kdegen  iterations, reset  featol  and
c              move  x  on to the working set if it is close.

               call e04mfr('e',n,nclin,nmoved,iter,
     *                     numinf,istate,featol,featlu,x)

               nviol = nviol + nmoved
            end if

            if (nviol.gt.0) then
               msg = 'resetx'
               go to 20
            end if

            if (numinf.ne.0) then
               call e04mfh(n,nclin,lda,istate,numinf,suminf,bl,
     *                     a,featol,w(lgq),x,w(lwtinf))

               if (numinf.gt.0) then
                  call e04nbw(6,n,nz,nfree,ldq,unitq,kx,w(lgq),w(lq),
     *                        w(lwrk))
               else 
                  call dcopy(n,w(lcq),1,w(lgq),1)
               end if
            end if

            if (numinf.eq.0) then
               obj = ddot(n,cvec,1,x)
            else
               obj = suminf
            end if
         end if
         go to 20
c        +    end while
      end if
c     ======================end of main loop============================

      if (msg.eq.'optiml') then

            if (nrz.lt.nz) then
               msg = 'weak  '
            else
               ntfixd = 0
               do 80 j = 1, n
                  if (istate(j).eq.4) ntfixd = ntfixd + 1
   80          continue
               if (ntfixd.gt.0) msg = 'weak  '
            end if
            if (abs(jtiny).gt.0) msg = 'weak  '

      else if (msg.eq.'unbndd' .and. numinf.gt.0) then
         msg = 'infeas'
      end if

      end

      subroutine e04mfj(rowerr,unitq,nclin,nactiv,nfree,nz,n,ldq,lda,
     *                  ldt,istate,kactiv,kx,jmax,errmax,xnorm,a,ax,bl,
     *                  featol,t,x,q,p,work)
c     mark 16 release. nag copyright 1992.

c     ******************************************************************
c     e04mfj  computes the point on a working set that is closest in the
c     least-squares sense to the input vector x.

c     if the computed point gives a row error of more than the
c     feasibility tolerance, an extra step of iterative refinement is
c     used.  if  x  is still infeasible,  the logical variable rowerr
c     is set.

c     original version derived from lssetx january-1987.
c     this version of  e04mfj  dated   5-jul-1989.
c     ******************************************************************
      double precision  zero, one
      parameter         (zero=0.0d+0,one=1.0d+0)
      integer           ntry
      parameter         (ntry=5)

      double precision  errmax, xnorm
      integer           jmax, lda, ldq, ldt, n, nactiv, nclin, nfree, nz
      logical           rowerr, unitq

      double precision  a(lda,*), ax(*), bl(nclin), 
     *                  featol(n+nclin), p(n), q(ldq,*), t(ldt,*),
     *                  work(n), x(n)
      integer           istate(n+nclin), kactiv(n), kx(n)
c     .. scalars in common ..
      

c     .. arrays in common ..

c     .. local scalars ..
      double precision  bnd
      integer           i, is, j, k, ktry
c     .. external functions ..
      double precision  ddot, dnrm2
      integer           idamax
c     .. common blocks ..



c     ------------------------------------------------------------------
c     move  x  onto the simple bounds in the working set.
c     ------------------------------------------------------------------
      do 20 k = nfree + 1, n
         j = kx(k)
         is = istate(j)
         bnd = 0d0
         if (is.ge.2) bnd = 1d0
         if (is.ne.4) x(j) = bnd
   20 continue
c     ------------------------------------------------------------------
c     move  x  onto the general constraints in the working set.
c     ntry  attempts are made to get acceptable row errors.
c     ------------------------------------------------------------------
      ktry = 1
      jmax = 1
      errmax = zero

c     repeat

c        set work = residuals for constraints in the working set.
c        solve for p, the smallest correction to x that gives a point
c        on the constraints in the working set.  define  p = y*(py),
c        where  py  solves the triangular system  t*(py) = residuals.

40       do 60 i = 1, nactiv
            k = kactiv(i)
            work(nactiv-i+1) = bl(k) - ddot(n,a(k,1),lda,x)
   60    continue

         call dtrsv('n',nactiv,t(1,nz+1),ldt,work)
         call f06fbf(n,zero,p,1)
         call dcopy(nactiv,work,1,p(nz+1),1)
         call e04nbw(2,n,nz,nfree,ldq,unitq,kx,p,q,work)
         call daxpy(n,one,p,1,x)


c     ---------------------------------------------------------------
c     compute the 2-norm of  x.
c     initialize  ax  for all the general constraints.
c     ---------------------------------------------------------------
      xnorm = dnrm2(n,x,1)
      call dgemv('n',nclin,n,a,lda,x,zero,ax)

c     ---------------------------------------------------------------
c     check the row residuals.
c     ---------------------------------------------------------------

         do k = 1, nactiv
            i = kactiv(k)
            is = istate(n + i)
            if (is.ge.1) work(k) = bl(i) - ax(i)
         end do

         jmax = idamax(nactiv,work)
         errmax = abs(work(jmax))

      ktry = ktry + 1

      if ( .not. (errmax.le.featol(jmax) .or. ktry.gt.ntry)) go to 40

      rowerr = errmax .gt. featol(jmax)

      end

      subroutine e04nbw(mode,n,nz,nfree,nq,unitq,kx,v,zy,wrk)

      double precision  zero, one
      parameter         (zero=0.0d+0,one=1.0d+0)
      integer           mode, n, nfree, nq, nz
      logical           unitq
      double precision  v(n), wrk(n), zy(nq,*)
      integer           kx(n)
      integer           j, j1, j2, k, l, lenv, nfixed


      nfixed = n - nfree
      j1 = 1
      j2 = nfree
      if (mode.eq.1 .or. mode.eq.4) j2 = nz
      if (mode.eq.2 .or. mode.eq.5 .or. mode.eq.7) j1 = nz + 1
      lenv = j2 - j1 + 1

      if (mode.le.3) then

         if (nfree.gt.0) call f06fbf(nfree,zero,wrk,1)

c        copy  v(fixed)  into the end of  wrk.

         if (mode.ge.2 .and. nfixed.gt.0) call dcopy(nfixed,v(nfree+1),
     *       1,wrk(nfree+1),1)

c        set  wrk  =  relevant part of  zy * v.

         if (lenv.gt.0) then
            if (unitq) then
               call dcopy(lenv,v(j1),1,wrk(j1),1)
            else
               call dgemv('n',nfree,j2-j1+1,zy(1,j1),nq,v(j1),one,wrk)
            end if
         end if

c        expand  wrk  into  v  as a full n-vector.

         call f06fbf(n,zero,v,1)
         do 20 k = 1, nfree
            j = kx(k)
            v(j) = wrk(k)
   20    continue

c        copy  wrk(fixed)  into the appropriate parts of  v.

         if (mode.gt.1) then
            do 40 l = 1, nfixed
               j = kx(nfree+l)
               v(j) = wrk(nfree+l)
   40       continue
         end if

      else
c        ===============================================================
c        mode = 4, 5, 6, 7  or  8.
c        ===============================================================
c        put the fixed components of  v  into the end of  wrk.

         if (mode.eq.5 .or. mode.eq.6) then
            do 60 l = 1, nfixed
               j = kx(nfree+l)
               wrk(nfree+l) = v(j)
   60       continue
         end if

c        put the free  components of  v  into the beginning of  wrk.

         if (nfree.gt.0) then
            do 80 k = 1, nfree
               j = kx(k)
               wrk(k) = v(j)
   80       continue

c           set  v  =  relevant part of  zy' * wrk.

            if (lenv.gt.0) then
               if (unitq) then
                  call dcopy(lenv,wrk(j1),1,v(j1),1)
               else
                  call dgemv('t',nfree,j2-j1+1,zy(1,j1),nq,wrk,
     *                       zero,v(j1))
               end if
            end if
         end if

c        copy the fixed components of  wrk  into the end of  v.

         if (nfixed.gt.0 .and. (mode.eq.5 .or. mode.eq.6))
     *       call dcopy(nfixed,wrk(nfree+1),1,v(nfree+1),1)
      end if

      end


      subroutine e04nfq(unitq,k1,k2,it,nactiv,nartif,nz,nfree,
     *                  nrejtd,ngq,n,ldq,lda,ldt,istate,kactiv,kx,
     *                  condmx,a,t,gqm,q,w,c,s)
c     mark 16 release. nag copyright 1992.

c     ******************************************************************
c     e04nfq  includes general constraints  k1  thru  k2  as new rows of
c     the  tq  factorization:
c              a(free) * q(free)  = (  0 t )
c                        q(free)  = (  z y )

c     a) the  nactiv x nactiv  upper-triangular matrix  t  is stored
c        with its (1,1) element in position  (it,jt)  of the array  t.

c     original version written by peg,  october-31-1984.
c     this version of  e04nfq  dated  7-jul-1989.
c     ******************************************************************

      implicit none 

      double precision  zero, one
      parameter         (zero=0d0,one=1d0)

      double precision  condmx
      integer           it, k1, k2, lda, ldq, ldt, n, nactiv,
     *                  nartif, nfree, ngq, nrejtd, nz
      logical           unitq
      double precision  a(lda,*), c(n), gqm(n,*), q(ldq,*), s(n),
     *                  t(ldt,*), w(n)
      integer           istate(*), kactiv(n), kx(n)

      double precision  asize, dtmax, dtmin
      double precision  wmach(9)
      double precision  cndmax, cond, delta, dtnew, rnorm, rowmax,
     *                  rtmax, tdtmax, tdtmin
      integer           i, iadd, iartif, ifix, inform, iswap, j, jadd,
     *                  jt, k, l, nzadd
      logical           overfl
      double precision  dnrm2, f06blf
      common            /ax02za/wmach
      common            /de04nb/asize, dtmax, dtmin

      rtmax = wmach(8)

      jt = nz + 1

c     estimate the condition number of the constraints already
c     factorized.

      if (nactiv.eq.0) then
         dtmax = zero
         dtmin = one
         if (unitq) then

c           first general constraint added.  set  q = i.

            call f06qhf(nfree,nfree,q,ldq)
            unitq = .false.
         end if
      else
         call f06flf(nactiv,t(it,jt),ldt+1,dtmax,dtmin)
      end if

      do 20 k = k1, k2
         iadd = kactiv(k)
         jadd = n + iadd
         if (nactiv.lt.nfree) then

            overfl = .false.

c           transform the incoming row of  a  by  q'.

            call dcopy(n,a(iadd,1),lda,w,1)
            call e04nbw(8,n,nz,nfree,ldq,unitq,kx,w,q,s)

c           check that the incoming row is not dependent upon those
c           already in the working set.

            dtnew = dnrm2(nz,w,1)
            if (nactiv.eq.0) then

c              this is the first general constraint in the working set.

               cond = f06blf(asize,dtnew,overfl)
               tdtmax = dtnew
               tdtmin = dtnew
            else

c              there are already some general constraints in the working
c              set. update the estimate of the condition number.

               tdtmax = max(dtnew,dtmax)
               tdtmin = min(dtnew,dtmin)
               cond = f06blf(tdtmax,tdtmin,overfl)
            end if

            if (cond.ge.condmx .or. overfl) then

c              this constraint appears to be dependent on those already
c              in the working set.  skip it.

               istate(jadd) = 0
               kactiv(k) = -kactiv(k)
            else
               if (nz.gt.1) then

c                 use a single column transformation to reduce the first
c                 nz-1  elements of  w  to zero.

c                 apply the householder reflection  i  -  w w'.
c                 the reflection is applied to  z  and gqm so that
c                    y  =    z  * w,   z    =  z    -  y w'  and
c                    y  =  gqm' * w,   gqm  =  gqm  -  w y',
c                 where  w = wrk1 (from householder),
c                 and    y = wrk2 (workspace).

c                 note that delta  has to be stored after the reflection
c                 is used.

                  delta = w(nz)
                  call f06frf(nz-1,delta,w,w(nz))
                  if (w(nz).gt.zero) then

                     call dgemv ('n',nfree,nz,q,ldq,w,zero,s)
                     call dger (nfree,nz,s,w,q,ldq)

                     if (ngq.gt.0) then
                        call dgemv('t',nz,ngq,gqm,n,w,zero,s)
                        call dger (nz,ngq,w,s,gqm,n)
                     end if
                  end if

                  w(nz) = delta
               end if
               it = it - 1
               jt = jt - 1
               nactiv = nactiv + 1
               nz = nz - 1
               call dcopy(nactiv,w(jt),1,t(it,jt),ldt)
               dtmax = tdtmax
               dtmin = tdtmin
            end if
         end if
   20 continue

      if (nactiv.lt.k2) then

c        some of the constraints were classed as dependent and not
c        included in the factorization.  re-order the part of  kactiv
c        that holds the indices of the general constraints in the
c        working set.  move accepted indices to the front and shift
c        rejected indices (with negative values) to the end.

         l = k1 - 1
         do 40 k = k1, k2
            i = kactiv(k)
            if (i.ge.0) then
               l = l + 1
               if (l.ne.k) then
                  iswap = kactiv(l)
                  kactiv(l) = i
                  kactiv(k) = iswap
               end if
            end if
   40    continue

c        if a vertex is required,  add some temporary bounds.
c        we must accept the resulting condition number of the working
c        set.

            cndmax = rtmax
            nzadd = nz
            do 80 iartif = 1, nzadd
               if (unitq) then
                  ifix = nfree
                  jadd = kx(ifix)
               else
                  rowmax = zero
                  do 60 i = 1, nfree
                     rnorm = dnrm2(nz,q(i,1),ldq)
                     if (rowmax.lt.rnorm) then
                        rowmax = rnorm
                        ifix = i
                     end if
   60             continue
                  jadd = kx(ifix)

                  call e04nfr(unitq,inform,ifix,iadd,jadd,it,
     *                        nactiv,nz,nfree,ngq,n,lda,ldq,ldt,
     *                        kx,cndmax,a,t,gqm,q,w,c,s)
               end if
               nfree = nfree - 1
               nz = nz - 1
               nartif = nartif + 1
               istate(jadd) = 4
   80       continue

         if (it.gt.1) then

c           if some dependent constraints were rejected,  move  t  to
c           the top of the array  t.

            do 120 k = 1, nactiv
               j = nz + k
               do 100 i = 1, k
                  t(i,j) = t(it+i-1,j)
  100          continue
  120       continue
         end if
      end if

      nrejtd = k2 - nactiv

      end

      subroutine lpinit (nctotl,nactiv,nartif,nfree,n,
     *                   istate,kactiv,kx,x,wx)

      integer           n, nactiv, nartif, nctotl, nfree

      double precision  wx(n), x(n)
      integer           istate(nctotl), kactiv(n), kx(n)
      integer           is, j, jfix, jfree

c     initialize variables 

      do j = 1, n
         x(j) = 0d0
         wx(j) = 0d0
      end do 

      nfree = n
      nactiv = 0
      nartif = 0

      do j = 1, n
         istate(j) = 0
      end do 

      do j = n+1, nctotl
         istate(j) = 3
      end do

c     define nfree and kactiv.

      do j = n+1, nctotl
         nactiv = nactiv + 1
         kactiv(nactiv) = j - n
      end do 
 
c        see if any bounds are violated or nearly satisfied.
c        if so,  add these bounds to the working set and set the
c        variables exactly on their bounds.

         j = n
  100    if (j.ge.1 .and. nactiv.lt.nfree) then
            if (istate(j).eq.0) then
               is = 0
               if (wx(j).le.1d-2) is = 1
               if (1d0-wx(j).le.2d-2) is = 2
               if (is.gt.0) then
                  istate(j) = is
                  if (is.eq.1) wx(j) = 0d0
                  if (is.eq.2) wx(j) = 1d0
                  nfree = nfree - 1
               end if
            end if
            j = j - 1
            go to 100
         end if

      jfree = 1
      jfix = nfree + 1

      do j = 1, n
         if (istate(j).le.0) then
            kx(jfree) = j
            jfree = jfree + 1
         else
            kx(jfix) = j
            jfix = jfix + 1
         end if
      end do 

      end

      subroutine e04mfr(job,n,nclin,nmoved,iter,numinf,istate,
     *                  featol,featlu,x)

      implicit none
      double precision  point6
      parameter         (point6=0.6d+0)
      integer           iter, n, nclin, nmoved, numinf
      character*1       job
      double precision  featlu(n+nclin), featol(n+nclin), x(n)
      integer           istate(n+nclin)
      double precision  tolx0
      integer           itnfix, ndegen
      double precision  wmach(9)
      integer           nfix(2)
      double precision  d, epsmch, tolz
      integer           is, j, maxfix
      common            /ax02za/wmach/ce04mf/tolx0, ndegen, itnfix, nfix
      save              tolz

      nmoved = 0
      if (job.eq.'i') then

c        job = 'initialize'.
c        initialize at the start of each linear problem.
c        kdegen  is the expand frequency      and
c        featlu  are the user-supplied feasibility tolerances.
c        they are not changed.

         epsmch = wmach(3)

         ndegen = 0
         itnfix = 0
         nfix(1) = 0
         nfix(2) = 0
         tolx0 = 0.5d+0
         tolz = epsmch**point6

         do 20 j = 1, n + nclin
            featol(j) = tolx0*featlu(j)
   20    continue
      else

c        job = 'end of cycle' or 'optimal'.
c        initialize local variables maxfix and tolz.

         maxfix = 2

         if (job.eq.'o') then

c           job = 'optimal'.
c           return with nmoved = 0 if the last call was at the same
c           iteration,  or if there have already been maxfix calls with
c           the same state of feasibility.

            if (itnfix.eq.iter) return
            if (numinf.gt.0) then
               j = 1
            else
               j = 2
            end if

            if (nfix(j).ge.maxfix) return
            nfix(j) = nfix(j) + 1
         end if

c        reset featol to its minimum value.

         do 40 j = 1, n + nclin
            featol(j) = tolx0*featlu(j)
   40    continue

c        count the number of times a variable is moved a nontrivial
c        distance onto its bound.

         itnfix = iter

         do 60 j = 1, n
            is = istate(j)
            if (is.gt.0 .and. is.lt.4) then
               if (is.eq.1) then
                  d = abs(x(j))
               else
                  d = abs(x(j)-1d0)
               end if

               if (d.gt.tolz) nmoved = nmoved + 1
            end if
   60    continue

      end if

      end

      subroutine e04mfq(n,nclin,istate,nviol,jmax,errmax,ax,bl,
     *                  featol,x)

      implicit none

c     e04mfq  checks the residuals of the constraints that are believed
c     to be feasible.  the number of constraints violated by more than
c     featol is computed, along with the maximum constraint violation.

      double precision  zero
      parameter         (zero=0.0d+0)

      double precision  errmax
      integer           jmax, n, nclin, nviol

      double precision  ax(*), bl(nclin), featol(n+nclin), x(n)
      integer           istate(n+nclin)

      double precision  con, feasj, res
      integer           is, j

c     compute the number of constraints (nviol) violated by more than
c     featol and  the maximum constraint violation (errmax).
c     (the residual of a constraint in the working set is treated as if
c     it were an equality constraint fixed at that bound.)

      nviol = 0
      jmax = 0
      errmax = zero

      do 40 j = 1, n + nclin
         is = istate(j)

         if (is.ge.0) then
            feasj = featol(j)

            if (j.le.n) then
               con = x(j)
            else
               con = ax(j-n)
            end if
c           check for constraint violations.

            if (j.le.n) then 
               res = -con
               if (res.gt.feasj) then
                  nviol = nviol + 1
                  go to 20
               end if

               res = 1d0 - con
               if (res.lt.(-feasj)) then
                  nviol = nviol + 1
                  res = -res
                  go to 20
               end if
c           this constraint is satisfied,  but count a large residual
c           as a violation if the constraint is in the working set.
               res = zero

               if (is.eq.1) then
               res = abs(con)

               else if (is.eq.2) then
               res = abs(1d0-con)

               else if (is.eq.3) then
               res = abs(1d0-con)
               end if
            else 
               res = bl(j-n) - con
               if (res.gt.feasj) then
                  nviol = nviol + 1
                  go to 20
               end if

c           this constraint is satisfied,  but count a large residual
c           as a violation if the constraint is in the working set.

               res = zero

               if (is.eq.1) then
               res = abs(bl(j-n)-con)

               else if (is.eq.2) then
               res = abs(bl(j-n)-con)

               else if (is.eq.3) then
               res = abs(bl(j-n)-con)
               end if
            end if 

            if (res.gt.feasj) nviol = nviol + 1

   20       if (res.gt.errmax) then
               jmax = j
               errmax = res
            end if
         end if
   40 continue

      end

      subroutine e04mfs(firstv,n,nclin,istate,bigalf,pnorm,
     *                  hitlow,move,onbnd,unbndd,alfa,alfap,jhit,anorm,
     *                  ap,ax,bl,featol,p,x)

      implicit none 

c     e04mfs  finds a step alfa such that the point x + alfa*p reaches
c     one of the linear constraints (including bounds).

c     in this version of e04mfs, when x is infeasible, the number of
c     infeasibilities will never increase.  if the number stays the
c     same, the sum of infeasibilities will decrease.  if the number
c     decreases by one or more,  the sum of infeasibilities will usually
c     decrease also, but occasionally it will increase after the step
c     alfa  is taken.  (convergence is still assured because the number
c     has decreased.)

c     three possible steps are computed as follows:

c     alfaf = the maximum step that can be taken without violating
c              one of the constraints that are currently satisfied.

c     alfai = reaches a linear constraint that is currently violated.
c              usually this will be the furthest such constraint along
c              p, subject to the angle between the constraint normal and
c              p being reasonably close to the maximum value among
c              infeasible constraints,  but if firstv = .true. it will
c              be the first one along p.  the latter case applies only
c              when the problem has been determined to be infeasible,
c              and the sum of infeasibilities are being minimized.
c              (alfai is not defined when x is feasible.)

c     alfai is needed occasionally when infeasible, to prevent
c     going unnecessarily far when alfaf is quite large.  it will
c     always come into effect when x is about to become feasible.
c     (the sum of infeasibilities will decrease initially as alfa
c     increases from zero, but may start increasing for larger steps.
c     choosing a large alfai allows several elements of  x  to
c     become feasible at the same time.

c     in the end, we take  alfa = alfaf  if x is feasible, or if
c     alfai > alfap (where  alfap  is the perturbed step from pass 1).
c     otherwise,  we take  alfa = alfai.

c     input parameters
c     ----------------
c     bigalf defines what should be treated as an unbounded step.
c     bigbnd provides insurance for detecting unboundedness.
c            if alfa reaches a bound as large as  it is
c            classed as an unbounded step.
c     featol is the array of current feasibility tolerances used by
c            e04mfh.  typically in the range 0.5*tolx to 0.99*tolx,
c            where tolx is the featol specified by the user.
c     tolinc (in common) is used to determine stepmn (see below),
c            the minimum positive step.
c     istate is set as follows:
c            istate(j) = -2  if a'x .lt. bl - featol
c                      = -1  if a'x .gt. bu + featol
c                      =  0  if a'x is not in the working set
c                      =  1  if a'x is in the working set at bl
c                      =  2  if a'x is in the working set at bu
c                      =  3  if a'x is in the working set (an equality)
c                      =  4  if x(j) is temporarily fixed.
c            values -2 and -1 do not occur once feasible.
c     bl     the lower bounds on the variables.
c     x      the values of       ditto.
c     p      the search direction.


c     output parameters
c     -----------------
c     hitlow  = true  if a lower bound restricted alfa.
c             = false otherwise.
c     move    = true  if  exact ge stepmn  (defined at end of code).
c     onbnd   = true  if  alfa = exact.  this means that the step  alfa
c                     moves x  exactly onto one of its constraints,
c                     namely  bound.
c             = false if the exact step would be too small
c                     ( exact .lt. stepmn ).
c               (with these definitions,  move = onbnd).
c     unbndd  = true  if alfa = bigalf.  jhit may possibly be zero.
c               the parameters hitlow, move, onbnd, bound and exact
c               should not be used.
c     jhit    = the index (if any) such that constraint jhit reaches
c               a bound.
c     bound   = the bound value bl(jhit) or bu(jhit) corresponding
c               to hitlow.
c     exact   = the step that would take constraint jhit exactly onto
c               bound.
c     alfa    = an allowable, positive step.
c               if unbndd is true,  alfa = stepmx.
c               otherwise,          alfa = max( stepmn, exact ).


c     e04mfs is based on minos 5.2 routine m5chzr, which implements the
c     expand procedure to deal with degeneracy. the step alfaf is
c     chosen as in the two-pass approach of paula harris (1973), except
c     that this version insists on returning a positive step, alfa.
c     two features make this possible:

c        1. featol increases slightly each iteration.

c        2. the blocking constraint, when added to the working set,
c           retains the value ax(jhit) + alfa * ap(jhit),
c           even if this is not exactly on the blocking bound.

c     for infeasible variables moving towards their bound, we require
c     the rate of change of the chosen constraint to be at least gamma
c     times as large as the biggest available.  this still gives us
c     freedom in pass 2.
c     gamma = 0.1 and 0.01 seemed to inhibit phase 1 somewhat.
c     gamma = 0.001 seems to be safe.

      double precision  zero, one, gamma
      parameter         (zero=0d0,one=1d0,gamma=1d-3)

      double precision  alfa, alfap, bigalf, pnorm
      integer           jhit, n, nclin
      logical           firstv, hitlow, move, onbnd, unbndd

      double precision  anorm(*), ap(*), ax(*), bl(nclin),
     *                  featol(n+nclin), p(n), x(n)
      integer           istate(n+nclin)

      double precision  tolx0
      integer           itnfix, ndegen
      integer           nfix(2)
      double precision  alfai, atp, atpabs, atpmxf, atpmxi, atpscd, atx,
     *                  bound, delta, exact, res,
     *                  stepmn, tolpiv
      integer           i, j, jhitf, jhiti, js
      logical           blockf, blocki

      common            /ce04mf/tolx0, ndegen, itnfix, nfix

      double precision wmach(9)
      common/ax02za/wmach

c     tolpiv is a tolerance to exclude negligible elements of a'p.

      tolpiv = wmach(1)*pnorm

c     first pass -- find steps to perturbed constraints, so that
c     alfap will be slightly larger than the true step.
c     in degenerate cases, this strategy gives us some freedom in the
c     second pass.  the general idea follows that described by p.m.j.
c     harris, p.21 of mathematical programming 5, 1 (1973), 1--28.

      atpmxi = zero
      alfap = bigalf

      do 20 j = 1, n + nclin
         js = istate(j)

         if (js.le.0) then
            delta = featol(j)

            if (j.le.n) then
               atx = x(j)
               atp = p(j)
               atpabs = abs(atp)
               atpscd = atpabs
            else
               i = j - n
               atx = ax(i)
               atp = ap(i)
               atpabs = abs(atp)
               atpscd = atpabs/(one+anorm(i))
            end if

            if (atpscd.le.tolpiv) then

c              this constraint appears to be constant along p.  it is
c              not used to compute the step.  give the residual a value
c              that can be spotted in the debug output.

               res = -one

            else if (atp.le.zero .and. js.ne.-2) then

c              a'x  is decreasing and the lower bound is not violated.

c              test for smaller alfap.
c              if the upper bound is violated. test for bigger atp.

               if (j.le.n) then 
                   res = atx + delta                    
                  if (res.lt.alfap*atpabs) alfap = res/atpabs
               else                  
                  res = atx - bl(j-n) + delta 
                  if (res.lt.alfap*atpabs) alfap = res/atpabs
               end if 

               if (js.eq.-1) atpmxi = max(atpmxi,atpscd)

            else if (atp.gt.zero .and. js.ne.-1) then

c              a'x  is increasing and the upper bound is not violated.

c              test for smaller alfap.
c              if the lower bound is violated. test for bigger atp.

               if (j.le.n) then 
                  res = 1d0 - atx + delta
                  if (res.lt.alfap*atp) alfap = res/atp
               else 
                  res = bl(j-n) - atx + delta
                  if (res.lt.alfap*atp) alfap = res/atp
               end if 

               if (js.eq.-2) atpmxi = max(atpmxi,atpscd)
            end if

         end if
   20 continue

c     second pass.
c     for feasible variables, recompute steps without perturbation.
c     amongst constraints that are closer than alfap, choose the one
c     that makes the largest angle with the search direction.
c     for infeasible variables, find the largest step subject to a'p
c     being no smaller than gamma * max(a'p).

      if (firstv) then
         alfai = bigalf
      else
         alfai = zero
      end if

      atpmxf = zero
      atpmxi = gamma*atpmxi
      jhitf = 0
      jhiti = 0

      do 40 j = 1, n + nclin
         js = istate(j)

         if (js.le.0) then

            if (j.le.n) then
               atx = x(j)
               atp = p(j)
               atpabs = abs(atp)
               atpscd = atpabs
            else
               i = j - n
               atx = ax(i)
               atp = ap(i)
               atpabs = abs(atp)
               atpscd = atpabs/(one+anorm(i))
            end if

            if (atpscd.le.tolpiv) then

c              this constraint appears to be constant along p.  it is
c              not used to compute the step.  give the residual a value
c              that can be spotted in the debug output.

               res = -one

            else if (atp.le.zero .and. js.ne.-2) then

c              a'x  is decreasing.

c              test for bigger a'p if the lower bound is satisfied.
c              test for smaller alfaf.

               if (atpscd.gt.atpmxf) then

                  if (j.le.n) then 
                     res = atx 

                     if (res.le.alfap*atpabs) then
                        atpmxf = atpscd
                        jhitf = j
                     end if
                   else 
                     res = atx - bl(j-n)

                     if (res.le.alfap*atpabs) then
                        atpmxf = atpscd
                        jhitf = j
                     end if
                   end if 
               end if

               if (js.eq.-1) then
c                 the upper bound is violated.
c                 test for bigger or smaller alfai,  depending on the
c                 value of firstv.
                  if (j.le.n) then 
                  if (firstv) then
                     res = atx - 1d0

                     if (res.le.alfai*atpabs) then
                        alfai = res/atpabs
                        jhiti = j
                     end if

                  else if (atpscd.ge.atpmxi) then
                     res = atx - 1d0

                     if (res.gt.alfai*atpabs) then
                        alfai = res/atpabs
                        jhiti = j
                     end if
                  end if
                  else 
                  if (firstv) then
                     res = atx - bl(j-n)

                     if (res.le.alfai*atpabs) then
                        alfai = res/atpabs
                        jhiti = j
                     end if

                  else if (atpscd.ge.atpmxi) then
                     res = atx - bl(j-n)

                     if (res.gt.alfai*atpabs) then
                        alfai = res/atpabs
                        jhiti = j
                     end if
                  end if
                  
                  end if 
               end if

            else if (atp.gt.zero .and. js.ne.-1) then

c              a'x  is increasing and the upper bound is not violated.

c              test for smaller alfap.

               if (atpscd.gt.atpmxf) then

                  if (j.le.n) then 
                     res = 1d0 - atx
                     if (res.le.alfap*atp) then
                        atpmxf = atpscd
                        jhitf = j
                     end if
                  else 
                     res = bl(j-n) - atx
                     if (res.le.alfap*atp) then
                        atpmxf = atpscd
                        jhitf = j
                     end if

                  end if 
               end if

               if (js.eq.-2) then
c                 the lower bound is violated.
c                 test for bigger or smaller alfai,  depending on the
c                 value of firstv.
               if (j.le.n) then       
                  if (firstv) then
                     res = -atx

                     if (res.le.alfai*atp) then
                        alfai = res/atp
                        jhiti = j
                     end if
                  else if (atpscd.ge.atpmxi) then
                     res = - atx

                     if (res.gt.alfai*atp) then
                        alfai = res/atp
                        jhiti = j
                     end if
                  end if       
               else
                  res = bl(j-n) - atx
                  if (firstv) then
                     if (res.le.alfai*atp) then
                        alfai = res/atp
                        jhiti = j
                     end if
                  else if (atpscd.ge.atpmxi) then
                     if (res.gt.alfai*atp) then
                        alfai = res/atp
                        jhiti = j
                     end if
                  end if
               end if
               end if 
            end if
         end if
   40 continue

c     ------------------------------------------------------------------
c     see if a feasible and/or infeasible constraint blocks.
c     ------------------------------------------------------------------
      blockf = jhitf .gt. 0
      blocki = jhiti .gt. 0
      unbndd = .not. (blockf .or. blocki)

      if (unbndd) go to 60

      if (blockf) then

c        a constraint is hit which is currently feasible.
c        the corresponding step alfaf is not used, so no need to get it,
c        but we know that alfaf .le. alfap, the step from pass 1.

         jhit = jhitf
         if (jhit.le.n) then
            atp = p(jhit)
         else
            atp = ap(jhit-n)
         end if
         hitlow = atp .lt. zero
      end if

c     if there is a choice between alfaf and alfai, it is probably best
c     to take alfai.  however, we can't if alfai is bigger than alfap.

      if (blocki .and. alfai.le.alfap) then

c        an infeasible variable reaches its violated bound.

         jhit = jhiti
         if (jhit.le.n) then
            atp = p(jhit)
         else
            atp = ap(jhit-n)
         end if
         hitlow = atp .gt. zero
      end if

      if (jhit.le.n) then
         atx = x(jhit)
      else
         atx = ax(jhit-n)
      end if

c     try to step exactly onto bound, but make sure the exact step
c     is sufficiently positive.  (exact will be alfaf or alfai.)
c     since featol increases by  tolinc  each iteration, we know that
c     a step as large as  stepmn  (below) will not cause any feasible
c     variables to become infeasible (where feasibility is measured
c     by the current featol).

      if (jhit.le.n) then 
      if (hitlow) then
         bound = 0d0
      else
         bound = 1d0
      end if
      else 
         bound = bl(jhit-n)
      end if 

      stepmn = 0d0
      exact = (bound-atx)/atp
      alfa = max(stepmn,exact)
      onbnd = alfa .eq. exact
      move = exact .ge. stepmn
      if ( .not. move) ndegen = ndegen + 1

      return

c     unbounded.

   60 alfa = bigalf
      move = .true.
      onbnd = .false.

      end

      subroutine e04nfr(unitq,inform,ifix,iadd,jadd,it,nactiv,nz,
     *                  nfree,ngq,n,lda,ldq,ldt,kx,condmx,
     *                  a,t,gqm,q,w,c,s)

      implicit none 

c     e04nfr  updates the matrices  z, y, t, r  and  d  associated with
c     factorizations

c              a(free) * q(free)  = (  0 t )
c                        q(free)  = (  z y )
c                      r' *d * r  =   hz

c     a) the matrices  r  and  t  are upper triangular.
c     b) the arrays  t  and  r  may be the same array.
c     c) the  nactiv x nactiv  upper-triangular matrix  t  is stored
c        with its (1,1) element in position  (it,jt) of the
c        array  t.   the integer  jt  is always  nz+1.  during regular
c        changes to the working set,  it = 1;  when several constraints
c        are added simultaneously,  it  points to the first row of the
c        existing  t.
c     d) the matrix  r  is stored in the first  nz x nz  rows
c        and columns of the  nfree x nfree  leading principal minor of
c        the array  r.


c     there are three separate cases to consider (although each case
c     shares code with another)...

c     (1) a free variable becomes fixed on one of its bounds when there
c         are already some general constraints in the working set.

c     (2) a free variable becomes fixed on one of its bounds when there
c         are only bound constraints in the working set.

c     (3) a general constraint (corresponding to row  iadd  of  a) is
c         added to the working set.

c     in cases (1) and (2), we assume that  kx(ifix) = jadd.
c     in all cases,  jadd  is the index of the constraint being added.

c     if there are no general constraints in the working set,  the
c     matrix  q = (z y)  is the identity and will not be touched.

c     if  ngq .gt. 0,  the column transformations are applied to the
c     columns of the  (ngq x n)  matrix  gqm'.

      double precision  zero, one
c changed 0 from 0 to 1d-99 11/06
      parameter         (zero=1d-99,one=1.0d+0)
      double precision  condmx
      integer           iadd, ifix, inform, it, jadd, lda, ldq,
     *                  ldt, n, nactiv, nfree, ngq, nz
      logical           unitq
      double precision  a(lda,*), c(n), gqm(n,*), q(ldq,*),
     *                  s(n), t(ldt,*), w(n)
      integer           kx(n)
      double precision  asize, dtmax, dtmin
      double precision  cond, dtnew, tdtmax, tdtmin
      integer           i, j, jt, k, nanew, npiv
      logical           bound, overfl
      double precision  dnrm2, f06blf

      common            /de04nb/asize, dtmax, dtmin

      overfl = .false.
      bound = jadd .le. n
      jt = nz + 1

      if (bound) then
c        ===============================================================
c        a simple bound has entered the working set.  iadd is not used.
c        ===============================================================

         nanew = nactiv

         if (unitq) then

c           q is not stored, but  kx  defines an ordering of the columns
c           of the identity matrix that implicitly define q.
c           define the sequence of pairwise interchanges p that moves
c           the newly-fixed variable to position  nfree.
c           reorder  kx  accordingly.

            do i = 1, nfree - 1
               if (i.ge.ifix) then
                  w(i) = i + 1
                  kx(i) = kx(i+1)
               else
                  w(i) = i
               end if
            end do 
         else

c           q  is stored explicitly.

c           set  w = the  (ifix)-th  row of  q.
c           move the  (nfree)-th  row of  q  to position ifix.

            call dcopy(nfree,q(ifix,1),ldq,w,1)
            if (ifix.lt.nfree) then
               call dcopy(nfree,q(nfree,1),ldq,q(ifix,1),ldq)
               kx(ifix) = kx(nfree)
            end if
         end if
         kx(nfree) = jadd
      else
c        ===============================================================
c        a general constraint has entered the working set.
c        ifix is not used.
c        ===============================================================

         nanew = nactiv + 1

c        transform the incoming row of a by q'.

         call dcopy(n,a(iadd,1),lda,w,1)
         call e04nbw(8,n,nz,nfree,ldq,unitq,kx,w,q,c)

c        check that the incoming row is not dependent upon those
c        already in the working set.

         dtnew = dnrm2(nz,w,1)
         if (nactiv.eq.0) then

c           this is the only general constraint in the working set.

            cond = f06blf(asize,dtnew,overfl)
            tdtmax = dtnew
            tdtmin = dtnew
         else

c           there are already some general constraints in the working
c           set.  update the estimate of the condition number.

            tdtmax = max(dtnew,dtmax)
            tdtmin = min(dtnew,dtmin)
            cond = f06blf(tdtmax,tdtmin,overfl)
         end if

         if (cond.gt.condmx .or. overfl) go to 80

         if (unitq) then

c           first general constraint added.  set  q = i.

            call f06qhf (nfree,nfree,q,ldq)
            unitq = .false.
            it = 0
         end if
      end if

      if (bound) then
         npiv = nfree
      else
         npiv = nz
      end if

      if (unitq) then

c        the orthogonal matrix  q  (i.e.,  q) is not stored explicitly.
c        apply  p, the sequence of pairwise interchanges that moves the
c        newly-fixed variable to position  nfree.

         if (ngq.gt.0) call f06qkf(nfree-1,w,ngq,gqm,n)
      else

         call f06fqf (npiv-1,w(npiv),w,c,s)

         if (ngq.gt.0) call f06qxf ('l','f',npiv,ngq,1,npiv,c,s,gqm,n)
         call f06qxf ('r','f',nfree,nfree,1,npiv,c,s,q,ldq)
      end if

      if ( .not. unitq) then
         if (bound) then

c           bound constraint added.   the rotations affect columns
c           nz+1  thru  nfree  of  gqm'  and  t.

c           the last row and column of  q  has been transformed to plus
c           or minus the unit vector  e(nfree).  we can reconstitute the
c           column of gqm' corresponding to the new fixed variable.

            if (w(nfree).lt.zero.and.ngq.gt.0) 
     *          call dscal(ngq,-one,gqm(nfree,1),n)


            if (nactiv.gt.0) then
               t(it,jt-1) = s(jt-1)*t(it,jt)
               if (dabs(c(jt-1)).lt.zero) c(jt-1) = 0d0
               t(it,jt) = c(jt-1)*t(it,jt)

               if (nactiv.gt.1) then
                  call f06qvf('right',nactiv,1,nactiv,c(jt),s(jt),
     *                        t(it,jt),ldt)
                  call dcopy(nactiv-1,s(jt),1,t(it+1,jt),ldt+1)
               end if

               jt = jt - 1
               call f06flf(nactiv,t(it,jt),ldt+1,tdtmax,tdtmin)
               cond = f06blf(tdtmax,tdtmin,overfl)
            end if
         else

c           general constraint added.  install  w  at the front of  t.
c           if there is no room,  shift all the rows down one position.

            it = it - 1
            if (it.le.0) then
               it = 1
               do 60 k = 1, nactiv
                  j = jt + k - 1
                  do 40 i = k, 1, -1
                     t(i+1,j) = t(i,j)
   40             continue
   60          continue
            end if
            jt = jt - 1
            call dcopy(nanew,w(jt),1,t(it,jt),ldt)
         end if
      end if

c     prepare to exit.  check the magnitude of the condition estimator.

   80 if (nanew.gt.0) then
         if (cond.lt.condmx .and. .not. overfl) then

c           the factorization has been successfully updated.

            inform = 0
            dtmax = tdtmax
            dtmin = tdtmin

         else

c           the proposed working set appears to be linearly dependent.

            inform = 1
         end if
      end if

      end


      subroutine e04nfp(unitq,it,n,nactiv,nfree,ngq,nz,nrz,lda,ldq,ldt,
     *                  jdel,kdel,kactiv,kx,a,t,gqm,q,c,s,fail)
      implicit none 
      double precision  zero, one
      parameter         (zero=0.0d+0,one=1.0d+0)
      integer           it, jdel, kdel, lda, ldq, ldt, n, nactiv, nfree,
     *                  ngq, nrz, nz, kactiv(n), kx(n)
      logical           unitq,fail
      double precision  a(lda,*), c(n), gqm(n,*), q(ldq,*), s(n), 
     *                  t(ldt,*), asize, dtmax, dtmin, cs, sn
      integer           i, ir, itdel, j, jart, jt, k, l, npiv, nrz1,
     *                  nsup, idamax
      common            /de04nb/asize, dtmax, dtmin

      jt = nz + 1
      fail = .false.

      if (jdel.gt.0) then

c        regular constraint or temporary bound deleted.

         if (jdel.le.n) then

c           case 1.  a simple bound has been deleted.
c           =======  columns  nfree+1  and  ir  of gqm' must be swapped.

            ir = nz + kdel

            itdel = nactiv + 1
            nfree = nfree + 1
            if (nfree.lt.ir) then
               kx(ir) = kx(nfree)
               kx(nfree) = jdel
               call dswap(ngq,gqm(nfree,1),n,gqm(ir,1),n)
            end if

            if ( .not. unitq) then

c              copy the incoming column of  a(free)  into the end of  t.

               do 20 k = 1, nactiv
                  i = kactiv(k)
                  t(nactiv-k+1,nfree) = a(i,jdel)
   20          continue

c              expand  q  by adding a unit row and column.

               if (nfree.gt.1) then

                  if (nfree.gt.ldq) then 
c                                 dec 07 bug? JADC
                     call warn (999,zero,nfree,'NLIB')
                     fail = .true.
                     return
                  end if 

                  call f06fbf(nfree-1,zero,q(nfree,1),ldq)
                  call f06fbf(nfree-1,zero,q(1,nfree),1)
               end if
               q(nfree,nfree) = one
            end if
         else
c           case 2.  a general constraint has been deleted.

c           delete row  itdel  of  t  and move up the ones below it.
c           t  becomes lower hessenberg.

            itdel = kdel
            do 60 k = itdel, nactiv
               j = jt + k - 1
               do 40 l = itdel, k - 1
                  i = it + l - 1
                  t(i,j) = t(i+1,j)
   40          continue
   60       continue

            do 80 i = nactiv - itdel + 1, nactiv - 1
               kactiv(i) = kactiv(i+1)
   80       continue
            nactiv = nactiv - 1
         end if

         nz = nz + 1

         if (nactiv.eq.0) then
            dtmax = one
            dtmin = one
         else

            nsup = itdel - 1

            if (nsup.gt.0) then
               npiv = jt + itdel - 1
               if (nsup.gt.1) then
                  call dcopy(nsup-1,t(it+1,jt+1),ldt+1,s(jt+1),1)
                  call f06qrf('right',nactiv,1,nsup,c(jt+1),s(jt+1),
     *                        t(it,jt+1),ldt)
               end if

               call f06baf(t(it,jt+1),t(it,jt),cs,sn)
               t(it,jt) = zero
               s(jt) = -sn
               c(jt) = cs
               call f06qxf('r','b',nfree,nfree,nz,npiv,c,s,q,ldq)
               call f06qxf('l','b',npiv,ngq,nz,npiv,c,s,gqm,n)
            end if

            jt = jt + 1
            call f06flf(nactiv,t(it,jt),ldt+1,dtmax,dtmin)
         end if
      end if

      nrz1 = nrz + 1

      if (nz.gt.nrz) then
         if (jdel.gt.0) then
            jart = nrz1 - 1 + idamax(nz-nrz1+1,gqm(nrz1,1))
         else
            jart = -jdel
         end if

         if (jart.gt.nrz1) then

            if (unitq) then
               k = kx(nrz1)
               kx(nrz1) = kx(jart)
               kx(jart) = k
            else
               call dswap(nfree,q(1,nrz1),1,q(1,jart),1)
            end if

            call dswap(ngq,gqm(nrz1,1),n,gqm(jart,1),n)
         end if
      end if

      nrz = nrz1

      end

      subroutine e04mfl(n,nrz,nz,zerolm,notopt,numinf,trusml,
     *                  smllst,jsmlst,tinyst,jtiny,gq)
      implicit none
      double precision  smllst, tinyst, trusml, zerolm
      integer jsmlst, jtiny, n, notopt, nrz, numinf, nz, j
      double precision  gq(n), rlam

      do 20 j = nrz + 1, nz
         rlam = -abs(gq(j))

         if (rlam.lt.zerolm) then
            if (numinf.eq.0) notopt = notopt + 1

            if (rlam.lt.smllst) then
               trusml = gq(j)
               smllst = rlam
               jsmlst = -j
            end if

         else if (rlam.lt.tinyst) then
            tinyst = rlam
            jtiny = -j
         end if
   20 continue

      end

      subroutine e04mfm(n,lda,ldt,nactiv,nfree,nz,istate,
     *                  kactiv,kx,zerolm,notopt,numinf,trusml,smllst,
     *                  jsmlst,ksmlst,tinyst,jtiny,jinf,trubig,biggst,
     *                  jbigst,kbigst,a,anorms,gq,rlamda,t,wtinf)

      implicit none 

      double precision  one
      parameter         (one=1.0d+0)
      double precision  biggst, smllst, tinyst, trubig, trusml, zerolm
      integer           jbigst, jinf, jsmlst, jtiny, kbigst, ksmlst,
     *                  lda, ldt, n, nactiv, nfree, notopt,
     *                  numinf, nz
      double precision  a(lda,*), anorms(*), gq(n), rlamda(n), t(ldt,*),
     *                  wtinf(*)
      integer           istate(*), kactiv(n), kx(n)
      double precision  anormj, blam, rlam, scdlam
      integer           i, is, j, k, l, nfixed

      nfixed = n - nfree
      jtiny = 0
      jsmlst = 0
      ksmlst = 0
      jbigst = 0
      kbigst = 0

      if (n.gt.nz) call dcopy(n-nz,gq(nz+1),1,rlamda,1)
      if (nactiv.gt.0) call dtrsv('t',nactiv,t(1,nz+1),ldt,rlamda)

      do 40 l = 1, nfixed
         j = kx(nfree+l)
         blam = rlamda(nactiv+l)
         do 20 k = 1, nactiv
            i = kactiv(k)
            blam = blam - a(i,j)*rlamda(nactiv-k+1)
   20    continue
         rlamda(nactiv+l) = blam
   40 continue

      do 60 k = 1, n - nz
         if (k.gt.nactiv) then
            j = kx(nz+k)
         else
            j = kactiv(nactiv-k+1) + n
         end if

         is = istate(j)

         i = j - n
         if (j.le.n) anormj = one
         if (j.gt.n) anormj = anorms(i)

         rlam = rlamda(k)

c        change the sign of the estimate if the constraint is in
c        the working set at its upper bound.

         if (is.eq.2) rlam = -rlam
         if (is.eq.3) rlam = abs(rlam)
         if (is.eq.4) rlam = -abs(rlam)

         if (is.ne.3) then
            scdlam = rlam*anormj

            if (scdlam.lt.zerolm) then
               if (numinf.eq.0) notopt = notopt + 1

               if (scdlam.lt.smllst) then
                  smllst = scdlam
                  trusml = rlamda(k)
                  jsmlst = j
                  ksmlst = k
               end if
            else if (scdlam.lt.tinyst) then
               tinyst = scdlam
               jtiny = j
            end if
         end if

         scdlam = rlam/wtinf(j)
         if (scdlam.gt.biggst .and. j.gt.jinf) then
            biggst = scdlam
            trubig = rlamda(k)
            jbigst = j
            kbigst = k
         end if
   60 continue

      end

      subroutine e04mfh(n,nclin,lda,istate,numinf,suminf,bl,a,
     *                  featol,cvec,x,wtinf)

      implicit none

      double precision  zero
      parameter         (zero=0.0d+0)

      double precision  suminf
      integer           lda, n, nclin, numinf

      double precision  a(lda,*), bl(*), cvec(n), featol(*),
     *                  wtinf(*), x(n)
      integer           istate(*)
      double precision  ctx, feasj, s, weight
      integer           j, k
      double precision  ddot

      numinf = 0
      suminf = zero
      call f06fbf(n,(zero),cvec,1)

      do 40 j = 1, n + nclin

         if (istate(j).le.0) then
            feasj = featol(j)
            if (j.le.n) then
               ctx = x(j)
            else
               k = j - n
               ctx = ddot(n,a(k,1),lda,x)
            end if
            istate(j) = 0

c           see if the lower bound is violated.
            if (j.le.n) then      
               s = 0d0 - ctx
               if (s.gt.feasj) then
                  istate(j) = -2
                  weight = -wtinf(j)
                  go to 20
               end if
c           see if the upper bound is violated.

               s = ctx - 1d0
               if (s.le.feasj) go to 40
               istate(j) = -1
               weight = wtinf(j)
            else
               s = bl(j-n) - ctx
               if (s.gt.feasj) then
                  istate(j) = -2
                  weight = -wtinf(j)
                  go to 20
               end if

               if (-s.le.feasj) go to 40
               istate(j) = -1
               weight = wtinf(j)

            end if 

c           add the infeasibility.

   20       numinf = numinf + 1
            suminf = suminf + abs(weight)*s
            if (j.le.n) then
               cvec(j) = weight
            else
               call daxpy(n,weight,a(k,1),lda,cvec)
            end if
         end if
   40 continue

      end

      subroutine f06baf( a, b, c, s )

      double precision   a, b, c, s, one, zero
      parameter        ( one = 1.0d+0, zero = 1d-99)
      double precision   t
      logical            fail
      double precision   f06blf

      if( b.eq.zero )then
         c  = one
         s  = zero
      else
         t  = f06blf( b, a, fail )
         call f06bcf( t, c, s )
         a  = c*a + s*b
         b  = t
      end if

      end

      subroutine f06fqf (n, alpha, x, c, s )
      implicit none
      double precision   c(*), s(*), x(*), alpha
      integer            n, i, ix

      if( n.gt.0 )then

            ix = 1

         do i = 1, n - 1
                  call f06baf( x( ix + 1), x( ix ), c( i ), s( i ) )
                  s( i )  = -s( i )
                  x( ix ) = -x( ix )
                  ix      =  ix + 1
         end do 
               call f06baf( alpha, x( ix ), c( n ), s( n ) )
               s( n )  = -s( n )
               x( ix ) = -x( ix )

      end if

      end

      subroutine f06qrf( side, n, k1, k2, c, s, a, lda )
      implicit none 
      integer  k1, k2, lda, n, i, j
      character*1 side
      double precision a(lda,*), c(*), s(*),one, zero
      double precision   aij, ctemp, stemp, subh, temp
      parameter ( one = 1.0d+0, zero = 1d-99)


      if((min( n, k1 ).lt.1 ).or.( k2.le.k1 ).or.( k2.gt.n ) )return

      if (side.eq.'l') then


         do 20 j = k1, n
            aij = a( k1, j )
            do 10 i = k1, min( j, k2 ) - 1
               temp = a( i + 1, j )
               a( i, j ) = s( i )*temp + c( i )*aij
               aij = c( i )*temp - s( i )*aij
   10       continue
            if( j.lt.k2 )then

               subh = s( j )
               call f06baf( aij, subh, c( j ), s( j ) )
               a( j, j ) = aij
            else
               a( k2, j ) = aij
            end if
   20    continue

      else if (side.eq.'r') then

         do 40 j = k2 - 1, k1, -1
            subh = s( j )
            call f06baf( a( j + 1, j + 1 ), subh, ctemp, stemp )
            stemp = -stemp
            if (dabs(ctemp).lt.zero) ctemp = 0d0
            s( j ) = stemp
            c( j ) = ctemp
            if( ( ctemp.ne.one ).or.( stemp.ne.zero ) )then
               do 30 i = j, 1, -1
                  temp = a( i, j + 1 )
                  a( i, j + 1 ) = ctemp*temp - stemp*a( i, j )
                  a( i, j ) = stemp*temp + ctemp*a( i, j )
   30          continue
            end if
   40    continue
      end if

      end

      subroutine f06qvf( side, n, k1, k2, c, s, a, lda )

      integer            k1, k2, lda, n
      character*1        side
      double precision   a( lda, * ), c(*), s(*), one, zero
      parameter          ( one = 1d0, zero = 1d-99)
      double precision   aij, ctemp, stemp, temp
      integer            i, j


      if (min( n, k1 ).lt.1.or.k2.le.k1.or.k2.gt.n) return

      if (side.eq.'l') then

         do 20 j = n, k1, -1

            if( j.ge.k2 )then
               aij = a( k2, j )
            else
               aij = c( j )*a( j, j )
               s( j ) = -s( j )*a( j, j )
            end if

            do 10 i = min( k2, j ) - 1, k1, -1
               temp = a( i, j )
               a( i + 1, j ) = c( i )*aij - s( i )*temp
               aij = s( i )*aij + c( i )*temp
   10       continue
            a( k1, j ) = aij
   20    continue

      else if( side.eq.'r' )then

         do j = k1, k2 - 1
            if(c(j).ne.one.or.s(j).ne.zero)then
               stemp = s( j )
               ctemp = c( j )
               if (dabs(ctemp).lt.zero) ctemp = 0d0
               do i = 1, j
                  temp = a( i, j + 1 )
c                                        could check for underflow.
c                                 added following line 11/06
                  if (dabs(a(i,j)).lt.zero) a(i,j) = 0d0                            
                  a( i, j + 1 ) = ctemp*temp - stemp*a( i, j )
                  a( i, j ) = stemp*temp + ctemp*a( i, j )
               end do 
               s( j ) = stemp*a( j + 1, j + 1 )
               a( j + 1, j + 1 ) = ctemp*a( j + 1, j + 1 )
            end if
         end do 
      end if

      end

      subroutine f06qxf( side, direct, m, n, k1, k2, c, s, a, lda )

      implicit none 
      integer            k1, k2, lda, m, n
      character*1        direct, side
      double precision   a( lda, * ), c(*), s(*), one, zero
      parameter          ( one = 1.0d+0, zero = 1d-99)
      double precision   aij, ctemp, stemp, temp
      integer            i, j
      logical            left, right

      left = ( side.eq.'l' )
      right = ( side.eq.'r' )

      if( ( min( m, n, k1 ).lt.1 ).or.( k2.le.k1 ).or.
     $    ( left  .and. k2.gt.m ).or.
     $    ( right .and. k2.gt.n ) )return
      if( left )then

            if (direct.eq.'f') then
               do j = 1, n
                  aij = a( k1, j )
                  do i = k1, k2 - 1
                     temp = a( i + 1, j )
c debug
                     if (c(i).lt.zero) c(i) = 0d0                     
                     a( i, j ) = s( i )*temp + c( i )*aij
                     aij = c( i )*temp - s( i )*aij
                  end do 
                  a( k2, j ) = aij
               end do
            else if(direct.eq.'b')then
               do j = 1, n
                  aij = a( k2, j )
                  do i = k2 - 1, k1, -1
                     temp = a( i, j )
c debug                                   11/06
                     if (c(i).lt.zero) c(i) = 0d0
                     a( i + 1, j ) = c(i)*aij - s(i)*temp
                     aij = s( i )*aij + c(i)*temp
                  end do 
                  a( k1, j ) = aij
               end do 
            end if

      else if (right)then

            if(direct.eq.'f')then
               do 140 j = k1, k2 - 1
                  if( ( c( j ).ne.one ).or.( s( j ).ne.zero ) )then
                     ctemp = c( j )
                     if (dabs(ctemp).lt.zero) ctemp = 0d0
                     stemp = s( j )
                     do 130 i = 1, m
                        temp = a( i, j + 1 )
                        a( i, j + 1 ) = ctemp*temp - stemp*a( i, j )
                        a( i, j ) = stemp*temp + ctemp*a( i, j )
  130                continue
                  end if
  140          continue
            else if(direct.eq.'b')then
               do 160 j = k2 - 1, k1, -1
                  if( ( c( j ).ne.one ).or.( s( j ).ne.zero ) )then
                     ctemp = c( j )
                     if (dabs(ctemp).lt.zero) ctemp = 0d0
                     stemp = s( j )
                     do 150 i = m, 1, -1
                        temp = a( i, j + 1 )
                        a( i, j + 1 ) = ctemp*temp - stemp*a( i, j )
                        a( i, j ) = stemp*temp + ctemp*a( i, j )
  150                continue
                  end if
  160          continue
            end if

      end if

      end


      subroutine f06qkf (n, perm, k, b, ldb )
      implicit none
      integer            k, ldb, n
      double precision   perm(*), b( ldb, * )
      integer            i, j, l
      double precision   temp

      if( min( n, k ).eq.0 ) return

            do i = 1, n
               l = idint(perm( i ))
               if( l.ne.i )then
                  do j = 1, k
                     temp = b( i, j )
                     b( i, j ) = b( l, j )
                     b( l, j ) = temp
                  end do 
               end if
             end do 
      end

      subroutine f06frf( n, alpha, x, zeta )
      implicit none
      double precision   alpha, zeta, beta, eps, scale, ssq
      integer            n
      double precision   x(*), one, zero
      parameter        ( one = 1.0d+0, zero = 1d-99)
      logical            first
      save               eps, first
      data               first/ .true. /

      if( n.lt.1 )then
         zeta = zero
      else if (n.eq.1.and.x(1).eq.zero) then
         zeta = zero
      else

         if( first )then
            first = .false.
            eps   =  1.11022302462516d-16
         end if

c        treat case where p is a 2 by 2 matrix specially.

         if( n.eq.1 )then

c           deal with cases where  alpha = zero  and
c           abs( x(1) ) .le. max( eps*abs( alpha ), tol )  first.

            if (alpha.eq.zero)then
               zeta   =  one
               alpha  =  abs ( x(1) )
               x(1) = -sign( one, x(1))
            else if (dabs(x(1)).le.max(eps*dabs(alpha),zero))then
               zeta   =  zero
            else
               if(dabs(alpha).ge.dabs(x(1)))then
                  beta = dabs(alpha )*dsqrt(1d0 + (x(1)/alpha )**2)
               else
                  beta = dabs(x(1))*dsqrt(1d0 + (alpha/x(1))**2)
               end if
               zeta = dsqrt((dabs( alpha ) + beta )/beta)
               if (alpha.ge.zero) beta = -beta
               x(1) = -x(1)/(zeta*beta)
               alpha  = beta
            end if
         else

c           now p is larger than 2 by 2.

            ssq   = one
            scale = zero
            call f06fjf( n, x, 1, scale, ssq )

c           treat cases where  scale = zero,
c           scale .le. max( eps*abs( alpha ), tol )  and
c           alpha = zero  specially.
c           note that  scale = max( abs( x( i ) ) ).

            if( ( scale.eq.zero ).or.
     $          ( scale.le.max( eps*dabs(alpha),zero) ) )then
               zeta  = zero
            else if( alpha.eq.zero )then
               zeta  = one
               alpha = scale*dsqrt(ssq )
               call dscal( n, -1d0/alpha, x, 1 )
            else
               if( scale.lt.dabs( alpha ) )then
                  beta = dabs(alpha)*dsqrt(1d0 + ssq*( scale/alpha )**2)
               else
                  beta = scale       *dsqrt(ssq +   ( alpha/scale )**2 )
               end if
               zeta = dsqrt(( beta + dabs( alpha ) )/beta )
               if (alpha.gt.zero) beta = -beta
               call dscal( n,-1d0/(zeta*beta), x, 1 )
               alpha = beta
            end if
         end if
      end if

      end

      subroutine f06bcf( t, c, s )
      implicit none
      double precision   c, s, t, one 
      parameter        ( one = 1d0 )
      double precision   abst, eps, rrteps, rteps
      logical            first
      save               first, eps, rteps, rrteps
      data               first/ .true. /

      if( first )then
         first  = .false.
         eps    =  1.11022302462516d-16
         rteps  =  dsqrt( eps )
         rrteps =  1d0/rteps
      end if

      abst = dabs(t)
      if( abst.lt.rteps )then
         c = one
         s = t
      else if( abst.gt.rrteps )then
         c = 1d0/abst
         s = sign( one, t )
      else
         c = 1d0/dsqrt(1d0 + abst**2 )
         s = c*t
      end if

      end


      subroutine f06flf( n, x, incx, xmax, xmin )
      implicit none
      double precision   xmax, xmin, x(*), zero
      integer            incx, n, ix
      parameter        ( zero = 1d-99)

      if( n.lt.1 )then
         xmax = zero
         xmin = zero
      else
         xmax = dabs( x(1) )
         xmin = xmax
         do ix = 1 + incx, 1 + ( n - 1 )*incx, incx
            xmax = max( xmax, dabs( x( ix ) ) )
            xmin = min( xmin, dabs( x( ix ) ) )
         end do 
      end if

      end

      subroutine f06fbf( n, const, x, incx )
      implicit none
      double precision   const, zero, x(*)
      integer            incx, n, ix
      parameter        ( zero = 1d-99)


      if( n.gt.0 )then
         if( const.ne.zero )then
            do ix = 1, 1 + ( n - 1 )*incx, incx
               x( ix ) = const
            end do
         else
            do ix = 1, 1 + ( n - 1 )*incx, incx
               x( ix ) = zero
            end do 
         end if
      end if

      end

      subroutine f06fjf( n, x, incx, scale, sumsq )
      implicit none
      double precision   scale, sumsq
      integer            incx, n
      double precision   x(*),   zero
      parameter        ( zero = 1d-99)
      double precision   absxi
      integer            ix

      if( n.gt.0 )then
         do ix = 1, 1 + ( n - 1 )*incx, incx
            if( x( ix ).ne.zero )then
               absxi = dabs( x( ix ) )
               if( scale.lt.absxi )then
                  sumsq = 1     + sumsq*( scale/absxi )**2
                  scale = absxi
               else
                  sumsq = sumsq +       ( absxi/scale )**2
               end if
            end if
         end do
      end if

      end

      double precision function f06blf( a, b, fail )
      implicit none
      double precision    one, zero, a, b
      parameter           ( one = 1d0, zero = 1d-99)

      double precision      absb, div, flmax, flmin

      logical               first, fail

      save                  first, flmin, flmax

      data                  first/ .true. /

      if( dabs(a).le.zero )then
         div = zero
         if( b.eq.zero )then
            fail = .true.
         else
            fail = .false.
         end if
      else

         if( first )then
            first = .false.
            flmin =  2.22507385850721d-308
            flmax =  1d0/flmin
         end if
c debug 11/06
         if( dabs(b).le.zero )then
            div  =  dsign( flmax, a )
            fail = .true.
         else
            absb = dabs(b)
            if( absb.ge.one )then
               fail = .false.
               if( dabs(a).ge.absb*flmin )then
                  div = a/b
               else
                  div = zero
               end if
            else
               if( dabs(a).le.absb*flmax )then
                  fail = .false.
                  div  =  a/b
               else
                  fail = .true.
                  div  = flmax
                  if( ( ( a.lt.zero ).and.( b.gt.zero ) ).or.
     $                ( ( a.gt.zero ).and.( b.lt.zero ) )     )
     $               div = -div
               end if
            end if
         end if
      end if

      f06blf = div

      end


      subroutine f06qhf (m, n, a, lda )
      implicit none
      integer            lda, m, n
      double precision   a( lda, * )

      integer            i, j

         do j = 1, n
            do i = 1, m
               a(i,j) = 0d0
            end do
         end do

         do i = 1, min(m,n)
            a(i,i) = 1d0
         end do

      end

      double precision function dnrm2 ( n, x, incx )
      implicit none
      integer                           incx, n
      double precision                  x(*)
      double precision      one         , zero
      parameter           (one = 1d0, zero = 1d-99)
      double precision      norm, scale, ssq
      double precision      f06bmf

      if( n.lt.1 )then
         norm  = zero
      else if( n.eq.1 )then
         norm  = dabs( x(1) )
      else
         scale = zero
         ssq   = one
         call f06fjf( n, x, incx, scale, ssq )
         norm  = f06bmf( scale, ssq )
      end if

      dnrm2 = norm

      end

      subroutine dscal ( n, alpha, x, incx )
      implicit none
      double precision   alpha
      integer            incx, n
      double precision   x(*)

c     x := alpha*x

      double precision   one         , zero
      parameter        ( one = 1.0d+0, zero = 1d-99)
      integer            ix

      if( n.gt.0 )then
         if( alpha.eq.zero )then
            do ix = 1, 1 + ( n - 1 )*incx, incx
               x( ix ) = zero
            end do
         else if( alpha.eq.( -one ) )then
            do ix = 1, 1 + ( n - 1 )*incx, incx
               x( ix ) = -x( ix )
            end do
         else if( alpha.ne.one )then
            do ix = 1, 1 + ( n - 1 )*incx, incx
               x( ix ) = alpha*x( ix )
            end do 
         end if
      end if

      end


      double precision function ddot  ( n, x, incx, y)
      implicit none
      integer                           incx, n
      double precision                  x(*), y(*)

c      x'y


      double precision      zero
      parameter           ( zero = 1d-99)
      double precision      sum
      integer               i, ix, iy

      sum = zero
      if( n.gt.0 )then
         if( ( incx.eq.1 ).and.( incx.gt.0 ) )then
            do ix = 1, 1 + ( n - 1 )*incx, incx
               sum = sum + x( ix )*y( ix )
            end do
         else

            iy = 1    
            if( incx.gt.0 )then
               do ix = 1, 1 + ( n - 1 )*incx, incx
                  sum = sum + x( ix )*y( iy )
                  iy  = iy  + 1
               end do
            else
               ix = 1 - ( n - 1 )*incx
               do 30, i = 1, n
                  sum = sum + x( ix )*y( iy )
                  ix  = ix  + incx
                  iy  = iy  + 1
   30          continue
            end if
         end if
      end if

      ddot = sum

      end

      double precision function f06bmf( scale, ssq )
      implicit none
      double precision                  scale, ssq
      double precision      flmax, flmin, norm, sqt
      logical               first
      save                  first, flmax
      data                  first/ .true. /

      if( first )then
         first = .false.
         flmin =  2.22507385850721d-308
         flmax =  1d0/flmin
      end if

      sqt = dsqrt(ssq )
      if( scale.lt.flmax/sqt )then
         norm = scale*sqt
      else
         norm = flmax
      end if

      f06bmf = norm

      end

      subroutine dgemv ( trans, m, n, a, lda, x, beta, y )
      implicit none
      integer lda, m, n, i, info, j, jx, kx, leny, m4, n4
      character*1 trans
      double precision a( lda, * ), x(*), y(*), one, zero, beta
      parameter ( one = 1d0, zero = 1d-99)
      double precision  temp, temp1, temp2, temp3, temp4      

      info = 0

      if( m.lt.0 )then
         info = 2
      else if( n.lt.0 )then
         info = 3
      else if( lda.lt.max( 1, m ) )then
         info = 6
      end if
      if( info.ne.0 )then
         return
      end if

      if(m.eq.0.or.n.eq.0) return

      if( trans.eq.'n' )then
         leny = m
      else
         leny = n
      end if

         kx = 1

      if( beta.ne.one )then
            if( beta.eq.zero )then
               do i = 1, leny
                  y( i ) = zero
               end do
            else
               do i = 1, leny
                  y( i ) = beta*y( i )
               end do 
            end if
      end if

      jx = kx

      if( trans.eq.'n' ) then

            n4 = 4*( n/4 )
            do j = 1, n4, 4
               temp1 = x( jx )
               temp2 = x( jx + 1)
               temp3 = x( jx + 2)
               temp4 = x( jx + 3)
               if( temp1.ne.zero.or.temp2.ne.zero.or.temp3.ne.zero.or.
     $             temp4.ne.zero )then
                  do i = 1, m
                     y( i ) = ( ( ( ( y( i ) + temp1*a( i, j ) )
     $                        + temp2*a( i, j + 1 ) )
     $                        + temp3*a( i, j + 2 ) )
     $                        + temp4*a( i, j + 3 ) )
                  end do 
               end if
               jx = jx + 4
            end do 

            do 80 j = n4 + 1, n, 1
               temp = x( jx )
               if( temp.ne.zero )then
                  do 70 i = 1, m
                     y( i ) = y( i ) + temp*a( i, j )
   70             continue
               end if
               jx = jx + 1
   80       continue

      else

            m4 = 4*( m/4 )
            do 140 j = 1, m4, 4
               temp1 = x( jx )
               temp2 = x( jx + 1)
               temp3 = x( jx + 2)
               temp4 = x( jx + 3)
               if( temp1.ne.zero.or.temp2.ne.zero.or.temp3.ne.zero.or.
     $             temp4.ne.zero )then
                  do 130, i = 1, n
                     y( i ) = ( ( ( ( y( i ) + temp1*a( j, i ) )
     $                        + temp2*a( j + 1, i ) )
     $                        + temp3*a( j + 2, i ) )
     $                        + temp4*a( j + 3, i ) )
  130             continue
               end if
               jx = jx + 4
  140       continue
c**** clean-up loop ****************************************************
            do 160 j = m4 + 1, m, 1
               temp = x( jx )
               if( temp.ne.zero )then
                  do 150 i = 1, n
                     y( i ) = y( i ) + temp*a( j, i )
  150             continue
               end if
               jx = jx + 1
  160       continue

      end if

      end

      subroutine dcopy ( n, x, incx, y, incy )
      implicit none
      integer i, ix, iy, incx, incy, n
      double precision x(*), y(*)   

      if ( n.gt.0 ) then
         if (incx.eq.incy.and.incy.gt.0) then
            do iy = 1, 1 + ( n - 1 )*incy, incy
               y( iy ) = x( iy )
            end do
         else
            if (incx.ge.0) then
               ix = 1
            else
               ix = 1 - ( n - 1 )*incx
            end if
            if (incy.gt.0)then
               do iy = 1, 1 + ( n - 1 )*incy, incy
                  y( iy ) = x( ix )
                  ix      = ix      + incx
               end do 
            else
               iy = 1 - ( n - 1 )*incy
               do i = 1, n
                  y( iy ) = x( ix )
                  iy      = iy      + incy
                  ix      = ix      + incx
               end do 
            end if
         end if
      end if

      end

      subroutine daxpy ( n, alpha, x, incx, y)
      implicit none
      double precision alpha
      integer incx, n, i, ix, iy
      double precision x(*), y(*), zero
      parameter        ( zero = 1d-99)     

      if( n.gt.0 )then
         if( alpha.ne.zero )then
            if( incx.eq.1.and.incx.gt.0)then
               do 10 ix = 1, 1 + ( n - 1 )*incx, incx
                  y( ix ) = alpha*x( ix ) + y( ix )
   10          continue
            else
              
               iy = 1

               if( incx.gt.0 )then
                  do 20 ix = 1, 1 + ( n - 1 )*incx, incx
                     y( iy ) = alpha*x( ix ) + y( iy )
                     iy      = iy            + 1
   20             continue
               else
                  ix = 1 - ( n - 1 )*incx
                  do 30 i = 1, n
                     y( iy ) = alpha*x( ix ) + y( iy )
                     ix      = ix            + incx
                     iy      = iy            + 1
   30             continue
               end if
            end if
         end if
      end if

      end

      subroutine dtrsv ( trans, n, a, lda, x)
      implicit none 
      integer lda, n,  i, info, j
      character*1 trans
      double precision  a(lda,*), x(*), zero, temp
      parameter ( zero = 1d-99)   

      info = 0

      if( n.lt.0 )then
         info = 4
      else if( lda.lt.max( 1, n ) )then
         info = 6
      end if

      if( n.eq.0 ) return

      if( trans.eq.'n' )then

               do j = n, 1, -1
                  if( x( j ).ne.zero )then
                     x( j ) = x( j )/a( j, j )
                     temp = x( j )
                     do i = j - 1, 1, -1
                        x( i ) = x( i ) - temp*a( i, j )
                     end do 
                  end if
               end do 

      else
               do j = 1, n
                  temp = x( j )
                  do i = 1, j - 1
                     temp = temp - a( i, j )*x( i )
                  end do 
                  temp = temp/a( j, j )
                  x( j ) = temp
               end do 

      end if

      end

      subroutine dger ( m, n, x, y, a, lda )
      implicit none 
      integer lda, m, n, i, info, j, jy
      double precision a(lda,*), x(*), y(*), alpha, zero, temp
      parameter (zero = 1d-99)
          
      info = 0

      if ( m.lt.0 )then
         info = 1
      else if( n.lt.0 )then
         info = 2
      else if( lda.lt.max( 1, m ) )then
         info = 9
      end if

c     quick return if possible.

      if( m.eq.0 .or. n.eq.0  ) return

c     start the operations. in this version the elements of a are
c     accessed sequentially with one pass through a.


      jy = 1
      alpha = -1d0

      do j = 1, n
            if( y( jy ).ne.zero )then
               temp = alpha*y( jy )
               do i = 1, m
                  a( i, j ) = a( i, j ) + x( i )*temp
               end do
            end if
            jy = jy + 1
      end do 

      end

      subroutine dswap ( n, x, incx, y, incy)

      implicit none
      integer incx, incy, n, i, ix, iy
      double precision x(*), y(*), temp 

      if( n.gt.0 )then
         if( ( incx.eq.incy ).and.( incy.gt.0 ) )then
            do iy = 1, 1 + ( n - 1 )*incy, incy
               temp    = x( iy )
               x( iy ) = y( iy )
               y( iy ) = temp
            end do
         else
            if( incx.ge.0 )then
               ix = 1
            else
               ix = 1 - ( n - 1 )*incx
            end if
            if( incy.gt.0 )then
               do 20 iy = 1, 1 + ( n - 1 )*incy, incy
                  temp    = x( ix )
                  x( ix ) = y( iy )
                  y( iy ) = temp
                  ix      = ix      + incx
   20          continue
            else
               iy = 1 - ( n - 1 )*incy
               do 30 i = 1, n
                  temp    = x( ix )
                  x( ix ) = y( iy )
                  y( iy ) = temp
                  iy      = iy      + incy
                  ix      = ix      + incx
   30          continue
            end if
         end if
      end if

      end

      integer function idamax ( n, x)

      implicit none
      double precision  x(*), xmax
      integer i, imax, ix, n

      if( n.gt.0 )then
         imax = 1
         if( n.gt.1 )then
            xmax = dabs( x(1) )
            ix   = 1
            do i = 2, n
               ix = ix + 1
               if( xmax.lt.dabs( x( ix ) ) )then
                  xmax = dabs( x( ix ) )
                  imax = i
               end if
            end do 
         end if
      else
         imax = 0
      end if

      idamax = imax

      end

c--------------olib.f---------------------------------------------------
c output routines called only by werami/meemum
c-----------------------------------------------------------------------
      subroutine calpr0 (lu)
c----------------------------------------------------------------------
c calpr0 - output properties of an assemblage, can be called by either
c meemum or werami. if meemum, prints chemical potentials.
c----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'
 
      character cprop*18

      integer i,j,l,lu

      double precision poiss

      integer icomp,istct,iphct,icp
      common/ cst6  /icomp,istct,iphct,icp

      character cname*5
      common/ csta4  /cname(k5) 

      double precision gtot,fbulk,gtot1,fbulk1
      common/ cxt81 /gtot,fbulk(k0),gtot1,fbulk1(k0)

      double precision props,psys,psys1,pgeo,pgeo1
      common/ cxt22 /props(i8,k5),psys(i8),psys1(i8),pgeo(i8),pgeo1(i8)

      integer iopt
      logical lopt
      double precision nopt
      common/ opts /nopt(i10),iopt(i10),lopt(i10)

      integer kkp, np, ncpd, ntot
      double precision cp3, amt
      common/ cxt15 /cp3(k0,k5),amt(k5),kkp(k5),np,ncpd,ntot

      integer jvar
      double precision var,dvr,vmn,vmx
      common/ cxt18 /var(l3),dvr(l3),vmn(l3),vmx(l3),jvar

      character vnm*8
      common/ cxt18a /vnm(l3)  

      double precision atwt
      common/ cst45 /atwt(k0)

      logical gflu,aflu,fluid,shear,lflu,volume,rxn
      common/ cxt20 /gflu,aflu,fluid(k5),shear,lflu,volume,rxn

      integer jbulk
      double precision cblk
      common/ cst300 /cblk(k5),jbulk

      double precision v,tr,pr,r,ps
      common/ cst5  /v(l2),tr,pr,r,ps

      integer ipot,jv,iv
      common / cst24 /ipot,jv(l2),iv(l2)

      double precision mu
      common/ cst330 /mu(k8)

      integer hcp,idv
      common/ cst52  /hcp,idv(k7) 

      integer jtest,jpot
      common/ debug /jtest,jpot

      character*8 vname,xname
      common/ csta2  /xname(k5),vname(l2)

      double precision pcomp
      common/ cst324 /pcomp(k0,k5)

      character pname*14
      common/ cxt21a /pname(k5)

      integer iam
      common/ cst4 /iam
c---------------------------------------------------------------------- 
                                    
      write (lu,1000)  

      if (iam.eq.2) then 
         write (lu,1120) (vname(jv(i)),v(jv(i)), i = 1, ipot)
         write (lu,1120) (vname(jv(i)),v(jv(i)), i = 3, ipot)
      else 
         write (lu,1120) (vnm(i), var(i), i = 1, jvar)
      end if 

      if (iopt(2).eq.0) then 
         cprop = 'molar  proportions'
      else
         cprop = 'weight percentages'
      end if

      write (lu,1020) cprop, (cname(i), i = 1, icomp)

      do i = 1, ntot

         write (lu,1030) pname(i), 
c                                 weight %
     *                   props(17,i)*props(16,i)/psys(17)*1d2,
c                                 vol %
     *                   props(1,i)*props(16,i)/psys(1)*1d2,
c                                 mol %
     *                   props(16,i)/psys(16)*1d2,
c                                 mol
     *                   props(16,i),
c                                 molar or weight composition
     *                   (pcomp(l,i), l = 1, icomp)
      end do 

      write (lu,1160)
c                                 phase/system summary, normal thermo:
      do i = 1, ntot
c                                 N, H, V, Cp, alpha, beta, density
         write (lu,1170) pname(i),props(17,i),props(2,i),props(15,i),
     *                   props(1,i),(props(j,i),j=12,14),props(10,i)
      end do

      write (lu,1170) 'System        ',psys(17),psys(2),psys(15),
     *                psys(1),(psys(j),j=12,14),psys(10)
      if (aflu) write (lu,1170) 'System - fluid',psys1(17),psys1(2),
     *                psys1(15),psys1(1),(psys1(j),j=12,14),psys1(10)

      write (lu,1190)     
c                                 phase/system summary, seismic:
      do i = 1, ntot
 
         write (lu,1200) pname(i), (props(j,i), j = 3, 8),
     *                   poiss(props(7,i),props(8,i))
      end do

      write (lu,1200) 'System        ',(psys(j), j = 3, 8),
     *                                 poiss(psys(7),psys(8))

      if (aflu) write (lu,1200) 'System - fluid',(psys1(j), j = 3, 8),
     *                                        poiss(psys1(7),psys1(8))

      write (lu,1240)
c                                 phase/system summary, seismic derivatives:
      do i = 1, ntot
         write (lu,1250) pname(i),props(18,i),props(20,i),props(19,i),
     *                  props(21,i),props(22,i),props(25,i),
     *                  props(23,i),props(26,i),props(24,i),props(27,i)
      end do

      write (lu,1250) 'System        ',psys(18),psys(20),psys(19),
     *                psys(21),psys(22),psys(25),psys(23),psys(26),
     *                psys(24),psys(27)
      if (aflu) write (lu,1250) 'System - fluid',psys1(18),psys1(20),
     *                psys1(19),psys1(21),psys1(22),psys1(25),psys1(23),
     *                psys1(26),psys1(24),psys1(27)

      if (.not.aflu.or.(aflu.and.psys1(1).eq.0)) then 
c                                 no fluid is present, or the system consists
c                                 entirely of fluid (psys1(1)=0):
         write (lu,1210)

         write (lu,1040)

         do i = 1, icomp

            write (lu,1110) cname(i),fbulk(i), fbulk(i)/gtot*1d2,
     *                      fbulk(i)*atwt(i)/psys(17)*1d2
         end do

         write (lu,1220)

         write (lu,1060) 
c                                 enthalpy, specific enthalpy
     *                   psys(2)/psys(1)*1d5/psys(10),
     *                   psys(2)/psys(1)*1d5, 
c                                 entropy, specific entropy 
     *                   psys(15)/psys(1)*1d5/psys(10),
     *                   psys(15)/psys(1)*1d5,
c                                 cp, specific cp 
     *                   psys(12)/psys(1)*1d5/psys(10),
     *                   psys(12)/psys(1)*1d5

      else 
c                                 fluid is present
         write (lu,1210)

         write (lu,1080)

         do i = 1, icomp

            write (lu,1110) cname(i),fbulk(i),fbulk(i)/gtot*1d2,
     *               fbulk(i)*atwt(i)/psys(17)*1d2,fbulk1(i)/gtot1*1d2,
     *               fbulk1(i)*atwt(i)/psys1(17)*1d2          
         end do

         write (lu,1220)
c                                 true bulk properties:
         write (lu,1060) 
c                                 enthalpy, specific enthalpy
     *                   psys(2)/psys(1)*1d5/psys(10),
     *                   psys(2)/psys(1)*1d5, 
c                                 entropy, specific entropy 
     *                   psys(15)/psys(1)*1d5/psys(10),
     *                   psys(15)/psys(1)*1d5,
c                                 cp, specific cp 
     *                   psys(12)/psys(1)*1d5/psys(10),
     *                   psys(12)/psys(1)*1d5 

c                                 solid only bulk properties:
         write (lu,1100) 
c                                 enthalpy, specific enthalpy
     *                   psys1(2)/psys1(1)*1d5/psys1(10),
     *                   psys1(2)/psys1(1)*1d5, 
c                                 entropy, specific entropy 
     *                   psys1(15)/psys1(1)*1d5/psys1(10),
     *                   psys1(15)/psys1(1)*1d5,
c                                 cp, specific cp 
     *                   psys1(12)/psys1(1)*1d5/psys(10),
     *                   psys1(12)/psys1(1)*1d5

         write (lu,1230) 

      end if 
c                                 chemical potentials variance
      if (jpot.ne.1) then 
         write (lu,1130) (cname(i), i = 1, hcp)
         write (lu,1140) (mu(i), i = 1, hcp)
         write (lu,1071) 2, jbulk - ntot + 2 
      else 
         write (lu,1070) 2, jbulk - ntot + 2 
      end if 

1000  format (/,40('-'),//,'Stable phases at:')
1020  format (/,'Phase Compositions (',a,'):',
     *        /,19x,'wt %',6x,'vol %',5x,'mol %',5x,'mol  ',
     *          5x,20(1x,a,3x))
1030  format (1x,a,3x,3(f6.2,4x),g9.3,1x,20(f7.3,2x))
1040  format (/,14x,'mol',7x,'mol %',6x,'wt %')
1060  format (/,' Enthalpy (J/kg) = ',g12.6,/,
     *          ' Specific Enthalpy (J/m3) = ',g12.6,/,
     *          ' Entropy (J/K/kg) = ',g12.6,/,
     *          ' Specific Entropy (J/K/m3) = ',g12.6,/,
     *          ' Heat Capacity (J/K/kg) = ',g12.6,/,
     *          ' Specific Heat Capacity (J/K/m3) = ',g12.6,/)
1070  format ('Variance (c-p+',i1,') = ',i2,//,40('-'),/)
1071  format (/,'Variance (c-p+',i1,') = ',i2,//,40('-'),/)
1080  format (/,16x,'Complete Assemblage',15x,'Solid+Melt Only',
     *        /,14x,'mol',7x,' mol %',6x,'wt %',9x,' mol %',6x,'wt %')
1100  format (/,' Solid Enthalpy (J/kg) = ',g12.6,/,
     *          ' Solid Secific Enthalpy (J/m3) (2) = ',g12.6,/,
     *          ' Solid Entropy (J/K/kg) = ',g12.6,/,
     *          ' Solid Specific Entropy (J/K/m3) = ',g12.6,/,
     *          ' Solid Heat Capacity (J/K/kg) (1) = ',g12.6,/,
     *          ' Solid Specific Heat Capacity (J/K/m3) (1) = ',g12.6,/)
1110  format (1x,a8,2x,f8.3,5x,2(f6.2,4x),5x,2(f6.2,4x))
1120  format (29x,a8,' = ',g12.6)
1130  format (/,'Chemical Potentials (J/mol):',/,2x,20(4x,a,5x))
1140  format (2x,20(1x,g13.6))
1160  format (/,'Molar Properties and Density:'
     *        /,20x,'N(g)',8x,'H(J)',6x,'S(J/K)',6x,'V(J/bar)',6x,
     *         'Cp(J/K)'
     *         ,6x,'Alpha(1/K)',2x,'Beta(1/bar)',2x,'Density(kg/m3)')
1170  format (1x,a,1x,f9.2,3x,13(g12.5,1x))
1190  format (/,'Seismic Properties:'
     *        /,17x,'Gruneisen_T',7x,'Ks(bar)',7x,'Mu(bar)',
     *        4x,'V0(km/s)',5x,'Vp(km/s)',5x,'Vs(km/s)',5x,
     *        'Poisson ratio')
1200  format (1x,a,3x,12(g12.5,1x))
1210  format (/,'Bulk Composition:')
1220  format (/,'Other Bulk Properties:')
1230  format (/,'N.B.: Aggregate properties represent the entire stable'
     *         ,' assemblage.',/,'Solid aggregate properties represent '
     *         ,'solid and melt properties,',/,'but do not include '
     *         ,'molecular fluid properties.',/)
1240  format (/,'Isochemical Seismic Derivatives:',
     *        /,16x,'Ks_T(bar/K)',2x,'Ks_P',2x,'Mu_T(bar/K)',
     *           2x,'Mu_P',2x,'Vphi_T(km/s/K)',1x,'Vphi_P(km/s/bar)',1x,
     *          'Vp_T(km/s/K)',2x,'Vp_P(km/s/bar)',2x,
     *          'Vs_T(km/s/K)',2x,'Vs_P(km/s/bar)')
1250  format (1x,a,3x,2(f8.2,1x,f8.4,2x),12(g12.5,3x))

      end 

      subroutine getloc (itri,jtri,ijpt,wt,nodata)
c-----------------------------------------------------------------------
c getloc computes local properties requested by either meemum or werami

c if called by werami and ijpt > 1 properties are computed as a 
c weighted mixture (wt(i)) of the assemblages present at nodes (itri(i),
c jtri(i), i = 1, ijpt). otherwise (ijpt=1) the assemblage is that 
c present at node itri(1), jtri(1).

c    ncpdg  -> ncpd
c    npg    -> np
c    idbulk -> kkp
c    xcoor  -> x3

c also sets flags (could set a solvus flag):

c    aflu  -> fluid present
c    fluid -> the phase is a fluid (indexed)

c see getphp got contents of props/psys/psys1 arrays
c----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer i,j,k,l,m,ids,jds,jd,kd,jcoor,kcoor,itri(4),jtri(4),ijpt

      double precision wt(3), cst

      logical sick(i8), nodata, ssick, ppois
c                                 x-coordinates for the assemblage solutions
      double precision x3
      common/ cxt16 /x3(k21,mst,msp)

      double precision p,t,xco2,u1,u2,tr,pr,r,ps
      common/ cst5 /p,t,xco2,u1,u2,tr,pr,r,ps
c                                 
      integer ifp
      common/ cxt32 /ifp(k1)
c                                 composition and model flags
c                                 for final adaptive solution
      integer kkp, np, ncpd, ntot
      double precision cp3, amt
      common/ cxt15 /cp3(k0,k5),amt(k5),kkp(k5),np,ncpd,ntot
c                                 x coordinate description
      integer istg, ispg, imlt, imdg
      common/ cxt6i /istg(h9),ispg(h9,mst),imlt(h9,mst),imdg(ms1,mst,h9)
c                                 global assemblage data
      integer idasls,iavar,iasct,ias
      common/ cst75  /idasls(k5,k3),iavar(3,k3),iasct,ias

      integer iap,ibulk
      common/ cst74  /iap(k2),ibulk

      integer igrd
      common/ cst311/igrd(l7,l7)

      double precision xcoor
      integer icoor
      common/ cxt10 /xcoor(k18),icoor(k1)
c                                 bookkeeping variables
      integer ksmod, ksite, kmsol, knsp
      common/ cxt0  /ksmod(h9),ksite(h9),kmsol(h9,m4,mst),knsp(m4,h9)

      logical gflu,aflu,fluid,shear,lflu,volume,rxn
      common/ cxt20 /gflu,aflu,fluid(k5),shear,lflu,volume,rxn

      double precision bg
      common/ cxt19 /bg(k5,k2)

      double precision gtot,fbulk,gtot1,fbulk1
      common/ cxt81 /gtot,fbulk(k0),gtot1,fbulk1(k0)

      integer iopt
      logical lopt
      double precision nopt
      common/ opts /nopt(i10),iopt(i10),lopt(i10)

      double precision props,psys,psys1,pgeo,pgeo1
      common/ cxt22 /props(i8,k5),psys(i8),psys1(i8),pgeo(i8),pgeo1(i8)

      double precision mus
      common/ cst48 /mus(k8,k2)

      double precision mu
      common/ cst330 /mu(k8)

      integer jtest,jpot
      common/ debug /jtest,jpot

      integer hcp,idv
      common/ cst52  /hcp,idv(k7) 

      logical usv
      integer pindex,tindex
      common/ cst54 /pindex,tindex,usv

      integer icomp,istct,iphct,icp
      common/ cst6  /icomp,istct,iphct,icp

      integer iam
      common/ cst4 /iam

      integer hs2p
      double precision hsb
      common/ cst84 /hsb(i8,4),hs2p(6)
c----------------------------------------------------------------------
c                                 logarithmic_p option
      if (lopt(14)) p = 1d1**p 

      if (iam.ne.2) then 

         jd = igrd(itri(1),jtri(1))
         ias = iap(jd)
c                                 no data test
         if (ias.eq.k3) then 
            nodata = .true.
            goto 99 
         end if 

         np = iavar(1,ias)
         ncpd = iavar(2,ias)
         ntot = iavar(3,ias)

         do i = 1, ntot
            kkp(i) = idasls(i,ias)
         end do 

         jcoor = icoor(jd)
c                                 get the dependent potentials
         if (jpot.ne.1) then
 
            do i = 1, hcp
               mu(i) = 0d0
            end do 

            do i = 1, ijpt

               kd = igrd(itri(i),jtri(i))

               do j = 1, hcp
                  mu(j) = mu(j) + wt(i) * mus(j,kd)
               end do 

            end do 

         end if
c                                 if s/v independent variables, 
c                                 then set p and t 
         if (hcp.gt.icp) then

            if (lopt(14)) then 
               write (*,*) 'ERROR: logarithmic_p must be false for USV'
               stop
            end if 

            p = -mu(pindex)
            t = mu(tindex)

            if (p.lt.0d0.or.t.lt.1d2) then 
               nodata = .true.
               goto 99
            end if 

         end if 

      end if 
c                                 initialize system props/flags
      call insysp (ssick,ppois)

      do i = 1, ntot

         ids = kkp(i)

         if (i.le.np) then 

            if (ksmod(ids).eq.0.or.ksmod(ids).gt.20.and.lopt(6)) then 
               aflu = .true.
               fluid(i) = .true.
            else 
               fluid(i) = .false.
            end if

            if (iam.ne.2) then
 
               do j = 1, istg(ids)
                  do k = 1, ispg(ids,j)
                     jcoor = jcoor + 1
                     cst = bg(i,jd)
c                                 in case zero mode is not on, allow
c                                 composition of zero phase
                     if (ijpt.eq.1.and.cst.eq.0d0) cst = 1d0
                     x3(i,j,k) = wt(1)*cst*xcoor(jcoor)

                  end do 
               end do 

            end if 

         else 

            if (ifp(-ids).eq.1) then 
               aflu = .true.
               fluid(i) = .true.
            else 
               fluid(i) = .false.
            end if

         end if
c                                 molar amounts
         if (iam.eq.2) then 

            props(16,i) = amt(i)
c                                 convert x3 to y for calls to gsol            
            if (ids.gt.0) call x3toy (i,ids)

         else 
c                                 if werami with interpolation, average
c                                 compositions:
            props(16,i) = wt(1)*bg(i,jd)
c                                 now average in other assemblages
            do j = 2, ijpt
            
               kd = igrd(itri(j),jtri(j))
               ias = iap(kd)

               kcoor = icoor(kd)

               do k = 1, i

                  jds = idasls(k,ias)

                  if (k.le.np) then 

                     do l = 1, istg(jds)
                        do m = 1, ispg(jds,l)
                           kcoor = kcoor + 1
                           if (k.lt.i) cycle
c                                 this is done so as to count
c                                 the coordinates as well as make
c                                 the composition.   
                           x3(i,l,m) = x3(i,l,m) 
     *                               + wt(j)*bg(k,kd)*xcoor(kcoor)

                        end do 
                     end do 

                  end if 

                  if (k.lt.i) cycle 
c                                 molar amounts
                  props(16,i) = props(16,i) + wt(j)*bg(k,kd)

               end do  

            end do
c                                 renormalize the composition
            if (i.le.np) then 

               do l = 1, istg(ids)
                  do m = 1, ispg(ids,l)    
                     cst = props(16,i)
                     if (cst.eq.0d0) cst = 1d0    
                     x3(i,l,m) = x3(i,l,m)/cst
                  end do 
               end do 

            end if
             
            if (ids.gt.0) then 
c                                 revover x from x3, 2nd arg has no meaning.
               call getxz (i,i,ids)
c                                 convert x to y for calls to gsol
               call xtoy (ids)

            end if 

         end if 
c                                 get and sum phase properties
         call getphp (ids,i,sick,ssick,ppois)     

      end do 
c                                 compute aggregate properties:
      call gtsysp (sick,ssick)

99    if (lopt(14)) p = dlog10(p)

      end

      subroutine x3toy (id,ids)
c----------------------------------------------------------------------
c subroutine to convert geometric reciprocal solution compositions (x3(id,i,j))
c to geometric endmember fractions (y) for solution model ids. replicate 
c of subroutine xtoy, but for the x3 array (used only by getloc from meemum).
c----------------------------------------------------------------------
      implicit none 

      include 'perplex_parameters.h'
c                                 -------------------------------------
c                                 local variables:
      integer ids, l, m, ld, id
c                                 -------------------------------------
c                                 global variables:
c                                 bookkeeping variables
      integer ksmod, ksite, kmsol, knsp
      common/ cxt0  /ksmod(h9),ksite(h9),kmsol(h9,m4,mst),knsp(m4,h9)
c                                 working arrays
      double precision z, pa, p0a, x, w, y
      common/ cxt7 /y(m4),z(m4),pa(m4),p0a(m4),x(mst,msp),w(m1)
c                                 x coordinate description
      integer istg, ispg, imlt, imdg
      common/ cxt6i /istg(h9),ispg(h9,mst),imlt(h9,mst),imdg(ms1,mst,h9)

      integer lstot,mstot,nstot,ndep,nord
      common/ cxt25 /lstot(h9),mstot(h9),nstot(h9),ndep(h9),nord(h9)

      double precision x3
      common/ cxt16 /x3(k21,mst,msp)
c----------------------------------------------------------------------

      do l = 1, mstot(ids)
c                                 the endmembers may have been
c                                 rearranged from the original order,
c                                 use knsp(l,ids) to assure correct
c                                 indexing
         ld = knsp(l,ids) 

         y(ld) = 1d0

         do m = 1, istg(ids)
            y(ld) = y(ld)*x3(id,m,kmsol(ids,ld,m))
         end do

      end do   

      end 

      double precision function ginc (dt,dp,id)
c-----------------------------------------------------------------------
      implicit none

      double precision dt,dp,gee,gsol,gfrnd

      integer id

      double precision p,t,xco2,u1,u2,tr,pr,r,ps
      common/ cst5 /p,t,xco2,u1,u2,tr,pr,r,ps

      integer iam
      common/ cst4 /iam
c----------------------------------------------------------------------

      p = p + dp 
      t = t + dt 

      if (iam.eq.5) then 
c                                 frendly 
         gee = gfrnd(-id)

      else 
c                                 meemum/werami
         gee = gsol(id)

      end if 

      p = p - dp 
      t = t - dt

      ginc = gee 

      end 

      double precision function gsol (id)
c-----------------------------------------------------------------------
c gsol computes the total (excess+ideal) free energy of solution 
c for a solution identified by index ids and composition y(m4) input
c from cxt7, the composition y is the independent endmember fractions
c for all model types except reciprocal solutions, in which case it is 
c the y's for the full reciprocal model.

c gsol assumes the endmember g's have not been calculated by gall and is
c      only called by WERAMI.
c gsol1 is identical to gsol but can only been called after gall and is 
c      only called by VERTEX and MEEMUM. 
c-----------------------------------------------------------------------
      implicit none
 
      include 'perplex_parameters.h'

      integer k,id

      double precision omega, gproj, hpmelt, gmelt, gfluid, gzero, g, 
     *                 dg, gex, slvmlt

      integer jend
      common/ cxt23 /jend(h9,k12)

      double precision r,tr,pr,ps,p,t,xco2,u1,u2
      common/ cst5   /p,t,xco2,u1,u2,tr,pr,r,ps
c                                 bookkeeping variables
      integer ksmod, ksite, kmsol, knsp
      common/ cxt0  /ksmod(h9),ksite(h9),kmsol(h9,m4,mst),knsp(m4,h9)

      integer lstot,mstot,nstot,ndep,nord
      common/ cxt25 /lstot(h9),mstot(h9),nstot(h9),ndep(h9),nord(h9)
c                                 working arrays
      double precision z, pa, p0a, x, w, y
      common/ cxt7 /y(m4),z(m4),pa(m4),p0a(m4),x(mst,msp),w(m1)
c                                 model type
      logical lorder, lexces, llaar, lrecip
      common/ cxt27 /lorder(h9),lexces(h9),llaar(h9),lrecip(h9)

      integer ispec
      common/ cxt8 /ispec(h9,m4)
c----------------------------------------------------------------------
      if (id.lt.0) then 

         call gphase (-id,g)
         gsol = g

      else 

         g = 0d0
c                                 evaluate dqf coefficients
         call setdqf (id)

         call setw (id) 

         if (ksmod(id).eq.2.or.ksmod(id).eq.3) then 
c                                 -------------------------------------
c                                 macroscopic formulation for normal solutions.
            call gdqf (id,g,y) 
c                                 add entropy and excess contributions
            g = g - t * omega(id,y) + gex(id,y)
c                                 get mechanical mixture contribution
            do k = 1, mstot(id) 
               g = g + y(k) * gproj (jend(id,2+k))
            end do 

         else if (lrecip(id).and.lorder(id)) then 
c                                 -------------------------------------
c                                 convert y coordinates to independent p coordinates
            call y2p0 (id)
c                                 get the speciation, excess and entropy effects.
            call specis (g,id)

            do k = 1, lstot(id) 
c                                 compute mechanical g from these z's, 
c                                 specip adds a correction for the ordered species.
               g = g + gproj(jend(id,2+k)) * p0a(k)
            end do 
c                                 get the dqf, this assumes the independent reactants
c                                 are not dqf'd. gex not neccessary as computed in specip
            call gdqf (id,g,p0a)

         else if (lorder(id)) then 
c                                 -------------------------------------
c                                 non-reciprocal speciation.
            do k = 1, lstot(id)  
               pa(k) = y(k)
               p0a(k) = y(k)
               g = g + y(k) * gproj (jend(id,2+k))
            end do 
c                                 get the speciation energy effect
            call specis (dg,id)

            g = g + dg 
c                                 get dqf corrections
            call gdqf (id,g,p0a) 
 
         else if (lrecip(id)) then 
c                                 -------------------------------------
c                                 macroscopic reciprocal solution w/o order-disorder

c                                 convert y's to p's (p0a here).
            call y2p0 (id)

            do k = 1, lstot(id)
               g = g + gproj (jend(id,2+k)) * p0a(k) 
            end do 
c                                 get the dqf
            call gdqf (id,g,p0a)
c                                 and excess contributions
            g = g - t * omega(id,p0a) + gex(id,p0a)

         else if (ksmod(id).eq.23) then 

             write (*,*) 'toop samis model not coded'

         else if (ksmod(id).eq.24) then 
c                                 -------------------------------------
c                                 hp melt model         
            call gdqf (id,g,y) 

            g = g - t * hpmelt(id) + gex(id,y)
c                                 get mechanical mixture contribution
            do k = 1, mstot(id)  
               g = g + y(k) * gproj (jend(id,2+k))
            end do 

         else if (ksmod(id).eq.25) then 
c                                 -------------------------------------
c                                 ghiorso pmelt model  
            call gdqf (id,g,y) 

            g = g - t * gmelt(id) + gex(id,y)
c                                 get mechanical mixture contribution
            do k = 1, mstot(id)  
               g = g + y(k) * gproj (jend(id,2+k))
            end do 

         else if (ksmod(id).eq.26) then 
c                                 ------------------------------------
c                                 andreas salt model
            call hcneos (g,y(1),y(2),y(3))

            do k = 1, 3
               g = g + y(k) * gproj (jend(id,2+k))
            end do 

         else if (ksmod(id).eq.27) then 

            do k = 1, mstot(id)
               if (y(k).gt.0d0)   
     *            g = g + (gproj(jend(id,2+k))+r*t*dlog(y(k)))*y(k) 
            end do 

         else if (ksmod(id).eq.28) then 
c                                 -------------------------------------
c                                 high T fo-fa-sio2 model  
            call gdqf (id,g,y) 

            g = g - t * slvmlt() + gex(id,y)
c                                 get mechanical mixture contribution
            do k = 1, mstot(id)  
               g = g + y(k) * gproj (jend(id,2+k))
            end do 

         else if (ksmod(id).eq.0) then 
c                                 ------------------------------------
c                                 internal fluid eos
            do k = 1, 2
               g = g + gzero(jend(id,2+k))*y(k)
            end do 

            g = g + gfluid(y(ispec(id,1)))

         else 

            write (*,*) 'what the **** am i doing here?'
            stop

         end if 

      gsol = g 

      end if 

      end

      subroutine shearm (mu,mut,mup,ks,kst,ksp,id)
c-----------------------------------------------------------------------
c shearm returns a linear model for the adiabatic shear/bulk modulus
c relative to the current pressure and temperature.

c three cases:

c make(id) = non-zero => use make definition to compute shear modulus.

c eos = 5 or 6 => shear modulus is known as a function of (V,T), then
c computed by centered finite differences.

c iemod = 1 or 2 => linear model is input
c-----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer id

      double precision mu,mut,mup,mu2,ks,kst,ksp,dt,dp,g,ginc

      double precision smu
      common/ cst323 /smu

      double precision p,t,xco2,u1,u2,tr,pr,r,ps
      common/ cst5 /p,t,xco2,u1,u2,tr,pr,r,ps

      integer make
      common / cst335 /make(k10)

      integer iemod,kmod
      logical smod,pmod
      double precision emod
      common/ cst319 /emod(k15,k10),smod(h9),pmod(k10),iemod(k10),kmod

      integer eos
      common/ cst303 /eos(k10)

      save dt,dp
      data dt,dp/5d0,50d0/
c-----------------------------------------------------------------------

      if (make(id).ne.0) then 

         call makmod (id,mu,mut,mup,ks,kst,ksp)

      else if (eos(id).eq.5.or.eos(id).eq.6) then 
c                                 by calling ginc a call to
c                                 stixrudes EoS for the adiabatic
c                                 shear modulus is implicit (cst323)
         g = ginc(0d0,0d0,-id)
         mu = smu
c                                 temperature derivative
         g = ginc(dt,0d0,-id)
         mu2 = smu
         g = ginc(-dt,0d0,-id)         
         mut = (mu2 - smu)/dt/2d0

         if (p-dp.gt.0d0) then 
c                                 centered pressure derivative
            g = ginc(0d0,dp,-id)
            mu2 = smu
            g = ginc(0d0,-dp,-id)         
            mup = (mu2 - smu)/dp/2d0

         else 

            g = ginc(0d0,dp,-id)
            mu2 = smu
            g = ginc(0d0,2d0*dp,-id)         
            mup = (mu2 - smu)/dp/2d0

         end if 

      else if (iemod(id).ne.0) then 

         mu  = emod(1,id) + (p-pr)*emod(2,id) + (t-tr)*emod(3,id)
         mut = emod(3,id)
         mup = emod(2,id)

         ks  = emod(4,id) + (p-pr)*emod(5,id) + (t-tr)*emod(6,id)
         kst = emod(6,id)
         ksp = emod(5,id)

      end if          

      end 

      subroutine makmod (id,mu,mut,mup,ks,kst,ksp)
c-----------------------------------------------------------------------
c gmake computes and sums the component g's for a make definition.
c the component g's may be calculated redundantly because gmake is
c called by gcpd, which in turn may be called by routines that call
c for a single g (e.g., gphase). 
c-----------------------------------------------------------------------
      implicit none
 
      include 'perplex_parameters.h'

      integer i, id, jd

      double precision mu, pmu, mut, pmut, mup, pmup, 
     *                 ks, pks, kst, pkst, ksp, pksp

      double precision mkcoef, mdqf

      integer mknum, mkind
      common / cst334 /mkcoef(k16,k17),mdqf(k16,k17),mkind(k16,k17),
     *                 mknum(k16)

      integer make
      common / cst335 /make(k10)
c-----------------------------------------------------------------------

      jd = make(id)

      mu = 0d0
      pmut = 0d0
      pmup = 0d0 

      ks = 0d0
      pkst = 0d0
      pksp = 0d0 
c                                compute the sum of the component g's
      do i = 1, mknum(jd)

         call shearm (pmu,pmut,pmup,pks,pkst,pksp,mkind(jd,i))

         mu = mu + mkcoef(jd,i) * pmu
         mut = mut + mkcoef(jd,i) * pmut
         mup = mup + mkcoef(jd,i) * pmup

         ks = ks + mkcoef(jd,i) * pks
         mut = kst + mkcoef(jd,i) * pkst
         mup = ksp + mkcoef(jd,i) * pksp


      end do 

      end

      subroutine moduli (ids,mu,mut,mup,ks,kst,ksp,ok) 
c-----------------------------------------------------------------------
c subroutine moduli determines shear moduli (mods) for entity ids, returns
c ok = false if moduli are unavailable.

c jmod is the number of cpds for which it is possible to calculate coeffs.
c-----------------------------------------------------------------------
      implicit none
 
      include 'perplex_parameters.h'

      double precision mu, pmu, mut, pmut, mup, pmup, ks, ksp, kst,
     *                 pks, pksp, pkst

      integer i, ids

      logical ok
c                                 bookkeeping variables
      integer ksmod, ksite, kmsol, knsp
      common/ cxt0  /ksmod(h9),ksite(h9),kmsol(h9,m4,mst),knsp(m4,h9)

      integer lstot,mstot,nstot,ndep,nord
      common/ cxt25 /lstot(h9),mstot(h9),nstot(h9),ndep(h9),nord(h9)

      integer jend
      common/ cxt23 /jend(h9,k12)

      logical lorder, lexces, llaar, lrecip
      common/ cxt27 /lorder(h9),lexces(h9),llaar(h9),lrecip(h9)

      integer iemod,kmod
      logical smod,pmod
      double precision emod
      common/ cst319 /emod(k15,k10),smod(h9),pmod(k10),iemod(k10),kmod

      double precision z, pa, p0a, x, w, y
      common/ cxt7 /y(m4),z(m4),pa(m4),p0a(m4),x(mst,msp),w(m1)

      integer iopt
      logical lopt
      double precision nopt
      common/ opts /nopt(i10),iopt(i10),lopt(i10)
c-----------------------------------------------------------------------
  
      ok = .true.

      mu = 0d0
      mut = 0d0
      mup = 0d0

      ks = 0d0
      kst = 0d0
      ksp = 0d0

      if (ids.le.0) then 

         if (iemod(-ids).ne.0) then

            call shearm (mu,mut,mup,ks,kst,ksp,-ids)

         else

            ok = .false.

         end if 

      else 

         if (smod(ids)) then 

            if (lrecip(ids)) then
c                                 get the p0a coordinates (amounts of 
c                                 the independent disordered endmembers)     
               call getpp (ids) 

               do i = 1, lstot(ids)

                  call shearm (pmu,pmut,pmup,
     *                         pks,pkst,pksp,jend(ids,2+i))

                  mu = mu + p0a(i) * pmu
                  mut = mut + p0a(i) * pmut
                  mup = mup + p0a(i) * pmup

                  if (.not.pmod(ids)) cycle 

                  ks = ks + p0a(i) * pks
                  kst = kst + p0a(i) * pkst
                  ksp = ksp + p0a(i) * pksp

               end do

            else 

c                                 for solutions with no dependent endmembers
c                                 the y coordinates can be used to compute 
c                                 the composition. for speciation models
c                                 (ksmod = 6) this assumes xtoy has been 
c                                 called before moduli, so that y is the 
c                                 unspeciated composition (this will not be 
c                                 the case if gsol has been called, as might
c                                 happen if shearm calls gsol to evaluate a 
c                                 speciation model using stixrude's EoS).
               do i = 1, mstot(ids)

                  call shearm (pmu,pmut,pmup,
     *                         pks,pkst,pksp,jend(ids,2+i))

                  mu  = mu + y(i) * pmu
                  mut = mut + y(i) * pmut
                  mup = mup + y(i) * pmup

                  if (.not.pmod(ids)) cycle

                  ks  = ks + y(i) * pks
                  kst = kst + y(i) * pkst
                  ksp = ksp + y(i) * pksp

               end do
 
            end if 

            if (mu.lt.0d0) then 
               mu = nopt(7)
               ok = .false.
            end if 

            if (mut.gt.0d0) then 
               mut = nopt(7)
               ok = .false.
            end if

            if (mup.lt.0d0) then 
               mup = nopt(7)
               ok = .false.
            end if
       
         else

            ok = .false.

         end if 

      end if  

      end


      double precision function gfrnd (id)
c-----------------------------------------------------------------------
c function to get g's for frendly. differs from gphase in that it checks
c for special components O2, H2O, CO2. sloppy but who cares?
c-----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer id

      double precision gee, fo2, fs2

      integer iff,idss,ifug,ifyn,isyn
      common/ cst10 /iff(2),idss(h5),ifug,ifyn,isyn

      double precision fh2o,fco2
      common/ cst11 /fh2o,fco2

      integer idf
      double precision act
      common/ cst205 /act(k7),idf(3)

      double precision p,t,xco2,u1,u2,tr,pr,r,ps
      common/ cst5 /p,t,xco2,u1,u2,tr,pr,r,ps
c-----------------------------------------------------------------------
      call gphase (id,gee)

      gee = gee + r * t * dlog(act(id))

      if (ifyn.eq.0) then 
c                                 this is a quick fix that will
c                                 call the fluid routine way more 
c                                 than necessary.
         call cfluid (fo2,fs2)

         if (id.eq.idf(3)) then 

            gee = gee + r*t*fo2

         else if (id.eq.idf(1)) then 
        
            gee = gee + r*t*fh2o
         
         else if (id.eq.idf(2)) then 
        
            gee = gee + r*t*fco2

         end if
 
      end if 

      gfrnd = gee

      end 

      double precision function poiss (vp,vs)
 
      implicit none

      include 'perplex_parameters.h'

      double precision vp, vs

      integer iopt
      logical lopt
      double precision nopt
      common/ opts /nopt(i10),iopt(i10),lopt(i10)

      if (isnan(vp).or.isnan(vs)) then 
         poiss = nopt(7)
      else if (vs.eq.0d0) then 
         poiss = 0.5d0
      else 
         poiss =  0.5d0*((vp/vs)**2-2d0)/((vp/vs)**2-1d0)
      end if 

      end 

      subroutine getphp (id,jd,sick,ssick,ppois)
c-----------------------------------------------------------------------
c gets properties of phase id and saves them in props(1:i8,i); 
c if called by werami/meemum id is a general phase pointer; if 
c called by frendly id is an endmember pointer. 

c the properties are saved prop as follows

c 1  - molar volume
c 2  - molar enthalpy
c 3  - gruneisen thermal parm
c 4  - K_S
c 5  - Mu_S
c 6  - v_phi
c 7  - v_p
c 8  - v_s
c 9  - v_p/v_s
c 10 - rho
c 11 - G
c 12 - cp
c 13 - alpha
c 14 - beta
c 15 - S
c 16 - molar amount
c 17 - molar weight

c 18 - KS_T
c 19 - MuS_T
c 20 - KS_P
c 21 - MuS_P

c 22 - vphi_T
c 23 - vp_T
c 24 - vs_T
c 25 - vphi_P
c 26 - vs_P
c 27 - vp_P

c getphp computes isostatic props of the phase identified by id as 
c computed by centered finite differences from the Gibbs energy
c as stored in props(i8,jd)

c the difference increments are

c dt0, dp0 for 1st order derivatives (entropy,volume and enthalpy)
c dt1, dp1 for 2nd order derivatives (heat capacity, expansivity*, 
c          compressibility*)
c dt2, dp2 for 3rd order derivatives (gptt, gppt, gppp, gttt)
c          used for the T derivative of the bulk modulus. 

c *expansivity (alpha) as returned here is 1/v*dv/dt
c *compressibility (beta) as returned here is -1/v*dv/dp

c corrected to check for negative pressure, in which case 
c forward differences are used. june 22, 2004, JADC.
c----------------------------------------------------------------------

      implicit none

      include 'perplex_parameters.h'

      logical ok, sick(i8), ssick, pois, ppois, bulk

      integer id,jd,iwarn1,iwarn2,j,itemp,m

      double precision dt0,dt1,dt2,g0,g1a, g2a, dg, ss,alpha1,alpha2,
     *                 dp0,dp1,dp2,e,alpha,v,ginc,beta,cp,s,rho,gtt,r43,
     *                 g1,g2,g3,g4,g5,g7,gppp,gppt,gptt,gttt,mols,units,
     *                 root

      double precision props,psys,psys1,pgeo,pgeo1
      common/ cxt22 /props(i8,k5),psys(i8),psys1(i8),pgeo(i8),pgeo1(i8)

      double precision gtot,fbulk,gtot1,fbulk1
      common/ cxt81 /gtot,fbulk(k0),gtot1,fbulk1(k0)

      integer iopt
      logical lopt
      double precision nopt
      common/ opts /nopt(i10),iopt(i10),lopt(i10)

      double precision pcomp
      common/ cst324 /pcomp(k0,k5)

      character pname*14
      common/ cxt21a /pname(k5)

      logical gflu,aflu,fluid,shear,lflu,volume,rxn
      common/ cxt20 /gflu,aflu,fluid(k5),shear,lflu,volume,rxn

      integer iam
      common/ cst4 /iam

      double precision atwt
      common/ cst45 /atwt(k0)

      integer icomp,istct,iphct,icp
      common/ cst6  /icomp,istct,iphct,icp

      integer kkp, np, ncpd, ntot
      double precision cp3, amt
      common/ cxt15 /cp3(k0,k5),amt(k5),kkp(k5),np,ncpd,ntot

      double precision p,t,xco2,u1,u2,tr,pr,r,ps
      common/ cst5 /p,t,xco2,u1,u2,tr,pr,r,ps

      integer idr,ivct
      double precision vnu
      common/ cst25 /vnu(k7),idr(k7),ivct

      integer hs2p
      double precision hsb
      common/ cst84 /hsb(i8,4),hs2p(6)

      save dt0,dt1,dt2
      data dt0,dt1,dt2/0.5d0,5d0,5d1/

      save iwarn1, iwarn2
      data iwarn1, iwarn2 /2*0/
c----------------------------------------------------------------------
      sick(jd) = .false.
      pois = .false.
c                                 make name and composition, 
c                                 redundant for frendly
      call getnam (pname(jd),id)
c                                 composition, don't call if meemum
      if (iam.ne.2) call getcmp (jd,jd,id)
c                                 component counter for frendly is different
c                                 than for all other programs
      if (iam.ne.5) then 
         itemp = icomp
      else
         itemp = k0
      end if 
c                                 formula weight
      props(17,jd) = 0d0

      do j = 1, itemp
c                                 formula weight
         props(17,jd) = props(17,jd) + cp3(j,jd) * atwt(j) 
c                                 molar amounts of the components
         mols = props(16,jd)*cp3(j,jd)
c                                 mass of the components
         fbulk(j) = fbulk(j) + mols
         gtot = gtot + mols

         if (.not.fluid(jd)) then 
            fbulk1(j) = fbulk1(j) + mols
            gtot1 = gtot1 + mols
         end if 
c                                 molar phase composition
         pcomp(j,jd) = cp3(j,jd)

      end do
c                                 an entity with no mass signals that 
c                                 frendly is using a make definition
c                                 which corresponds to a balanced reaction
      if (gtot.eq.0d0) rxn = .true.

      if (iopt(2).eq.1) then 
c                                 convert molar phase composition to 
c                                 mass % composition:
         do j = 1, itemp
            pcomp(j,jd) = pcomp(j,jd)*atwt(j)*1d2/props(17,jd)
         end do  

      end if 
c                                 bulk modulus flag, if false use explicit form
      bulk = .true.
c                                 shear modulus
      if (.not.fluid(jd)) then 

         call moduli (id,props(5,jd),props(19,jd),props(21,jd),
     *                   props(4,jd),props(18,jd),props(20,jd),ok)

         if (.not.ok.and.iopt(16).eq.0) shear = .false.  
c                                 explicit bulk modulus is present and allowed
         if (lopt(17).and.props(4,jd).gt.0d0) bulk = .false.

      else

         props(5,jd)  = 0d0
         props(19,jd) = 0d0    
         props(21,jd) = 0d0

      end if   
c                                 compute g-derivatives for isostatic 
c                                 thermodynamic properties
      if (p.gt.1d3) then 
         dp2 = 5d-2 * p
      else 
         dp2 = 5d1
      end if 

      dp1 = dp2/1d1
      dp0 = dp1/1d1
            
      g0 = ginc(0d0,0d0,id)
c                                 straight derivatives:
c                                 first order
      if (p-dp2.le.0d0) then 

         v = (ginc(0d0,dp0,id) - g0)/dp0
         if (v.lt.0d0.or.dabs(v).gt.1d9)  
c                                 expand increment if invalid v
     *   v = (ginc(0d0,dp1,id) - g0)/dp1
         if (v.lt.0d0.or.dabs(v).gt.1d9)  
c                                 expand increment more if invalid v
     *   v = (ginc(0d0,dp2,id) - g0)/dp2

      else 

         v = (ginc(0d0,dp0,id) - ginc(0d0,-dp0,id))/dp0/2d0
         if ((v.lt.0d0.or.dabs(v).gt.1d9).and.p-dp1.gt.0d0)  
c                                 expand increment if invalid v
     *   v = (ginc(0d0,dp1,id) - ginc(0d0,-dp1,id))/dp1/2d0
         if ((v.lt.0d0.or.dabs(v).gt.1d9).and.p-dp2.gt.0d0)  
c                                 expand increment more if invalid v
     *   v = (ginc(0d0,dp2,id) - ginc(0d0,-dp2,id))/dp2/2d0

      end if 
c                                 in case the evaluating routine fails
c                                 on both calls to ginc 
      s = (ginc(-dt0,0d0,id) - ginc(dt0,0d0,id))/dt0/2d0
c                                 this crap is necessary because 
c                                 optimization or my bad programming
c                                 corrupts ginc with compaq visual fortran.
      g1a = ginc(-dt0,0d0,id)
      g2a =  ginc(dt0,0d0,id)
      dg = g1a-g2a
      ss = dg/dt0/2d0
      s = ss
c
c 
c     write (*,*) s, ss, dg, ginc(-dt0,0d0,id) - ginc(dt0,0d0,id), dt0

      e = g0 + t * s
c                                 second order
      gtt = (ginc(dt1,0d0,id) + ginc(-dt1,0d0,id) - 2d0*g0)/dt1/dt1
      cp = -t*gtt

      if (cp.lt.0d0.or.dabs(cp).gt.1d9)  
c                                 expand increment if invalid cp
     *   cp = -t*(ginc(dt2,0d0,id) + 
     *            ginc(-dt2,0d0,id) - 2d0*g0)/dt2/dt2

      if (cp.lt.0d0.or.dabs(cp).gt.1d9)  
c                                 shrink increment if invalid cp
     *   cp = -t*(ginc(dt0,0d0,id) + 
     *            ginc(-dt0,0d0,id) - 2d0*g0)/dt0/dt0

c                                 volumetric properties only if v is ok:
      if (v.gt.0d0) then 
   
         if (p-dp2.le.0d0) then 
c                                 use forward difference at small p's
            beta = (ginc(0d0,2d0*dp1,id) + g0 - 2d0*ginc(0d0,dp1,id))
     *             /dp1/dp1
            if (beta.lt.-v.or.beta.ge.0d0)
c                                 expand increment if invalid beta
     *      beta = (ginc(0d0,2d0*dp2,id) + g0 - 2d0*ginc(0d0,dp2,id))
     *             /dp2/dp2                                 
            if (beta.lt.-v.or.beta.ge.0d0)
c                                 shrink increment if invalid beta
     *      beta = (ginc(0d0,2d0*dp0,id) + g0 - 2d0*ginc(0d0,dp0,id))
     *             /dp0/dp0   

            alpha = ( ginc( dt1,dp1,id) - ginc( dt1,0d0,id)
     *               -ginc(-dt1,dp1,id) + ginc(-dt1,0d0,id))/dp1/dt1/2d0
            if (alpha.gt.v.or.alpha.le.0d0)
c                                 expand increment if invalid alpha
     *      alpha = ( ginc( dt2,dp2,id) - ginc( dt2,0d0,id)
     *               -ginc(-dt2,dp2,id) + ginc(-dt2,0d0,id))/dp2/dt2/2d0
            if (alpha.gt.v.or.alpha.le.0d0)
c                                 shrink increment if invalid alpha
     *      alpha = ( ginc( dt0,dp0,id) - ginc( dt0,0d0,id)
     *               -ginc(-dt0,dp0,id) + ginc(-dt0,0d0,id))/dp0/dt0/2d0

         else

            beta = (ginc(0d0,dp1,id) + ginc(0d0,-dp1,id) - 2d0*g0)
     *             /dp1/dp1
            if (beta.lt.-v.and.p-dp2.ge.0d0.or.beta.ge.0d0)
c                                 expand increment if invalid beta
     *      beta = (ginc(0d0,dp2,id) + ginc(0d0,-dp2,id) - 2d0*g0)
     *             /dp2/dp2
     
            if (beta.lt.-v.or.beta.ge.0d0)
c                                 shrink increment if invalid beta
     *         beta = (ginc(0d0,dp0,id) 
     *               + ginc(0d0,-dp0,id) - 2d0*g0)/dp0/dp0

            alpha = ( ginc( dt1,dp1,id) - ginc( dt1,-dp1,id)
     *            -ginc(-dt1,dp1,id) + ginc(-dt1,-dp1,id))/dp1/dt1/4d0

            if (alpha.gt.v.or.alpha.le.0d0) then 
c                                 expand increment if invalid alpha
               alpha1 = ( ginc( dt2,dp2,id) - ginc( dt2,-dp2,id)
     *                  - ginc(-dt2,dp2,id) 
     *                  + ginc(-dt2,-dp2,id))/dp2/dt2/4d0

               if (alpha1.gt.v.or.alpha1.le.0d0) then
c                                 shrink increment if invalid alpha
                  alpha2 = ( ginc( dt0,dp0,id) - ginc( dt0,-dp0,id)
     *                      -ginc(-dt0,dp0,id) + ginc(-dt0,-dp0,id))
     *                     /dp0/dt2/4d0

                  if (alpha2.lt.v.and.alpha2.ge.0d0) then 
                     alpha = alpha2
                  end if 

               else 

                  alpha = alpha1

               end if 
            end if      
     
         end if  
c                                 third order derivatives, only need for
c                                 derivatives of seismic props.
         if (p-2d0*dp2.le.0d0) then 

            g1 = ginc(-dt2,0d0,id)
            g2 = ginc( dt2,2d0*dp2,id)
            g3 = ginc( dt2,0d0,id)
            g4 = ginc(-dt2,2d0*dp2,id)
            g5 = ginc(0d0,dp2,id)
            g7 = g1 - g3

            gppp = ((ginc(0d0,4d0*dp2,id) - g0)/2d0
     *              - ginc(0d0,3d0*dp2,id) + g5)/dp2**3
            gppt = (g2 + g3 + 2d0*(ginc(-dt2, dp2,id)-ginc(dt2,dp2,id))
     *              -g4 - g1)/dp2/dp2/dt2/2d0
            gptt = (g2 + g4  + 2d0*(g0 - ginc(0d0,2d0*dp2,id))
     *              -g3 - g1)/2d0/dp2/dt2/dt2

         else 

            g1 = ginc(-dt2,-dp2,id) - ginc( dt2,dp2,id)
            g3 = ginc( dt2,-dp2,id)
            g4 = ginc(-dt2,dp2,id)
            g5 = ginc(0d0,dp2,id) - ginc(0d0,-dp2,id)
            g7 = ginc(-dt2,0d0,id) - ginc(dt2, 0d0,id)
   
            gppp = ((ginc(0d0,2d0*dp2,id) - ginc(0d0,-2d0*dp2,id))/2d0 
     *           - g5)/dp2**3
            gppt = (g3 - g4 + 2d0*g7 - g1)/dp2/dp2/dt2/2d0
            gptt = (g4 - g3 - 2d0*g5 - g1)/2d0/dp2/dt2/dt2
 
         end if 

         gttt = ((ginc(dt2*2d0,0d0,id) - ginc(-dt2*2d0,0d0,id))/2d0 
     *           + g7)/dt2**3

         g7 = (gtt*beta-alpha**2)**2

         if (g7.ne.0d0.and.bulk) then 
c                                 temperature derivative of the adiabatic bulk modulus:
            props(18,jd) = (((v*gppt-alpha*beta)*gtt
     *                      -(2d0*v*gptt-alpha**2)*alpha)*gtt
     *                      +v*gttt*alpha**2)/g7
c                                 pressure derivative of the adiabatic bulk modulus:
            props(20,jd) = (((v*gppp-beta**2)*gtt
     *                   +(alpha*beta-2d0*v*gppt)*alpha)*gtt
     *                   +v*gptt*alpha**2)/g7
         else if (bulk) then 

            props(18,jd) = nopt(7)
            props(20,jd) = nopt(7)

         end if 

      end if 
c                                 -------------------------------------
c                                 up to this point beta = d2g/dp2
c                                 and alpha = d2g/dp2 now convert 
c                                 to their normal forms:
      if (v.le.0d0) then 

         sick(jd) = .true.
         v = nopt(7)
         beta = nopt(7)
         alpha = nopt(7)
         rho = nopt(7)
      
      else 

         beta = -beta/v
         alpha = alpha/v
         rho = props(17,jd)/v*1d2

c                                 ideal gas beta = 1/p           
         if (beta.gt.v.or.beta.lt.0d0) then
            beta = nopt(7)
            sick(jd) = .true.
         end if
c                                 aug 28, 2007, removed check on alpha to 
c                                 accomodate -alpha's generated by landau 
c                                 transition models. ideal gas alpha = 1/t
         if (alpha.gt.v) then 
            alpha = nopt(7)
            sick(jd) = .true.
         end if 

      end if  

      if (cp.gt.1d9.or.cp.lt.0d0) then
         cp = nopt(7)
         sick(jd) = .true.
      end if 

      props(2,jd) = e
      props(11,jd) = g0 
      props(12,jd) = cp
      props(15,jd) = s
      props(1,jd) = v
      props(13,jd) = alpha
      props(14,jd) = beta 
      props(10,jd) = rho  

      if (.not.sick(jd).and..not.rxn) then
c                                 gruneisen parameter
         props(3,jd) = v/(cp*beta/alpha - t*alpha*v)
c                                 aug 28, 2007, removed check on gruneisen to 
c                                 accomodate -alpha's generated by landau 
c                                 transition models (prop(13,jd))
c        if (props(3,jd).le.0d0) sick(jd) = .true.

c                                 adiabatic bulk modulus
         if (bulk) props(4,jd) = (1d0 + t*alpha*props(3,jd))/beta

         if (props(4,jd).le.0d0) sick(jd) = .true.

         if (.not.fluid(jd).and.iopt(16).gt.0) then 
c                                 use poisson ratio estimates if iopt(16).ne.0
            if ((iopt(16).eq.1.and..not.ok).or.iopt(16).eq.2) then

               if (.not.sick(jd)) then
 
                  props(5,jd)  = nopt(16)*props(4,jd)
                  props(19,jd) = nopt(16)*props(18,jd) 
                  props(21,jd) = nopt(16)*props(20,jd)

                  if (iopt(16).eq.1) then 
                     ppois = .true.
                     pois = .true.
                  end if 

               else

                  shear = .false.
                  props(5,jd) = nopt(7)
                  props(19,jd) = nopt(7)    
                  props(21,jd) = nopt(7)

               end if 

            end if

         end if  

      end if 

      if (sick(jd)) then

         props(3,jd) = nopt(7)
         props(4,jd) = nopt(7)

         volume = .false.

         if (.not.fluid(jd).and..not.ok) shear = .false.

         if (.not.fluid(jd)) ssick = .true.

      end if 
c                                 seismic properties
      if (.not.sick(jd).and..not.rxn) then 

         units = dsqrt(1d5)/1d3
         r43   = 4d0/3d0
c                                 sound velocity
         root = props(4,jd)/rho
         props(6,jd) = dsqrt(root) * units
c                                 sound velocity T derivative
         props(22,jd) = (props(18,jd) + props(4,jd) * alpha) 
     *                  / dsqrt(root) / rho / 2d0 * units
c                                 sound velocity P derivative
         props(25,jd) = (props(20,jd) - props(4,jd) * beta) 
     *                  / dsqrt(root) / rho / 2d0 * units

c                                 p-wave velocity
         root = (props(4,jd)+r43*props(5,jd))/rho

         if (root.ge.0d0) then 

            props(7,jd) = dsqrt(root)*units
c                                 p-wave velocity T derivative
            props(23,jd) = (props(18,jd) + r43 * 
     *                     (props(19,jd) + alpha * props(5,jd)) 
     *                    + props(4,jd) * alpha) / 
     *                      dsqrt(root) / rho / 2d0 * units
c                                 p-wave velocity P derivative
            props(26,jd) = (props(20,jd) + r43 *
     *                     (props(21,jd) - beta * props(5,jd)) 
     *                    - props(4,jd) * beta) /
     *                      dsqrt(root) / rho / 2d0 * units

         else 

            props(7,jd) = nopt(7)
            props(23,jd) = nopt(7)
            props(26,jd) = nopt(7)
            shear = .false.

         end if 

         if (.not.fluid(jd)) then 
c                                 s-wave velocity
            root = props(5,jd)/rho

            if (root.gt.0d0) then 

               props(8,jd) = dsqrt(root)*units
               props(24,jd)= (props(19,jd) + props(5,jd) * alpha)
     *                     / dsqrt(root) / rho / 2d0 * units
               props(27,jd)= (props(21,jd) - props(5,jd) * beta)
     *                     / dsqrt(root) / rho / 2d0 * units
            else

               props(8,jd) = nopt(7)
               props(24,jd) = nopt(7)
               props(27,jd) = nopt(7)
               shear = .false.

            end if 
c                                 vp/vs
            if (isnan(props(8,jd))) then 
               props(9,jd) = nopt(7) 
            else if (props(8,jd).ne.0d0) then 
               props(9,jd) = props(7,jd)/props(8,jd)
            else
               props(9,jd) = nopt(7)
            end if 

         else 

            props(8,jd) = 0d0
            props(24,jd) = 0d0 
            props(27,jd) = 0d0 

         end if 

      else 

         do j = 3, 9
            props(j,jd) = nopt(7)
         end do 

      end if 
c                                 get min/max moduli for hashin-strikman
c                                 bounds. also saves the corresponding 
c                                 T and P derivatives.
      if (.not.lopt(16)) then
         do j = 1, 2
c                                 property index 
            m = hs2p(j)
            if (isnan(props(m,jd))) cycle 
c                                 min aggregate prop
            if (props(m,jd).lt.hsb(j,1)) then
               hsb(j,1) = props(m,jd)
               hsb(j+2,1) = props(hs2p(j+2),jd)
               hsb(j+4,1) = props(hs2p(j+4),jd)
            end if 
c                                 max aggregate prop
            if (props(m,jd).gt.hsb(j,2)) then
               hsb(j,2) = props(m,jd)
               hsb(j+2,2) = props(hs2p(j+2),jd)
               hsb(j+4,2) = props(hs2p(j+4),jd)
            end if 

            if (fluid(jd)) cycle 
c                                 min solid prop
            if (props(m,jd).lt.hsb(j,3)) then
               hsb(j,3) = props(m,jd)
               hsb(j+2,3) = props(hs2p(j+2),jd)
               hsb(j+4,3) = props(hs2p(j+4),jd)
            end if 
c                                 max solid prop
            if (props(m,jd).gt.hsb(j,4)) then
               hsb(j,4) = props(m,jd)
               hsb(j+2,4) = props(hs2p(j+2),jd)
               hsb(j+4,4) = props(hs2p(j+4),jd)
            end if 

         end do 
      end if 
c                                 check and warn if necessary for negative
c                                 expansivity
      if (.not.sick(jd)) then 

         if (alpha.le.0d0.and.iwarn1.lt.11) then

            write (*,1030) t,p,pname(jd)
            iwarn1 = iwarn1 + 1
            if (iwarn1.eq.11) call warn (49,r,179,'GETPHP') 
         end if 

      end if

      if (ppois.and.iwarn2.lt.11) then

         if (pois) then 
            iwarn2 = iwarn2 + 1
            write (*,1040) t,p,pname(jd)
         end if
 
         if (iwarn2.eq.11) call warn (49,r,178,'GETPHP')

      end if 
c                                 accumulate non-seismic totals 
      if (iam.ne.5) then
c                                 weighting factor for molar properties
         mols = props(16,jd)

      else 
c                                 if frendly use reaction coefficients
         mols = vnu(jd)

      end if 
c                                 vol of phase per mole of system
      v = v*mols
c                                 system molar volume
      psys(1)  = psys(1)  + v
c                                 molar enthalpy
      psys(2)  = psys(2)  + e*mols
c                                 gruneisen T
      psys(3)  = psys(3)  + props(3,jd)*v 
c                                 molar gibbs energy
      psys(11) = psys(11) + g0*mols 
c                                 molar heat capacity
      psys(12) = psys(12) + cp*mols 
c                                 expansivity
      psys(13) = psys(13) + alpha*v 
c                                 compressibility
      psys(14) = psys(14) + beta*v
c                                 molar entropy
      psys(15) = psys(15) + s*mols 
c                                 moles of assemblage
      psys(16) = psys(16) + mols
c                                 mass of assemblage 
      psys(17) = psys(17) + props(17,jd)*mols
c                                 solid only totals:
      if (.not.fluid(jd)) then 

         psys1(1)  = psys1(1)  + v
         psys1(2)  = psys1(2)  + e*mols 
         psys1(3)  = psys1(3)  + props(3,jd)*v 
         psys1(11) = psys1(11) + g0*mols 
         psys1(12) = psys1(12) + cp*mols 
         psys1(13) = psys1(13) + alpha*v 
         psys1(14) = psys1(14) + beta*v
         psys1(15) = psys1(15) + s*mols 
         psys1(16) = psys1(16) + mols
         psys1(17) = psys1(17) + props(17,jd)*mols

      end if 


1030  format (/,'**warning ver179** at T(K)=',g12.4,' P(bar)=',g12.4,1x,
     *        'the effective expansivity of: ',a,/,'is negative. ',
     *        'Most probably this is because of a Landau ordering ',
     *        'model. The Gruneisen',/,'thermal parameter and seismic',
     *        ' velocities for this phase should be considered ',
     *        'with caution.',/)

1040  format (/,'**warning ver178** at T(K)=',g12.4,' P(bar)=',g12.4,1x,
     *        'the shear modulus of: ',a,/,'is missing or invalid ',
     *        'and has been estimated from the default poisson ',
     *        'ratio ',/)

      end

      subroutine gtsysp (sick,ssick)
c-----------------------------------------------------------------------
c computes aggregate (system) properties from phase properties 
c obtained by prior calls to getphp
c-----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      logical sick(i8), ssick, solid, bad

      integer i, j, iwarn, m

      double precision chi, chi1, units, root, r43, k, g, v, vs

      double precision p,t,xco2,u1,u2,tr,pr,r,ps
      common/ cst5 /p,t,xco2,u1,u2,tr,pr,r,ps

      logical gflu,aflu,fluid,shear,lflu,volume,rxn
      common/ cxt20 /gflu,aflu,fluid(k5),shear,lflu,volume,rxn

      double precision props,psys,psys1,pgeo,pgeo1
      common/ cxt22 /props(i8,k5),psys(i8),psys1(i8),pgeo(i8),pgeo1(i8)

      character pname*14
      common/ cxt21a /pname(k5)

      integer hs2p
      double precision hsb
      common/ cst84 /hsb(i8,4),hs2p(6)

      integer iopt
      logical lopt
      double precision nopt
      common/ opts /nopt(i10),iopt(i10),lopt(i10)

      integer kkp, np, ncpd, ntot
      double precision cp3, amt
      common/ cxt15 /cp3(k0,k5),amt(k5),kkp(k5),np,ncpd,ntot

      save iwarn
      data iwarn/0/
c----------------------------------------------------------------------
c                                 check if volume is there, if not assume
c                                 things are really bad
      if (isnan(psys(1))) then 
     
         bad = .true.
 
      else if (psys(1).eq.0d0) then 

         bad = .true.

      else 

         bad = .false. 

      end if 

      if (bad) then 

         do i = 1, i8
            psys(i) = nopt(7)
            psys1(i) = nopt(7)
         end do

         return

      end if 

      if (.not.volume) shear = .false.
c                                 not so bad....
      units = dsqrt(1d5)/1d3
      r43   = 4d0/3d0
      solid = .true.
c                                 weighting used to compute average
c                                 moduli (and derivatives) from bounds:
c                                 chi = 1 -> fast bound 
c                                 chi = 0 -> slow bound 
      chi = nopt(6)
      chi1 = 1d0 - chi
c                                 hashin-shtrikman limiting values, set
c                                 in calphp. ony 4,5,18,19,20,21 are used
c                                 1 - min, 2 - max, 3 - min solid, 4 - max
c                                 solid. 
      if (.not.lopt(16)) then 
         do m = 1, 5, 2
            do i = 1, 4

               k = hsb(m,i)
               g = hsb(m+1,i)
               hsb(m,i)   = r43*g

               if (k.eq.0d0.and.g.eq.0d0) then 
                  hsb(m+1,i) = 0d0
               else 
                  hsb(m+1,i) = g*((9d0*k+8d0*g)/(k+2d0*g))/6d0
               end if 

            end do 
         end do 
      end if 
c                                 compute aggregate props:
c                                 density, kg/m3
      psys(10) = psys(17)/psys(1)*1d2
c                                 convert volumetrically weighted totals
c                                 to arithmetic means (for aseismic properties)
      do i = 13, 14
c                                 normalize volumetrically weighted alpha/beta
         psys(i) = psys(i)/psys(1)
         if (psys1(1).ne.0d0) psys1(i) = psys1(i)/psys1(1)
      end do 
c                                 gruneisen T
      psys(3) = psys(3)/psys(1)

      if (.not.isnan(psys1(3))) then 
         if (psys1(1).gt.0d0) then
            psys1(3) = psys1(3)/psys1(1)
            psys1(10) = psys1(17)/psys1(1)*1d2
         end if 
      end if 
c                                 if a reaction (frendly) return
      if (rxn) return
c                                 if not solid, don't compute solid only
c                                 properties
      if (psys1(1).le.0d0.or..not.aflu) then 
         solid = .false.
         aflu = .false.
      end if 
c                                 accumulate aggregate totals, some
c                                 totals may be incomplete if volume or 
c                                 shear is false for an individual phase
c                                 weighting scheme for seismic velocity
      do i = 1, ntot 
c                                 total volume fraction
         v = props(1,i)*props(16,i)/psys(1)
c                                 solid volume fraction
         if (.not.fluid(i).and.aflu) 
     *                    vs = props(1,i)*props(16,i)/psys1(1)
c                                 for elastic properties use
c                                 VRH if lopt(16), else HS
         if (lopt(16)) then 

            if (volume) then 

               do j = 1, 5, 2

                  m = hs2p(j)

                  if (props(m,i).eq.0d0) cycle 
c                                 Aggregate Bulk Modulus, T-derivative, P-derivative                                
                  psys(m) = psys(m) + v*props(m,i)
                  pgeo(m) = pgeo(m) + v/props(m,i)

               end do 

            end if 
c                                 aggregate shear props only if
c                                 shear mod is available for all phases.
            if (shear) then

               do j = 2, 6, 2

                  m = hs2p(j) 
                  if (props(m,i).eq.0d0) cycle 
c                                 Aggregate shear Modulus, T-derivative, P-derivative                                
                  psys(m) = psys(m) + v*props(m,i)
                  if (.not.aflu) pgeo(m) = pgeo(m) + v/props(m,i)

               end do 

            end if 

            if (aflu.and..not.fluid(i).and..not.ssick) then
c                                 assemblage includes fluid, solid only
c                                 totals:
               do j = 1, 5, 2

                  m = hs2p(j)

                  if (props(m,i).eq.0d0) cycle 
c                                 Aggregate Bulk Modulus, T-derivative, P-derivative                                
                  psys1(m) = psys1(m) + vs*props(m,i)
                  pgeo1(m) = pgeo1(m) + vs/props(m,i)

               end do 

            end if 

            if (aflu.and..not.fluid(i).and.shear) then
               
               do j = 2, 6, 2

                  m = hs2p(j)
                  if (props(m,i).eq.0d0) cycle 
c                                 Aggregate shear Modulus, T-derivative, P-derivative                                
                  psys1(m) = psys1(m) + vs*props(m,i)
                  pgeo1(m) = pgeo1(m) + vs/props(m,i)

               end do 

            end if 

         else 
c                                 HS sums: 
c                                 psys is used for upper bound
c                                 pgeo used for lower bound
            if (volume) then 
c                                 Aggregate bulk modulus, T-derivative, P-derivative 
               do j = 1, 5, 2

                  m = hs2p(j)

                  if (props(m,i).eq.0d0) cycle 
                  psys(m) = psys(m) + v/(props(m,i)+hsb(j,2))
                  pgeo(m) = pgeo(m) + v/(props(m,i)+hsb(j,1))

               end do 

            end if 

            if (shear) then 
c                                 Aggregate shear modulus, T-derivative, P-derivative 
               do j = 2, 6, 2

                  m = hs2p(j) 

                  if (props(m,i).eq.0d0) cycle 
                  psys(m) = psys(m) + v/(props(m,i)+hsb(j,2))
                  if (.not.aflu) pgeo(m) 
     *                              = pgeo(m) + v/(props(m,i)+hsb(j,1))

               end do 

            end if 

            if (aflu.and..not.fluid(i).and..not.ssick) then
c                                 assemblage includes fluid, solid only totals:
c                                 Aggregate bulk modulus, T-derivative, P-derivative 
               do j = 1, 5, 2

                  m = hs2p(j)

                  if (props(m,i).eq.0d0) cycle 
                  psys1(m) = psys1(m) + vs/(props(m,i)+hsb(j,4))
                  pgeo1(m) = pgeo1(m) + vs/(props(m,i)+hsb(j,3))

               end do 

            end if 

            if (aflu.and..not.fluid(i).and.shear) then
c                                 assemblage includes fluid, solid only totals:
c                                 Aggregate shear modulus, T-derivative, P-derivative 
               do j = 2, 6, 2

                  m = hs2p(j)

                  if (props(m,i).eq.0d0) cycle 
                  psys1(m) = psys1(m) + vs/(props(m,i)+hsb(j,4))
                  pgeo1(m) = pgeo1(m) + vs/(props(m,i)+hsb(j,3))

               end do 

            end if 

         end if 

      end do 
c                                 seismic moduli and derivatives
      do j = 1, 6
c                                 property index
         m = hs2p(j)
c                                 combine as VRH or HS means
         if (lopt(16)) then 
c                                 VRH
            psys(m) = chi*psys(m)
            if (pgeo(m).ne.0d0) psys(m) = psys(m)+chi1/pgeo(m) 
            psys1(m) = chi*psys1(m)
            if (pgeo1(m).ne.0d0) psys1(m) = psys1(m)+chi1/pgeo1(m) 

         else 
c                                 HS 
            if (psys(m).ne.0d0) psys(m) = 1d0/psys(m) 
            psys(m) = chi*(psys(m) - hsb(j,2))

            if (pgeo(m).ne.0d0) pgeo(m) = 1d0/pgeo(m)
            psys(m) = psys(m) + chi1*(pgeo(m) - hsb(j,1))

            if (psys1(m).ne.0d0) psys1(m) = 1d0/psys1(m) 
            psys1(m) = chi*(psys1(m) - hsb(j,4))

            if (pgeo1(m).ne.0d0) pgeo1(m) = 1d0/pgeo1(m)
            psys1(m) = psys1(m) + chi1*(pgeo1(m) - hsb(j,3))

         end if 
 
      end do 
c                                 ----------------------------------
c                                 aggregate velocities, aggregate 
      if (volume) then
c                                 sound velocity
         root = psys(4)/psys(10)

         if (root.gt.0d0) then 

            psys(6) = dsqrt(root) * units
c                                 sound velocity T derivative
            psys(22) = (psys(18) + psys(4) * psys(13)) 
     *                  / dsqrt(root) / psys(10) / 2d0 * units
c                                 sound velocity P derivative
            psys(25) = (psys(20) - psys(4) * psys(14)) 
     *                  / dsqrt(root) / psys(10) / 2d0 * units
         end if 

      else 
c                                 set missing data  
         psys(3)   = nopt(7)
         psys(4)   = nopt(7)
         psys(6)   = nopt(7)
         psys(18)  = nopt(7)
         psys(20)  = nopt(7)
         psys(22)  = nopt(7)
         psys(25)  = nopt(7)

      end if 

      if (shear) then 
c                                 s-wave velocity
         root = psys(5)/psys(10)

         if (root.gt.0d0) then 

            psys(8) = dsqrt(root) * units
c                                 T-derivative
            psys(24) = (psys(19) + psys(5) * psys(13)) 
     *                    / dsqrt(root) / psys(10) / 2d0 * units
c                                 P-derivative 
            psys(27) = (psys(21) - psys(5) * psys(14)) 
     *                    / dsqrt(root) / psys(10) / 2d0 * units

         end if 

      else 
c                                 set missing data
         psys(5)  = nopt(7)
         psys(8)  = nopt(7)
         psys(19) = nopt(7)
         psys(21) = nopt(7)
         psys(24) = nopt(7)
         psys(27) = nopt(7)

      end if 

      if (shear.and.volume) then 

         root = (psys(4)+r43*psys(5))/psys(10)

         if (root.gt.0d0) then 
c                                 p-wave velocity
            psys(7) = dsqrt(root)*units
c                                 p-wave velocity T derivative
            psys(23) = (psys(18) + r43*(psys(19) + psys(13) * psys(5)) 
     *                 + psys(4) * psys(13)) / 
     *                 dsqrt(root) / psys(10) / 2d0 * units
c                                 p-wave velocity P derivative
            psys(26) = (psys(20) + r43*(psys(21) - psys(14) * psys(5)) 
     *                 - psys(4) * psys(14)) /
     *                 dsqrt(root) / psys(10) / 2d0 * units

         end if 
c                                 vp/vs
         if (psys(8).gt.0d0) then 
            psys(9) = psys(7)/psys(8)
         else
            psys(9) = nopt(7)
         end if 

      else 
c                                 set missing data
         psys(7)  = nopt(7)
         psys(9)  = nopt(7)
         psys(23) = nopt(7)
         psys(26) = nopt(7)

      end if 
c                                 ----------------------------------
c                                 fluid-absent properties:
c                                 the psys1(1) condition is for the 
c                                 special case of a system consisting 
c                                 only of fluid. 
      if (solid.and..not.ssick) then 
c                                 fluid absent properties:
         root = psys1(4)/psys1(10)

         if (root.gt.0d0) then 
c                                 sound velocity
            psys1(6) = dsqrt(root) * units
c                                 sound velocity T derivative
            psys1(22) = (psys1(18) + psys1(4) * psys1(13)) 
     *                  / dsqrt(root) / psys(10) / 2d0 * units
c                                 sound velocity P derivative
            psys1(25) = (psys1(20) - psys1(4) * psys1(14)) 
     *                  / dsqrt(root) / psys1(10) / 2d0 * units
         end if

      else 
c                                 set missing data  
         psys1(3)  = nopt(7)
         psys1(4)  = nopt(7)
         psys1(6)  = nopt(7)
         psys1(18) = nopt(7)
         psys1(20) = nopt(7)
         psys1(22) = nopt(7)
         psys1(25) = nopt(7)

      end if 

      if (shear.and.solid) then 

         root = psys1(5)/psys1(10)

         if (root.gt.0d0) then 
c                                 s-wave velocity
            psys1(8) = dsqrt(root) * units
c                                 T-derivative
            psys1(24) = (psys1(19) + psys1(5) * psys1(13)) 
     *                 / dsqrt(root) / psys1(10) / 2d0 * units
c                                 P-derivative 
            psys1(27) = (psys1(21) - psys1(5) * psys1(14)) 
     *                 / dsqrt(root) / psys1(10) / 2d0 * units

         end if 

      else
c                                 set missing data
         psys1(5)  = nopt(7)
         psys1(8)  = nopt(7)
         psys1(19) = nopt(7)
         psys1(21) = nopt(7)
         psys1(24) = nopt(7)
         psys1(27) = nopt(7)

      end if 

      if (shear.and..not.ssick.and.solid) then

         root = (psys1(4)+r43*psys1(5))/psys1(10)

         if (root.gt.0d0) then 
c                                 p-wave velocity
            psys1(7) = dsqrt(root)*units
c                                 p-wave velocity T derivative
            psys1(23) = (psys1(18) + r43*(psys1(19) 
     *                 + psys1(13) * psys1(5)) 
     *                 + psys1(4) * psys1(13)) / 
     *                 dsqrt(root) / psys1(10) / 2d0 * units
c                                 p-wave velocity P derivative
            psys1(26) = (psys1(20) + r43*(psys1(21)
     *                 - psys1(14) * psys1(5)) 
     *                 - psys1(4) * psys1(14)) /
     *                 dsqrt(root) / psys1(10) / 2d0 * units
         end if 
c                                 vp/vs
         if (psys1(8).gt.0d0) then 
            psys1(9) = psys1(7)/psys1(8)
         else
            psys1(9) = nopt(7)
         end if 

      else 
c                                 set missing data
         psys1(7)  = nopt(7)
         psys1(9)  = nopt(7)
         psys1(23) = nopt(7)
         psys1(26) = nopt(7)
         
      end if 

      if ((.not.volume.or..not.shear).and.(iwarn.lt.11)) then

         iwarn = iwarn + 1

         if (.not.shear.and.volume) then
             write (*,1000) t,p
          else if (.not.volume) then 
            do i = 1, ntot
               if (sick(i)) write (*,1010) t,p,pname(i)
            end do 
         end if 

         if (iwarn.eq.11) call warn (49,r,177,'GETSYP') 
                  
      end if  

1000  format (/,'**warning ver177** at T(K)=',g12.4,' P(bar)=',g12.4,1x,
     *        'aggregate seismic properties',/,'cannot be computed ',
     *        'because of a missing/invalid shear modulus.',/)
1010  format (/,'**warning ver177** at T(K)=',g12.4,' P(bar)=',g12.4,1x,
     *        'aggregate seismic properties ',/,'cannot be computed ',
     *        'because of missing/invalid properties for: ',a,/)

      end 

      subroutine insysp (ssick,ppois)
c-----------------------------------------------------------------------
c insysp initializes system properties accumulated in getphp and gtsysp
c----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer i

      logical ssick,ppois

      logical gflu,aflu,fluid,shear,lflu,volume,rxn
      common/ cxt20 /gflu,aflu,fluid(k5),shear,lflu,volume,rxn

      double precision props,psys,psys1,pgeo,pgeo1
      common/ cxt22 /props(i8,k5),psys(i8),psys1(i8),pgeo(i8),pgeo1(i8)

      double precision gtot,fbulk,gtot1,fbulk1
      common/ cxt81 /gtot,fbulk(k0),gtot1,fbulk1(k0)

      integer icomp,istct,iphct,icp
      common/ cst6  /icomp,istct,iphct,icp

      integer hs2p
      double precision hsb
      common/ cst84 /hsb(i8,4),hs2p(6)
c----------------------------------------------------------------------
c                                 flags
      aflu = .false.
      shear = .true.
      volume = .true.
      ssick = .false.
      ppois = .false.
      rxn = .false.
c                                 initialize sums
      do i = 1, i8
         psys(i) = 0d0
         psys1(i) = 0d0
         pgeo(i) = 0d0 
         pgeo1(i) = 0d0
      end do 

c                                 initialize bulk properites
c                                 total mass
      gtot = 0d0
      gtot1 = 0d0

c                                 HS limiting moduli
      do i = 1, 6
         hsb(i,1) = 1d99
         hsb(i,2) = 0d0         
         hsb(i,3) = 1d99
         hsb(i,4) = 0d0 
      end do     

      do i = 1, icomp
c                                 total molar amounts
         fbulk(i) = 0d0
         fbulk1(i) = 0d0

      end do

      end 

      subroutine lpopt0 (idead)
c-----------------------------------------------------------------------
c lpopt0 - calls lp minimization after a call to initlp. lpopt0
c does the minimization, writes error messages if necessary.

c this is an utterly stupid formulation of the lp problem because i modified
c the lp code to impose the implicit constraint that phase amounts were between
c 0 and 1, but did not impose the constraint the sum of the amounts must be
c be 1 (which would be unwise in any case). this requires that compositions and
c g's must be normalized to the total number of moles (and therefore lots of 
c extra bookkeeping). 
c-----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer liw,lw,k,idead,inc

      parameter (liw=2*k1+3,lw=2*(k5+1)**2+7*k1+5*k5)  

      double precision ax(k5),x(k1),clamda(k1+k5),w(lw),oldt,oldp

      integer is(k1+k5),iw(liw)

      logical quit
c                                 options from perplex_option.dat
      integer iopt
      logical lopt
      double precision nopt
      common/ opts /nopt(i10),iopt(i10),lopt(i10)

      integer hcp,idv
      common/ cst52  /hcp,idv(k7)  

      double precision ctot
      common/ cst3  /ctot(k1)

      double precision g
      common/ cst2 /g(k1)

      integer jphct,istart
      common/ cst111 /jphct,istart

      double precision a,b,c
      common/ cst313 /a(k5,k1),b(k5),c(k1)

      integer icomp,istct,iphct,icp
      common/ cst6  /icomp,istct,iphct,icp  
c                                 solution model counter
      integer isoct
      common/ cst79 /isoct

      double precision p,t,xco2,u1,u2,tr,pr,r,ps
      common/ cst5 /p,t,xco2,u1,u2,tr,pr,r,ps

      logical usv
      integer pindex,tindex
      common/ cst54 /pindex,tindex,usv

      integer npt,jdv
      logical fulrnk
      double precision cptot,ctotal
      common/ cst78 /cptot(k5),ctotal,jdv(k19),npt,fulrnk

      save ax, x, clamda, w, is, iw
c-----------------------------------------------------------------------
      if (.not.usv) then 

         inc = istct - 1

         oldt = t

         oldp = p
c                                logarithmic_p option
         if (lopt(14)) p = 1d1**p
c                                t_stop option
         if (t.lt.nopt(12)) t = nopt(12)

         call gall

         do k = 1, jphct
            c(k) = g(k+inc)/ctot(k+inc)
         end do

      end if 
c                                 idead = -1 tells lpnag to save parameters
c                                 for subsequent warm starts
      idead = -1
c                                 optimize by nag
      call lpnag (jphct,hcp,a,k5,b,c,is,x,ax,
     *            clamda,iw,liw,w,lw,idead,l6,istart)

      if (idead.gt.0) then
c                                 look for severe errors                                            
         call lpwarn (idead,'LPOPT ')
c                                 on severe error do a cold start.
c                                 necessary?
         istart = 0

      else if (hcp.eq.1.or.iopt(10).eq.0.or.isoct.eq.0.or.usv) then 
c                                 no refinement, find the answer
         call yclos0 (x,is,jphct) 
c                                 final processing, .true. indicates static
         call rebulk (.true.)

      else
c                                 find discretization points
c                                 for refinement
         call yclos1 (clamda,x,is,jphct,quit)
c                                 returns quit if nothing to refine
         if (quit) then 
c                                 final processing, .true. indicates static
            call rebulk (.true.)

         else 
c                                 reoptimize with refinement
            call reopt (idead)
c                                 final processing, .false. indicates dynamic
            if (idead.eq.0) call rebulk (.false.) 

         end if 
         
      end if 
     
      t = oldt
      p = oldp

      end 

      subroutine reopt (idead)
c-----------------------------------------------------------------------
c reopt - given the results of an initial optimization for lpopt, reopt
c iteratively refines the solution by generating pseudocompounds in the
c neighborhood of the initial optimization.
c-----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer liw, lw, iter, iref, i, j, id, idead, ids, jstart, inc, 
     *        opt

      parameter (liw=2*k21+3,lw=2*(k5+1)**2+7*k21+5*k5)  

      double precision  ax(k5), x(k21), clamda(k21+k5), w(lw)

      integer is(k21+k5), iw(liw)
c                                 -------------------------------------
c                                 global variables
c                                 adaptive coordinates
      integer jphct
      double precision g2, cp2
      common/ cxt12 /g2(k21),cp2(k5,k21),jphct

      integer icomp,istct,iphct,icp
      common/ cst6  /icomp,istct,iphct,icp

      double precision xa,b,xc
      common/ cst313 /xa(k5,k1),b(k5),xc(k1)

      integer ikp
      common/ cst61 /ikp(k1)

      integer hkp,mkp
      common/ cst72 /hkp(k21),mkp(k19)

      double precision g
      common/ cst2  /g(k1)

      double precision cp
      common/ cst12 /cp(k5,k1)

      double precision ctot
      common/ cst3  /ctot(k1)
c                                 adaptive x(i,j) coordinates
      integer jcoct, jcoor, jkp
      double precision zcoor
      common/ cxt13 /zcoor(k20),jcoor(k21),jkp(k21),jcoct

      integer iopt
      logical lopt
      double precision nopt
      common/ opts /nopt(i10),iopt(i10),lopt(i10)

      integer lcoor,lkp
      double precision ycoor
      common/ cxt14 /ycoor(k22),lcoor(k19),lkp(k19)

      integer ipoint,imyn
      common/ cst60 /ipoint,imyn

      integer npt,jdv
      logical fulrnk
      double precision cptot,ctotal
      common/ cst78 /cptot(k5),ctotal,jdv(k19),npt,fulrnk
c-----------------------------------------------------------------------
c                                 the pseudocompounds to be refined
c                                 are identified in jdv(1..npt)
      iter = 1
      jphct = 0
      iref = 0 
      jcoct = 1
      inc = istct - 1
      opt = npt
c                                 --------------------------------------
c                                 first iteration
      do i = 1, npt

         id = jdv(i) + inc

         if (id.le.ipoint) then
c                                 the point is a true compound
            jphct = jphct + 1
c                                 jkp indicates which phase a point is associated with
            jkp(jphct) = -id
c                                 hkp indicates which refinement point
            hkp(jphct) = i

            g2(jphct) = g(id)/ctot(id)

            do j = 1, icp
               cp2(j,jphct) = cp(j,id)/ctot(id)
            end do 

         else 
c                                 the point is a pseudocompound, refine it
            call resub (i,id,ikp(id),iref,iter)

         end if
c                                 reset jdv in case of exit
         jdv(i) = jphct

      end do 

      if (iref.eq.0) return
 
      do 
c                                 iter is incremented before the operations,
c                                 i.e., on the nth iteration, iter is n+1
         iter = iter + 1
c                                 cold start
         jstart = 0 
c                                 set idead = 0 to prevent lpnag from
c                                 overwriting warm start parameters
         idead = 0 
c                                 do the optimization
         call lpnag (jphct,icp,cp2,k5,b,g2,is,x,ax,
     *               clamda,iw,liw,w,lw,idead,l6,jstart)
c                                 warn if severe error
         if (idead.gt.0) then

            call lpwarn (idead,'REOPT ')
            exit

         end if 
c                                 analyze solution, get refinement points
         call yclos2 (clamda,x,is,iter,opt)
c                                 save the id and compositions
c                                 of the refinement points, this
c                                 is necessary because resub rewrites
c                                 the xcoor array.
         call saver 

         if (iter.gt.iopt(10)) exit 

         jphct = 0 
         iref = 0 
         jcoct = 1
c                                 generate new pseudocompounds
         do i = 1, npt

            ids = lkp(i)

            if (ids.lt.0) then 
c                                 the point is a true compound
               jphct = jphct + 1
               jkp(jphct) = ids
               hkp(jphct) = mkp(i)
               ids = -ids
               g2(jphct) = g(ids)/ctot(ids)

               do j = 1, icp
                  cp2(j,jphct) = cp(j,ids)/ctot(ids)
               end do 

            else
c                                 the point is a pseudocompound 
               call resub (mkp(i),i,ids,iref,iter)

            end if
c                                 reset jdv in case of exit
            jdv(i) = i 

         end do 

      end do 

      end

      subroutine resub (jd,id,ids,iref,iter)
c----------------------------------------------------------------------
c subroutine to generate new pseudocompound compositions around the
c pseudocompound id of solution ids in iteration iter. ifst is the 
c pointer to the first pseudocompound of the solution ids and ilst
c points to the last. 
c----------------------------------------------------------------------
      implicit none 

      include 'perplex_parameters.h'
c                                 -------------------------------------
c                                 local variables
      logical bad

      double precision xxnc, ysum

      integer i, j, k, ids, id, jd, iter, kcoct, iref
c                                 -------------------------------------
c                                 functions
      double precision gsol1, ydinc
c                                 -------------------------------------
c                                 global variables:
c                                 adaptive g and compositions
      integer jphct
      double precision g2, cp2
      common/ cxt12 /g2(k21),cp2(k5,k21),jphct
c                                 adaptive z coordinates
      integer jcoct, jcoor, jkp
      double precision zcoor
      common/ cxt13 /zcoor(k20),jcoor(k21),jkp(k21),jcoct
c                                 working arrays
      double precision z, pa, p0a, x, w, y
      common/ cxt7 /y(m4),z(m4),pa(m4),p0a(m4),x(mst,msp),w(m1)
c                                 x coordinate description
      integer istg, ispg, imlt, imdg
      double precision xmng, xmxg, xncg, xmno, xmxo
      common/ cxt6r /xmng(h9,mst,msp),xmxg(h9,mst,msp),xncg(h9,mst,msp),
     *               xmno(h9,mst,msp),xmxo(h9,mst,msp)
      common/ cxt6i /istg(h9),ispg(h9,mst),imlt(h9,mst),imdg(ms1,mst,h9)
c                                 temporary subdivision limits:
      double precision wg,xmn,xmx,xnc
      integer iend,isub,imd,insp,ist,isp,isite,iterm,iord,istot,
     *        jstot,kstot
      common/ cst108 /wg(m1,m3),xmn(mst,msp),xmx(mst,msp),xnc(mst,msp),
     *      iend(m4),isub(m1,m2,2),imd(msp,mst),insp(m4),ist(mst),
     *      isp(mst),isite,iterm,iord,istot,jstot,kstot
c                                 coordinates output by subdiv
      double precision xy,yy
      integer ntot,npairs
      common/ cst86 /xy(mdim,k1),yy(ms1,mst,k1),ntot,npairs
c                                 max number of refinements for solution h9
      integer ncoor
      common/ cxt24 /ncoor(h9)

      integer ksmod, ksite, kmsol, knsp
      common/ cxt0  /ksmod(h9),ksite(h9),kmsol(h9,m4,mst),knsp(m4,h9)

      integer hkp,mkp
      common/ cst72 /hkp(k21),mkp(k19)
c                                 model type
      logical lorder, lexces, llaar, lrecip
      common/ cxt27 /lorder(h9),lexces(h9),llaar(h9),lrecip(h9)
c                                 option values
      integer iopt
      logical lopt
      double precision nopt
      common/ opts /nopt(i10),iopt(i10),lopt(i10)

      integer lstot,mstot,nstot,ndep,nord
      common/ cxt25 /lstot(h9),mstot(h9),nstot(h9),ndep(h9),nord(h9)

      integer ineg
      common/ cst91 /ineg(h9,m15)
c----------------------------------------------------------------------
      
      if (iter.eq.1) then
c                                first iteration id array points to 
c                                original compound arrays:
         call getolx (ids,id)

      else
c                                on subsequent iterations get the y's
c                                stored in the ycoor array by routine 
c                                saver, these are reindexed copies of the
c                                coordinates originally saved in zcoor
c                                below. 
         call getxy0 (ids,id)

      end if
c                                load the subdivision limits into
c                                temporary limit arrays:
      isite = istg(ids)
      
      do i = 1, isite

         isp(i) = ispg(ids,i)

         do j = 1, isp(i) - 1

            imd(j,i) = imdg(j,i,ids)

            xxnc = nopt(14)*xncg(ids,i,j)/iopt(11)**(iter-1)

            if (imd(j,i).eq.0) then 
c                                 cartesian
               xmn(i,j) = x(i,j) - xxnc
               xmx(i,j) = x(i,j) + xxnc

            else
c                                 conformal
               xmn(i,j) = ydinc (x(i,j),-xxnc,imd(j,i),j,i,ids)
               xmx(i,j) = ydinc (x(i,j),xxnc,imd(j,i),j,i,ids)

            end if 

            xnc(i,j) = 2d0*nopt(14)*xncg(ids,i,j)/iopt(11)**iter
            if (xmn(i,j).lt.xmng(ids,i,j)) xmn(i,j) = xmng(ids,i,j)
            if (xmx(i,j).gt.xmxg(ids,i,j)) xmx(i,j) = xmxg(ids,i,j)

         end do 
      end do 
                            
c     call subdv1 ('characters',ids) 
      call subdiv ('characters',ids)

      do 10 i = 1, ntot 

         jphct = jphct + 1
         if (jphct.gt.k21) call error (58,x(1,1),k21,'resub')
c                                 convert to compositional corrdinates 
c                                 required by routine gsol, y coordinates
c                                 are placed in first array of cxt7,
c                                 store a copy of x coordinates in 
c                                 1-d array zcoor
         jkp(jphct) = ids
         hkp(jphct) = jd
         jcoor(jphct) = jcoct - 1
         kcoct = jcoct + ncoor(ids)
c                                 counter for number of non 0 or 1 compositions

         if (kcoct.gt.k20) call error (59,x(1,1),k20,'resub')

         do j = 1, isite
            ysum = 0d0
            do k = 1, isp(j) - 1
               x(j,k) = yy(k,j,i)
               ysum = ysum + x(j,k)
               zcoor(jcoct) = x(j,k)

               if (x(j,k).lt.xmno(ids,j,k).and.
     *             x(j,k).gt.xmxo(ids,j,k)) then 
c                                 the composition is out of range
                  jphct = jphct - 1
                  jcoct = kcoct - ncoor(ids)
                  goto 10
               end if 
               jcoct = jcoct + 1
            end do 
            x(j,isp(j)) = 1d0 - ysum
            zcoor(jcoct) = x(j,isp(j))
            jcoct = jcoct + 1
         end do 

         call xtoy (ids)

         if (ksmod(ids).eq.5) then
c                                 this is an el cheapo filter for redundant
c                                 compositions, a better method would be to
c                                 do the subdivision properly.
            bad = .false.

            do j = 1, ndep(ids)

               if (y(knsp(lstot(ids)+j,ids)).gt.0d0.and.
     *             y(knsp(lstot(ids)+j,ids)).le.y(ineg(ids,j))) then
c                                 reject composition 
                  jphct = jphct - 1
                  jcoct = kcoct - ncoor(ids)
                  bad = .true. 
                  exit 

               end if 

            end do 
      
            if (bad) cycle 

         end if 


c                                 call gsol to get g of the solution, gsol also
c                                 computes the p compositional coordinates
         g2(jphct) = gsol1(ids)
c                                 this is to check for invalid site fractions
c                                 arising from h&p's equipartition models.
c                                 this is redundant with the z calculations 
c                                 made in gsol1, but to avoid modifying the code
c                                 the test is repeated here, the test will be 
c                                 obsolete once equipartition is phased out.
         if (lopt(5).and.lrecip(ids)) then 
c                                 check for invalid site fractions, this is only necessary
c                                 for H&P models that assume equipartition (which is not 
c                                 implemented). 
            call zchk (pa,ids,bad)

            if (bad) then
               jphct = jphct - 1
               jcoct = jcoct - ncoor(ids)
               cycle
            end if 

         end if 
c                                 use the coordinates to compute the composition 
c                                 of the solution
         call csol (ids)

         iref = iref + 1
     
10    continue  

      end 

      subroutine csol (id)
c-----------------------------------------------------------------------
c csol computes chemical composition of solution id from the macroscopic
c endmember fraction array y or p0a (cxt7), these arrays are prepared by a prior
c call to function gsol. the composition is loaded into the array cp2 at
c position jphct.
c-----------------------------------------------------------------------
      implicit none
 
      include 'perplex_parameters.h'

      integer i,j,id

      double precision ctot2
c                                 -------------------------------------
c                                 global variables:
      integer icomp,istct,iphct,icp
      common/ cst6  /icomp,istct,iphct,icp

      double precision cp
      common/ cst12 /cp(k5,k1)

      double precision ctot
      common/ cst3  /ctot(k1)
c                                 adaptive coordinates
      integer jphct
      double precision g2, cp2
      common/ cxt12 /g2(k21),cp2(k5,k21),jphct
c                                 bookkeeping variables
      integer ksmod, ksite, kmsol, knsp
      common/ cxt0  /ksmod(h9),ksite(h9),kmsol(h9,m4,mst),knsp(m4,h9)
c                                 working arrays
      double precision z, pa, p0a, x, w, y
      common/ cxt7 /y(m4),z(m4),pa(m4),p0a(m4),x(mst,msp),w(m1)

      integer jend
      common/ cxt23 /jend(h9,k12)

      logical lorder, lexces, llaar, lrecip
      common/ cxt27 /lorder(h9),lexces(h9),llaar(h9),lrecip(h9)

      integer lstot,mstot,nstot,ndep,nord
      common/ cxt25 /lstot(h9),mstot(h9),nstot(h9),ndep(h9),nord(h9)
c----------------------------------------------------------------------

      ctot2 = 0d0

      do i = 1, icp
         cp2(i,jphct) = 0d0
      end do  

      if (lrecip(id).or.lorder(id)) then 
c                                 solutions with dependent endmembers, p0a 
c                                 contains the p's. for ksmod=8 these are a 
c                                 reformulation of the p's to eliminate the ordered 
c                                 endmembers. p0a is constructed in function gsol.
         do i = 1, lstot(id) 
            do j = 1, icp 
               cp2(j,jphct) = cp2(j,jphct) + p0a(i) * cp(j,jend(id,2+i))
            end do 
            ctot2 = ctot2 + p0a(i)*ctot(jend(id,2+i))
         end do 

      else 
c                                 general case (y coordinates)
         do i = 1, mstot(id)

            do j = 1, icp 
               cp2(j,jphct) = cp2(j,jphct) + y(i) * cp(j,jend(id,2+i))
            end do

            ctot2 = ctot2 + y(i)*ctot(jend(id,2+i)) 

         end do 
         
      end if 
c                                  normalize the composition and free energy
      g2(jphct) = g2(jphct)/ctot2

      do j = 1, icp 
         cp2(j,jphct) = cp2(j,jphct)/ctot2
      end do  

      end 

      subroutine sortin 
c-----------------------------------------------------------------------
c sort the first npt values of jdv
c-----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer i, j, imin

      integer npt,jdv
      logical fulrnk
      double precision cptot,ctotal
      common/ cst78 /cptot(k5),ctotal,jdv(k19),npt,fulrnk

      do j = 1, npt-1

         imin = jdv(j)

         do i = j+1, npt

            if (jdv(i).lt.imin) then 
               imin = jdv(i)
               jdv(i) = jdv(j)
               jdv(j) = imin
            end if
 
         end do 

      end do 

      end 

      subroutine lpwarn (idead,char)
c----------------------------------------------------------------------
c write warning messages from lpnag as called by routine 'char',
c set flags ier and idead, the optimization is a total fail if
c idead set to 1.
c----------------------------------------------------------------------
      implicit none

      integer idead, iwarn91, iwarn42, iwarn90

      character*6 char     

      double precision c

      save iwarn91, iwarn42, iwarn90

      data iwarn91, iwarn42, iwarn90/0,0,0/
c----------------------------------------------------------------------
c                                             look for errors                                            
      if (idead.eq.2.or.idead.gt.4.and.iwarn91.lt.6) then 
c                                             unbounded solution, or
c                                             other programming error.
         call warn (91,c,idead,char) 
         iwarn91 = iwarn91 + 1
         if (iwarn91.eq.5) call warn (49,c,91,'LPWARN')

      else if (idead.eq.3.and.iwarn42.lt.6) then 
c                                             no feasible solution
         call warn (42,c,idead,char)
         iwarn42 = iwarn42 + 1
         if (iwarn42.eq.5) call warn (49,c,42,'LPWARN')

      else if (idead.eq.4.and.iwarn90.lt.6) then 
c                                             iteration count exceeded,
c                                             probable cause no feasible
c                                             solution.
         call warn (90,c,idead,char) 
         iwarn90 = iwarn90 + 1
         if (iwarn90.eq.5) call warn (49,c,90,'LPWARN')

      end if

      end 

      subroutine saver 
c----------------------------------------------------------------------
c subroutine to save a copy of adaptive pseudocompound x(i,j) compositions
c in the temporary array ycoor (also lcoor) used by resub to generate
c the new zcoor array for the subsequent iteration.  
c----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'
c                                 -------------------------------------
c                                 local variables
      integer i, j, k, kcoct, id, ids, itic
c                                 -------------------------------------
c                                 global variables:
c                                 adaptive z coordinates
      integer jcoct, jcoor, jkp
      double precision zcoor
      common/ cxt13 /zcoor(k20),jcoor(k21),jkp(k21),jcoct
c                                 interim storage array
      integer lcoor,lkp
      double precision ycoor
      common/ cxt14 /ycoor(k22),lcoor(k19),lkp(k19)
c                                 x coordinate description
      integer istg, ispg, imlt, imdg
      common/ cxt6i /istg(h9),ispg(h9,mst),imlt(h9,mst),imdg(ms1,mst,h9)

      integer npt,jdv
      logical fulrnk
      double precision cptot,ctotal
      common/ cst78 /cptot(k5),ctotal,jdv(k19),npt,fulrnk
c----------------------------------------------------------------------
      kcoct = 0

      do i = 1, npt

         id = jdv(i)
         ids = jkp(id)
         lkp(i) = ids
c                                 cycle on a compound
         if (ids.lt.0) cycle
c                                 it's a solution:
         lcoor(i) = kcoct
         itic = 0

         do j = 1, istg(ids)
            do k = 1, ispg(ids,j)
               itic = itic + 1
               if (kcoct+itic.gt.k22) 
     *             call error (60,ycoor(1),k22,'saver')
               ycoor(lcoor(i)+itic) = zcoor(jcoor(id)+itic)
            end do 
         end do 

         kcoct = kcoct + itic

      end do 

      end 

      subroutine getxz (jd,id,ids)
c----------------------------------------------------------------------
c subroutine to recover geometric reciprocal solution compositions (x(i,j))
c from the zcoor array loaded in resub.
c----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer i, j, jd, id, ids, icoor
c                                 working arrays
      double precision z, pa, p0a, x, w, y
      common/ cxt7 /y(m4),z(m4),pa(m4),p0a(m4),x(mst,msp),w(m1)
c                                 x coordinate description
      integer istg, ispg, imlt, imdg
      common/ cxt6i /istg(h9),ispg(h9,mst),imlt(h9,mst),imdg(ms1,mst,h9)
c                                 adaptive x(i,j) coordinates
      integer jcoct, jcoor, jkp
      double precision zcoor
      common/ cxt13 /zcoor(k20),jcoor(k21),jkp(k21),jcoct
c                                  xcoordinates for the final solution
      double precision x3
      common/ cxt16 /x3(k21,mst,msp)
c----------------------------------------------------------------------
      icoor = jcoor(id)

      do i = 1, istg(ids)
         do j = 1, ispg(ids,i)
            icoor = icoor + 1
            x(i,j) = zcoor(icoor)
            x3(jd,i,j) = x(i,j)
         end do 
      end do 

      end 

      subroutine getxy0 (ids,id)
c----------------------------------------------------------------------
c subroutine to recover geometric reciprocal solution compositions (x(i,j))
c from the ycoor array loaded in saver
c----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer i, j, id, ids, jcoor
c                                 working arrays
      double precision z, pa, p0a, x, w, y
      common/ cxt7 /y(m4),z(m4),pa(m4),p0a(m4),x(mst,msp),w(m1)
c                                 x coordinate description
      integer istg, ispg, imlt, imdg
      common/ cxt6i /istg(h9),ispg(h9,mst),imlt(h9,mst),imdg(ms1,mst,h9)
c                                 interim storage array
      integer lcoor,lkp
      double precision ycoor
      common/ cxt14 /ycoor(k22),lcoor(k19),lkp(k19)
c----------------------------------------------------------------------
      jcoor = lcoor(id)

      do i = 1, istg(ids)
         do j = 1, ispg(ids,i)
            jcoor = jcoor + 1
            x(i,j) = ycoor(jcoor)
         end do 
      end do 

      end 

      logical function solvs1 (id1,id2,ids)
c-----------------------------------------------------------------------
c function to test if a solvus separates two pseudocompounds of solution
c ids, called only for final solution vales by avrger.
c-----------------------------------------------------------------------
      implicit none
 
      include 'perplex_parameters.h'

      integer i, id1, id2, ids

      integer icomp,istct,iphct,icp
      common/ cst6  /icomp,istct,iphct,icp

      double precision dcp,soltol
      common/ cst57 /dcp(k5,h8),soltol

      integer iopt
      logical lopt
      double precision nopt
      common/ opts /nopt(i10),iopt(i10),lopt(i10)
c                                 composition and model flags
c                                 for final adaptive solution
      integer kkp,np,ncpd,ntot
      double precision cp3, amt
      common/ cxt15 /cp3(k0,k5),amt(k5),kkp(k5),np,ncpd,ntot
c-----------------------------------------------------------------------
      solvs1 = .false.

      do i = 1, icp

         if (dcp(i,ids).eq.0d0) cycle 

         if (dabs(cp3(i,id1) - cp3(i,id2))/dcp(i,ids).gt.soltol) then 
            solvs1 = .true.
            exit 
         end if 
      end do 

      end 

      logical function solvs2 (id1,id2)
c-----------------------------------------------------------------------
c function to test if a solvus separates two pseudocompounds of solution
c ids, intermediate solution values. 
c-----------------------------------------------------------------------
      implicit none
 
      include 'perplex_parameters.h'

      integer id1,id2,i

      integer icomp,iphct,icp,istct
      common/ cst6 /icomp,istct,iphct,icp

      double precision dcp,soltol
      common/ cst57 /dcp(k5,h8),soltol

      integer jphct
      double precision g2, cp2
      common/ cxt12 /g2(k21),cp2(k5,k21),jphct
c-----------------------------------------------------------------------
      solvs2 = .false.

      do i = 1, icp

         if (dabs(cp2(i,id1) - cp2(i,id2)).gt.soltol) then
            solvs2 = .true.
            exit
         end if  

      end do 

      end 

      subroutine avrger 
c----------------------------------------------------------------------
c avrger combines discretization points into a single solution
c composition. on output

c     np  - is the number of solutions, 
c     ncpd - is the number of true compounds
c     ntot - np+ncpd

c this routine is unecessarily complicated, because it assumes
c pseudocompounds are not ordered by solution (but they are
c----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      logical solvs1, check
c                                 -------------------------------------
c                                 local variables
      integer idsol(k5),kdsol(k5,k5),ids,isite,xidsol,xkdsol,irep,
     *        i,j,jdsol(k5,k5),jd,k,l,nkp(k5),xjdsol(k5)

      double precision bsol(k5,k5),cpnew(k5,k5),xx,xb(k5), 
     *                 bnew(k5),xnew(k21,mst,msp)
c                                 -------------------------------------
c                                 global variables:
c                                 x coordinate description
      integer istg, ispg, imlt, imdg
      common/ cxt6i /istg(h9),ispg(h9,mst),imlt(h9,mst),imdg(ms1,mst,h9)

      integer icomp,istct,iphct,icp
      common/ cst6  /icomp,istct,iphct,icp

      double precision dcp,soltol
      common/ cst57 /dcp(k5,h8),soltol
c                                 composition and model flags
c                                 for final adaptive solution
      integer kkp, np, ncpd, ntot
      double precision cp3, amt
      common/ cxt15 /cp3(k0,k5),amt(k5),kkp(k5),np,ncpd,ntot
c                                  x-coordinates for the final solution
      double precision x3
      common/ cxt16 /x3(k21,mst,msp)

      integer ikp
      common/ cst61 /ikp(k1)

      double precision cp
      common/ cst12 /cp(k5,k1)

      integer iopt
      logical lopt
      double precision nopt
      common/ opts /nopt(i10),iopt(i10),lopt(i10)

      double precision z, pa, p0a, x, w, y
      common/ cxt7 /y(m4),z(m4),pa(m4),p0a(m4),x(mst,msp),w(m1)

      integer npt,jdv
      logical fulrnk
      double precision cptot,ctotal
      common/ cst78 /cptot(k5),ctotal,jdv(k19),npt,fulrnk

      logical usv
      integer pindex,tindex
      common/ cst54 /pindex,tindex,usv
c-----------------------------------------------------------------------
c                                first check if solution endmembers are
c                                among the stable compounds:
      do i = 1, ntot
         if (kkp(i).lt.0) then 
            if (ikp(-kkp(i)).ne.0) then 
c                                we have an endmember
               nkp(i) = ikp(-kkp(i))
            else
               nkp(i) = kkp(i)
            end if 
         else 
            nkp(i) = kkp(i)
         end if 
      end do 
c                                check if any solutions
      do i = 1, ntot
         if (nkp(i).gt.0) goto 10
      end do 

      if (usv) then 
         do i = 1, ntot
            do j = i+1, ntot
               if (nkp(i).eq.nkp(j)) goto 10 
            end do 
         end do
      end if 

      np = 0
      ncpd = ntot

      goto 99
c                                figure out how many solutions
c                                are present:
10    np = 0
      ncpd = 0
c                                set solvus tolerance, avrger (was 1.5)
      if (lopt(9)) then 
         soltol = 1.5d0*nopt(8)
      else 
         soltol = nopt(8)
      end if 

      do 30 i = 1, ntot
         if (nkp(i).lt.0) then
c                                 the pseudocompound is a true compound
            ncpd = ncpd + 1 
            idsol(ntot) = ncpd
            bsol(ntot,ncpd) = amt(i)
            kdsol(ntot,ncpd) = nkp(i)       
            jdsol(ntot,ncpd) = i   
         else 
            do j = 1, np
c                                 compare the compound to the np solutions 
c                                 identfied so far:        
               if (kdsol(j,1).eq.nkp(i)) then 
c                                 if match check for a solvus
                  if (.not.solvs1(i,jdsol(j,idsol(j)),nkp(i))) then
c                                 the pseudocompound matches a solution
c                                 found earlier.
                     idsol(j) = idsol(j) + 1
                     bsol(j,idsol(j)) = amt(i)
                     jdsol(j,idsol(j)) = i  
                     goto 30 
                  end if 
               end if 
            end do
c                                 the pseudocompound is a new solution 
c                                 phase.
            np = np + 1
            idsol(np) = 1
            kdsol(np,1) = nkp(i)
            jdsol(np,1) = i 
            bsol(np,1) = amt(i)

         end if    
30    continue  
c                                 check if a solution occurs more than once
c                                 but the occurences are not sequential (this
c                                 can only occur if an endmember is immiscible 
c                                 with a general composition
      if (np.gt.2) then
 
         do i = 1, np

            check = .false.
            irep = 0

            do j = i+1, np
               if (kdsol(j,1).ne.kdsol(i,1)) then
                  check = .true.
               else 
                  irep = irep + 1
               end if 
            end do 

            if (check.and.irep.gt.0) then 

               l = i + 1

               if (kdsol(l,1).ne.kdsol(i,1)) then 
c                                 not in sequence, find the next occurence
                  do j = i+2, np 
                     if (kdsol(i,1).eq.kdsol(j,1)) exit
                  end do 
c                                 swap phase at i+1 with the one at j
                  xidsol = idsol(l)
                  xkdsol = kdsol(l,1)
                  do k = 1, xidsol
                     xb(k) = bsol(l,k)
                     xjdsol(k) = jdsol(l,k)
                  end do 

                  idsol(l) = idsol(j)
                  kdsol(l,1) = kdsol(j,1)
                  do k = 1, idsol(j)
                     bsol(l,k) = bsol(j,k)
                     jdsol(l,k) = jdsol(j,k)
                  end do 

                  idsol(j) = xidsol
                  kdsol(j,1) = xkdsol
                  do k = 1, xidsol
                     bsol(j,k) = xb(k)
                     jdsol(j,k) = xjdsol(k)
                  end do 

               end if 
            end if 
         end do 
      end if 
c                                 if a solution is represented by
c                                 more than one pseudocompound get
c                                 the everage composition
      do i = 1, np 
c                                 initialize
         bnew(i) = 0d0

         do j = 1, icomp
            cpnew(j,i) = 0d0
         end do 

         ids = kdsol(i,1)
         isite = istg(ids)

         do j = 1, isite
            do k = 1, ispg(ids,j)
               xnew(i,j,k) = 0d0
            end do 
         end do 

         do j = 1, idsol(i)
            bnew(i) = bnew(i) + amt(jdsol(i,j))
         end do 

         do j = 1, idsol(i)

            jd = jdsol(i,j)
c                                conditional in case zero mode
c                                is off:
            if (bnew(i).gt.0d0) then 

               xx =  amt(jd)/bnew(i)
c                                save the new compositions
               do k = 1, icomp
                  cpnew(k,i) = cpnew(k,i) + xx*cp3(k,jd)
               end do 

               do k = 1, isite
                  do l = 1, ispg(ids,k)
                     xnew(i,k,l) = xnew(i,k,l) + xx*x3(jd,k,l)
                  end do 
               end do 
            
            else 
c                               
               do k = 1, icomp
                  cpnew(k,i) = cp3(k,jd)
               end do 

               do k = 1, isite
                  do l = 1, ispg(ids,k)
                     xnew(i,k,l) = x3(jd,k,l)
                  end do 
               end do 

            end if 

         end do 

      end do
c                                now reform the arrays kdv and b
      do i = 1, np

         amt(i) = bnew(i)
         kkp(i) = kdsol(i,1)
         ids = kkp(i)

         do j = 1, icomp
            cp3(j,i) = cpnew(j,i)
         end do

         do j = 1, istg(ids)
            do k = 1, ispg(ids,j)
c                                 set x's for sollim
               x(j,k) = xnew(i,j,k)
c                                 set x's for global storage
               x3(i,j,k) = x(j,k) 

            end do 
         end do 
c                                 check composition against solution model ranges
c                                 if auto_refine is on:
         call sollim (ids)

      end do

      if (.not.usv) then 

         do i = 1, ncpd
            k = np + i
            l = kdsol(ntot,i)
            amt(k) = bsol(ntot,i)
            kkp(k) = l
c                                for the sake of completeness load
c                                compound composition into cp3 array
            do j = 1, icomp
               cp3(j,k) = cp(j,-l)
            end do 
         end do
 
      else 

         irep = 1
         idsol(1) = kdsol(ntot,1)

         do i = 2, ncpd

            check = .false.

            do j = 1, irep

               if (kdsol(ntot,i).eq.idsol(j)) then 
                  check = .true.
                  exit 
               end if 
               
               if (check) exit

            end do 

            if (.not.check) then 
               irep = irep + 1
               idsol(irep) = kdsol(ntot,i)
            end if 
             
         end do 
         
         do i = 1, irep

            k = np + i
            l = idsol(i)

            do j = 1, ncpd
               if (kdsol(ntot,j).eq.l) amt(k) = amt(k) + bsol(ntot,j)
            end do 

            amt(k) = bsol(ntot,i)
            kkp(k) = l
c                                for the sake of completeness load
c                                compound composition into cp3 array
            do j = 1, icomp
               cp3(j,k) = cp(j,-l)
            end do 
         end do 

         ncpd = irep

      end if 

      ntot = np + ncpd

99    end 

      subroutine sollim (ids)
c----------------------------------------------------------------------
c subroutine to extract compositional range of endmembers in stable phases
c for auto_refine option.
c----------------------------------------------------------------------
      implicit none 

      include 'perplex_parameters.h'

      integer ids,i,j

      double precision z, pa, p0a, x, w, y
      common/ cxt7 /y(m4),z(m4),pa(m4),p0a(m4),x(mst,msp),w(m1)
c                                 x coordinate description
      integer istg, ispg, imlt, imdg
      double precision xmng, xmxg, xncg, xmno, xmxo
      common/ cxt6r /xmng(h9,mst,msp),xmxg(h9,mst,msp),xncg(h9,mst,msp),
     *               xmno(h9,mst,msp),xmxo(h9,mst,msp)
      common/ cxt6i /istg(h9),ispg(h9,mst),imlt(h9,mst),imdg(ms1,mst,h9)
c                                 solution limits and stability
      logical stable,limit,relax
      double precision xlo,xhi
      common/ cxt11 /xlo(m4,mst,h9),xhi(m4,mst,h9),stable(h9),limit(h9),
     *               relax(h9)

      character fname*10
      common/ csta7 /fname(h9)
c                                 interval limits conformal transformation
      integer intv
      double precision yint, yfrc
      common/ cst47 /yint(5,ms1,mst,h9),yfrc(4,ms1,mst,h9),intv(4)

      integer iopt
      logical lopt
      double precision nopt
      common/ opts /nopt(i10),iopt(i10),lopt(i10)
c----------------------------------------------------------------------
c                                 set stable flag
      stable(ids) = .true.
c                                 check x-ranges
      do i = 1, istg(ids)
         do j = 1, ispg(ids,i) - 1
c                                 low limit:
            if (x(i,j).lt.xlo(j,i,ids)) then

               xlo(j,i,ids) = x(i,j)
c                                 check if solution is at an unnatural limit
               if (x(i,j).gt.xmno(ids,i,j).and.
     *             x(i,j).le.xmng(ids,i,j)) then
c                                 relax limits according to subdivsion model
                  if (imdg(j,i,ids).eq.0) then 
c                                 cartesian
                     xmng(ids,i,j) = xmng(ids,i,j) - nopt(10)
                     if (xmng(ids,i,j).lt.0d0) xmng(ids,i,j) = 0d0

                  else if (imdg(j,i,ids).eq.1.or.imdg(j,i,ids).eq.4)then 
c                                 assymmetric stretching towards xmin
                     yint(1,j,i,ids) = yint(1,j,i,ids) - nopt(10)
                     if (yint(1,j,i,ids).lt.0d0) yint(1,j,i,ids) = 0d0
                     xmng(ids,i,j) =  yint(1,j,i,ids)

                  else 
c                                 symmetric modes, don't reset, but
c                                 set xmn to prevent future warnings
                     xmng(ids,i,j) = 0d0 
                     relax(ids) = .false.

                  end if 

                  limit(ids) = .true.

               end if 
            end if 
c                                 high limit:
            if (x(i,j).gt.xhi(j,i,ids)) then
               xhi(j,i,ids) = x(i,j)
c                                 check if solution is at an unnatural limit
               if (x(i,j).lt.xmxo(ids,i,j).and.
     *             x(i,j).ge.xmxg(ids,i,j)) then
c                                 relax limits according to subdivsion model
                  if (imdg(j,i,ids).eq.0) then 
c                                 cartesian
                     xmxg(ids,i,j) = xmxg(ids,i,j) + nopt(10)
                     if (xmxg(ids,i,j).gt.1d0) xmxg(ids,i,j) = 1d0

                  else if (imdg(j,i,ids).eq.1.or.imdg(j,i,ids).eq.4)then 
c                                 assymmetric stretching
                     yint(2,j,i,ids) = yint(2,j,i,ids) + nopt(10)
                     if (yint(2,j,i,ids).gt.1d0) yint(2,j,i,ids) = 1d0
                     xmxg(ids,i,j) = yint(2,j,i,ids)

                  else 
c                                 symmetric modes, don't reset
c                                 set xmx to prevent future warnings
                     xmxg(ids,i,j) = 1d0 
                     relax(ids) = .false.

                  end if 

                  limit(ids) = .true.

               end if 
            end if 
         end do 
      end do  

      end 

      subroutine outlim 
c----------------------------------------------------------------------
c subroutine to extract compositional range of endmembers in stable phases
c for auto_refine option.
c----------------------------------------------------------------------
      implicit none 

      include 'perplex_parameters.h'
c                                 -------------------------------------
c                                 local variables:
      integer i,j,k,ibad1,ibad2,ibad3,igood

      logical bad1,bad2,good
c                                 -------------------------------------
c                                 global variables:
c                                 working arrays
c                                 x coordinate description
      integer istg, ispg, imlt, imdg
      common/ cxt6i /istg(h9),ispg(h9,mst),imlt(h9,mst),imdg(ms1,mst,h9)
c                                 solution limits and stability
      logical stable,limit,relax
      double precision xlo,xhi
      common/ cxt11 /xlo(m4,mst,h9),xhi(m4,mst,h9),stable(h9),limit(h9),
     *               relax(h9)
c                                 solution model counter
      integer isoct
      common/ cst79 /isoct
c                                 solution model names
      character*10 fname
      common/ csta7 /fname(h9)
c                                 endmember pointers
      integer jend
      common/ cxt23 /jend(h9,k12)
c                                 endmember names
      character names*8
      common/ cst8  /names(k1)

      logical refine
      common/ cxt26 /refine

      integer isec,icopt,ifull,imsg,io3p
      common/ cst103 /isec,icopt,ifull,imsg,io3p

      integer iopt
      logical lopt
      double precision nopt
      common/ opts /nopt(i10),iopt(i10),lopt(i10)
      
      integer ksmod, ksite, kmsol, knsp
      common/ cxt0  /ksmod(h9),ksite(h9),kmsol(h9,m4,mst),knsp(m4,h9)
c----------------------------------------------------------------------
      ibad1 = 0 
      ibad2 = 0 
      ibad3 = 0 
      igood = 0 
      rewind (n10)
      if (lopt(11)) rewind (n11)

      if (isoct.eq.0) goto 99

      bad1 = .false.
      bad2 = .false.
      good = .false.

      do i = 1, isoct

         if (.not.stable(i)) then
            bad1 = .true.
            ibad1 = ibad1 + 1
         else
            good = .true.
            igood = igood + 1
         end if
 
         if (limit(i)) then 
            bad2 = .true.
            if (relax(i)) then 
               ibad2 = ibad2 + 1
            else 
               ibad3 = ibad3 + 1
            end if 
         end if 

      end do 

      if (.not.refine) write (n10,*) ibad1,0,igood
c                                 write solutions present that are 
c                                 not stable
      if (bad1) then 

         write (*,1000)
         if (lopt(11)) write (n11,1000)
     
         do i = 1, isoct
            if (.not.stable(i)) then 
               write (*,'(5x,a)') fname(i) 
               if (.not.refine) write (n10,'(a)') fname(i)
               if (lopt(11)) write (n11,'(5x,a)') fname(i) 
            end if 
         end do
      end if 

      if (.not.good) goto 99
c                                 write solutions that are on an internal
c                                 limit
      if (bad2.and.icopt.gt.3) then 
c                                 adaptive minimization
         if (ibad2.gt.0) then 
c                                 solutions whose limits could be relaxed
            write (*,1080) 
            if (lopt(11)) write (n11,1010) 
            do i = 1, isoct
               if (limit(i).and.relax(i)) then
                  write (*,'(5x,a)') fname(i) 
                  if (lopt(11)) write (n11,'(5x,a)') fname(i)
               end if  
            end do
         end if

         if (ibad3.gt.0) then 
c                                 solutions whose limits could NOT be relaxed
            write (*,1090) 
            if (lopt(11)) write (n11,1010) 
            do i = 1, isoct
               if (limit(i).and.(.not.relax(i))) then
                  write (*,'(5x,a)') fname(i) 
                  if (lopt(11)) write (n11,'(5x,a)') fname(i)
               end if  
            end do
         end if

      else if (bad2) then 
c                                 non-adaptive minimization,
c                                 solutions on internal limits 
         write (*,1010) 
         if (lopt(11)) write (n11,1010) 
         do i = 1, isoct
            if (limit(i)) then
               write (*,'(5x,a)') fname(i) 
               if (lopt(11)) write (n11,'(5x,a)') fname(i)
            end if  
         end do

      end if 

      do i = 1, isoct

         if (.not.stable(i)) cycle

         if (.not.refine) then

            write (n10,'(a)') fname(i)

            do j = 1, istg(i)
               do k = 1, ispg(i,j)-1
                  write (n10,*) xlo(k,j,i),xhi(k,j,i)
               end do
            end do 

         end if 

         if (istg(i).eq.1) then 
c                                 single site solution
            write (*,1020) fname(i)
            if (lopt(11)) write (n11,1020) fname(i)

            do j = 1, ispg(i,1) - 1
            
               if (ksmod(i).eq.5) then
               
                  write (*,1070) j,xlo(j,1,i),xhi(j,1,i)
                                  
               else
                
                  write (*,1030) names(jend(i,2+j)),
     *                           xlo(j,1,i),xhi(j,1,i)
               end if
                
               if (lopt(11)) write (n11,1030) 
     *                       names(jend(i,2+j)),xlo(j,1,i),xhi(j,1,i)
     
            end do 

         else
c                                 reciprocal solution
            write (*,1040) fname(i)
            if (lopt(11)) write (n11,1040) fname(i)

            do j = 1, istg(i)
               
               write (*,1050) j
               if (lopt(11)) write (n11,1050) j

               if (ispg(i,j).eq.1) then 

                  write (*,1060)
                  if (lopt(11)) write (n11,1060) 

               else

                  do k = 1, ispg(i,j) - 1
                     write (*,1070) k,xlo(k,j,i),xhi(k,j,i)
c    *                     ,names(jend(i,2+indx(i,j,k)))
                     if (lopt(11)) write (n11,1070) 
     *                              k,xlo(k,j,i),xhi(k,j,i)
c    *                     ,names(jend(i,2+indx(i,j,k)))
                  end do 

               end if 

            end do

         end if 

      end do 

99    close (n10)
      if (lopt(11)) close (n11)

1000  format (/,'WARNING: The following solutions were input, but are',
     *          ' not stable:',/)
1010  format (/,'WARNING: The following solutions have compositions on',
     *          ' an internal limit (i.e., 0<x<1)',/,'(see ranges ',
     *          'below to determine which limits should be relaxed or',
     *        /,'if executing in auto_refine mode inrease auto_refine',
     *          '_slop in perplex_option.dat):',/)
1020  format (/,'Endmember compositional ranges for model: ',a,//,5x,
     *        'Endmember   Minimum   Maximum')
1030  format (5x,a8,4x,f7.5,3x,f7.5)
1040  format (/,'Site fraction ranges for multisite model: ',a)
1050  format (/,'  Site ',i1,/,5x,'Species   Minimum   Maximum   ')
c     *          'Endmember with this species')
1060  format (8x,'Dummy site generated by model reformulation',/)
1070  format (8x,i1,6x,f7.5,3x,f7.5,3x,12(a8,1x))
1080  format (/,'WARNING: The compositions of the following solutions ',
     *        'reached internal limits',/,'that were automatically ',
     *        'relaxed.',/)
1090  format (/,'WARNING: The compositions of the following solutions ',
     *        'reached internal limits',/,'that could not be ',
     *        'automatically relaxed. To avoid this problem change',/,
     *        'the subdivision mode for ',
     *        'the solutions or increase auto_refine_slop.',/)

      end 

      subroutine sorter (kdbulk,ico,jco,output)
c----------------------------------------------------------------------
c sorter compares assemblages to those already defined and reorders 
c the phases if the assemblage has been identified earlier
c----------------------------------------------------------------------
      implicit none
 
      include 'perplex_parameters.h'

      integer i,j,k,l,m,kdbulk,ico,jco,ids,ioct,inct

      logical output 

      double precision cpt(k5,k5),xt(k5,mst,msp),bt(k5)
c                                 x-coordinates for the final solution
      double precision x3
      common/ cxt16 /x3(k21,mst,msp)

      integer iap,ibulk
      common/ cst74  /iap(k2),ibulk

      integer idasls,iavar,iasct,ias
      common/ cst75  /idasls(k5,k3),iavar(3,k3),iasct,ias
c                                 composition and model flags
c                                 for final adaptive solution
      integer kkp, np, ncpd, ntot
      double precision cp3, amt
      common/ cxt15 /cp3(k0,k5),amt(k5),kkp(k5),np,ncpd,ntot
c                                 x coordinate description
      integer istg, ispg, imlt, imdg
      common/ cxt6i /istg(h9),ispg(h9,mst),imlt(h9,mst),imdg(ms1,mst,h9)

      integer icomp,istct,iphct,icp
      common/ cst6  /icomp,istct,iphct,icp

      integer npt,jdv
      logical fulrnk
      double precision cptot,ctotal
      common/ cst78 /cptot(k5),ctotal,jdv(k19),npt,fulrnk
c----------------------------------------------------------------------
c                                 look for a match with known assemblages
      do 110 i = 1, iasct

         if (np.ne.iavar(1,i).or.ncpd.ne.iavar(2,i)) cycle 

         do 120 j = 1, ntot
            do k = 1, ntot 
               if (idasls(k,i).eq.kkp(j)) then 
c                                 check that the phase occurs the same 
c                                 number of times in each assemblage:
                   inct = 0 
                   ioct = 0 
                   do l = 1, ntot
                      if (kkp(l).eq.kkp(j)) inct = inct + 1
                      if (idasls(l,i).eq.kkp(j)) ioct = ioct + 1
                   end do 

                   if (ioct.ne.inct) goto 110 

                   goto 120

               end if 
            end do
c                                 no match with compound j:
c                                 do next assemblage
            goto 110 

120      continue  

         if (ibulk.gt.k2) call error (183,0d0,k2,'SORTER')
         ibulk = ibulk + 1
         iap(ibulk) = i
         kdbulk = ibulk
c                                 reorder the result arrays of the
c                                 current occurence to match initial 
c                                 occurence:
         do j = 1, ntot

            do k = 1, ntot

               if (kkp(k).eq.idasls(j,i)) then
c                                 load temporary array
                  bt(j) = amt(k)

                  if (kkp(k).gt.0) then 

                     do l = 1, icomp
                        cpt(l,j) = cp3(l,k)
                     end do

                     do l = 1, istg(kkp(k))
                        do m = 1, ispg(kkp(k),l)
                           xt(j,l,m) = x3(k,l,m) 
                        end do 
                     end do 
                  end if 
c                                 this eliminates immiscible phases
                  kkp(k) = 0

                  exit 
 
               end if 

            end do 

         end do
c                                 reload final arrays from temporary
         do j = 1, ntot

            amt(j) = bt(j)
            ids = idasls(j,i)
            kkp(j) = ids

            if (ids.gt.0) then 

               do k = 1, icomp
                  cp3(k,j) = cpt(k,j)
               end do

               do k = 1, istg(ids)
                  do l = 1, ispg(ids,k)
                     x3(j,k,l) = xt(j,k,l) 
                  end do 
               end do 
            end if 
         end do 

         goto 98 

110   continue 
c                                 the assemblage is new:
      iasct = iasct + 1
      if (iasct.gt.k3) call error (184,0d0,k3,'BLKMAT')

      do i = 1, ntot
         idasls(i,iasct) = kkp(i)
      end do

      ibulk = ibulk + 1
      if (ibulk.gt.k2) call error (183,0d0,k2,'BLKMAT')
      kdbulk = ibulk 
      iap(ibulk) = iasct 

      iavar(1,iasct) = np
      iavar(2,iasct) = ncpd
      iavar(3,iasct) = np + ncpd
c                                
98    if (output) call outbl1 (ico,jco)
     
      end 

      subroutine outbl1 (ico,jco)
c----------------------------------------------------------------------
c output data for compositions and phases of assemblage ibulk
c----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer ico,jco,i,j,k,ids
c                                 -------------------------------------
c                                 global variables
      integer iap,ibulk
      common/ cst74  /iap(k2),ibulk
c                                 composition and model flags
c                                 for final adaptive solution
      integer kkp, np, ncpd, ntot
      double precision cp3, amt
      common/ cxt15 /cp3(k0,k5),amt(k5),kkp(k5),np,ncpd,ntot
c                                 x-coordinates for the final solution
      double precision x3
      common/ cxt16 /x3(k21,mst,msp)
c                                 x coordinate description
      integer istg, ispg, imlt, imdg
      common/ cxt6i /istg(h9),ispg(h9,mst),imlt(h9,mst),imdg(ms1,mst,h9)
c                                 i/o
      integer io3,io4,io9
      common / cst41 /io3,io4,io9

      double precision mu
      common/ cst330 /mu(k8)

      integer jtest,jpot
      common/ debug /jtest,jpot

      integer hcp,idv
      common/ cst52  /hcp,idv(k7) 
c----------------------------------------------------------------------
      if (io4.eq.1) return
c                                graphics output  
      write (n5,'(3(i8,1x))') ico,jco,iap(ibulk)
c                                phase molar amounts
      write (n5,1010) (amt(i),i=1,np+ncpd)
c                                solution phase compositions
      do i = 1, np
         ids = kkp(i)
         write (n5,1010) ((x3(i,j,k),k=1,ispg(ids,j)),j=1,istg(ids))
      end do 
c                                dependent potentials
      if (jpot.ne.1) write (n5,1010) (mu(i),i=1,hcp)

1010  format (20(g16.8,1x))

      end 

      subroutine yclos1 (clamda,x,is,jphct,quit)
c----------------------------------------------------------------------
c subroutine to identify pseudocompounds close to the solution for 
c subsequent refinement. this routine is only called as preparation
c for iterative refinement.
c----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer jphct, i, j, k, is(k1+k5), idsol(k5), kdv(h8+1), nsol, 
     *        mpt, iam, id, is1, left, right, inc, jdsol(k5,k5), 
     *        kdsol(k5), max

      external ffirst

      logical solvus, quit

      double precision clamda(k1+k5), x(k1),  slam(h8+1)

      integer ipoint,imyn
      common/ cst60 /ipoint,imyn

      integer icomp,istct,iphct,icp
      common/ cst6  /icomp,istct,iphct,icp

      integer iopt
      logical lopt
      double precision nopt
      common/ opts /nopt(i10),iopt(i10),lopt(i10)

      integer isoct
      common/ cst79 /isoct

      double precision dcp,soltol
      common/ cst57 /dcp(k5,h8),soltol

      integer ikp
      common/ cst61 /ikp(k1)

      integer kkp, np, ncpd, ntot
      double precision cp3, amt
      common/ cxt15 /cp3(k0,k5),amt(k5),kkp(k5),np,ncpd,ntot

      integer npt,jdv
      logical fulrnk
      double precision cptot,ctotal
      common/ cst78 /cptot(k5),ctotal,jdv(k19),npt,fulrnk
c----------------------------------------------------------------------
      npt = 0 
      nsol = 0
      inc = istct - 1
      is1 = isoct + 1 
      quit = .true.
c                                 solvus tolerance, yclos1, was 5
      if (lopt(9)) then
c                                 auto 
         soltol = 4d0*nopt(8)
      else 
c                                 twice initial_resolution.
         soltol = 2d0*nopt(13)
      end if 

      do i = 1, jphct

         if (is(i).ne.1) then 
c                                 make a list of found phases:
            id = i + inc
c                                 currently endmember compositions are not 
c                                 refined (this is probably a mistake, but 
c                                 seems to work fine), so use id > ipoint
c                                 to identify a refineable point
            if (id.gt.ipoint) quit = .false.

            if (ikp(id).ne.0.and.id.gt.ipoint) then 
               do j = 1, nsol
                  if (ikp(id).eq.idsol(j)) then 
                     kdsol(j) = kdsol(j) + 1
                     jdsol(kdsol(j),j) = id
                     goto 10
                  end if 
               end do
c                                 new phase, add to list
               nsol = nsol + 1
               idsol(nsol) = ikp(id)
               jdsol(1,nsol) = id
               kdsol(nsol) = 1

            end if 
c                                 new point, add to list
10          npt = npt + 1
            jdv(npt) = i

         end if 

      end do

      do i = 1, is1
         slam(i) = 1d99
         kdv(i) = 0 
      end do 
c                                 perp 6.6.3, make a list of metastable
c                                 phases, this list includes one compound
c                                 and the least metastable composition of
c                                 each solution.      
      do 20 i = 1, jphct

         if (is(i).ne.1) cycle 

         id = i + inc 
         iam = ikp(id)

         if (iam.ne.0.and.id.gt.ipoint) then   

            if (clamda(i).lt.slam(iam)) then
c                                the composition is more stable
c                                than the previous composition 
c                                of the solution. check if it's 
c                                one of the stable solutions                               
               do j = 1, nsol
                  if (iam.eq.idsol(j)) then
c                                it's already stable, only accept
c                                it if its further than the solvus
c                                tolerance from any of the stable
c                                compositions.
                     do k = 1, kdsol(j)
                        if (.not.solvus(jdsol(k,j),id,iam)) goto 20
                     end do 
                  end if
               end do
c                                the composition is stable
               slam(iam) = clamda(i)
               kdv(iam) = i

            end if

         else 
c                                a compound, save only one
            if (clamda(i).lt.slam(is1)) then 
               slam(is1) = clamda(i)
               kdv(is1) = i
            end if 
 
         end if 

20    continue 
c                                 load the metastable points into
c                                 kdv
      mpt = 0 

      do i = 1, is1

         if (kdv(i).eq.0) cycle
         mpt = mpt + 1
         kdv(mpt) = kdv(i)
         slam(mpt) = slam(i)

      end do 

      if (mpt.le.iopt(12)) then 
c                                 less metastable refinement points than
c                                 iopt(12)
            max = mpt

      else 
c                                 sort the metastable points to
c                                 find the most stable iopt(12) points
         left = 1
         right = mpt
         max = iopt(12)

         call ffirst (slam,kdv,left,right,max,h8+1,ffirst)

      end if 
 
      do i = 1, max

         jdv(npt+i) = kdv(i)
c                                 a metastable solution to be refined
         if (kdv(i)+inc.gt.ipoint) quit = .false.
      end do

      if (quit) then 
c                                 zero mode filter and 
c                                 save amounts for final processing
         mpt = npt
         npt = 0 

         do i = 1, mpt
            if (x(jdv(i)).lt.nopt(9)) cycle 
            npt = npt + 1
            jdv(npt) = jdv(i)
            amt(npt) = x(jdv(i)) 
         end do 

      else 

         npt = npt + max
c                                 sort the phases, why? don't know, but it's 
c                                 necessary
         call sortin 

      end if 

      end 

      subroutine ffirst (a, ind, left, right, k, n, dumsub)
c-----------------------------------------------------------------------
c find the k smallest values of array between indices left and right
c from http://en.wikipedia.org/wiki/Selection_algorithm
c-----------------------------------------------------------------------
      implicit none

      integer left, right, k, n, pivot, opivot, partit, ind(n)

      external dumsub

      double precision a(n)

      if (right.gt.left) then 

         opivot = left + (right-left)/2
         pivot = partit (a, ind, left, right, opivot, n)

         if (pivot.gt.k) then 
            call dumsub (a,ind,left,pivot-1,k,n,dumsub)
         else if (pivot.lt.k) then 
            call dumsub (a,ind,pivot+1,right,k-pivot,n,dumsub)
         end if 

      end if 

      end 

      integer function partit (a, ind, left, right, opivot, n)

      implicit none

      integer left, right, n, pivot, opivot, iold, ind(n), i

      double precision a(n), value, oldval

      value = a(opivot)
c                                 swap a(opivot) with a(right)
      iold = ind(opivot)
      a(opivot) = a(right)
      ind(opivot) = ind(right)
      a(right) = value
      ind(right) = iold

      pivot  = left

      do i = left, right-1

         if (a(i).le.value) then
 
            iold = ind(pivot)
            oldval = a(pivot)
            a(pivot) = a(i)
            ind(pivot) = ind(i)
            a(i) = oldval
            ind(i) = iold
            
            pivot = pivot + 1
         end if 
      end do 
c                                 swap a(right) with a(pivot)
      iold = ind(pivot)
      oldval = a(pivot)
      a(pivot) = a(right)
      ind(pivot) = ind(right)
      a(right) = oldval 
      ind(right) = iold
      
      partit = pivot

      end 

      subroutine subst (a,ipvt,n,b,ier)
c-----------------------------------------------------------------------
c subst uses the lu decomposition of the matrix 'a' contained
c in the array 'a' to solve ax = b for x. subst is modified from the
c the subroutine of the same name listed by conte and de boor
c in 'elementary numerical analysis', mcgraw-hill, 1980.
c factor uses scaled partial pivoting.
 
c input     a- an n by n array containing the non-zero elements of
c              the u and l decompositions of a, as output by factor.
c           n- the dimension of the matrix a.
c        ipvt- a vector indicating that row ipvt(k) was used to
c              eliminate the coefficient a(n,k).
c           b- the vector b.
c output    b- the solution vector x.
c----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'
 
      double precision a(k8,k8),b(k8),x(k8),sum

      integer ipvt(k8),ip,i,j,n,ii,ier
c----------------------------------------------------------------------
c                                 solve ly = b for y:
      ip = ipvt(1)
      x(1) = b(ip)
      do i = 2, n

         sum = 0d0

         do j = 1, i - 1
            sum = a(i,j)*x(j)+sum
         end do 

         ip = ipvt(i)
         x(i) = b(ip)-sum

      end do 
c                                 solve ux = y for x:
      if (a(n,n).eq.0d0) then
c                                 this check should be superfluous,
c                                 but reopt requires it. should check
c                                 what's with factor. 
         ier = 1
         goto 99
      end if 

      x(n) = x(n)/a(n,n)

      do ii = 1, n - 1

         i = n-ii

         sum = 0d0

         do j = i + 1, n
            sum = a(i,j)*x(j)+sum
         end do 

         if (a(i,i).eq.0d0) then
c                                 as above.
            ier = 1
            goto 99
         end if 

         x(i) = (x(i)-sum)/a(i,i)
         b(i) = x(i)

      end do 
      b(n) = x(n)
 
99    end

      subroutine subst1 (n)
c-----------------------------------------------------------------------
c subst uses the lu decomposition of the matrix 'a' contained
c in the array 'a' to solve ax = b for x. subst is modified from the
c the subroutine of the same name listed by conte and de boor
c in 'elementary numerical analysis', mcgraw-hill, 1980.
c factor uses scaled partial pivoting.
 
c input     a- an n by n array containing the non-zero elements of
c              the u and l decompositions of a, as output by factor.
c           n- the dimension of the matrix a.
c        ipvt- a vector indicating that row ipvt(k) was used to
c              eliminate the coefficient a(n,k).
c           b- the vector b.
c output    b- the solution vector x.
c-----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      double precision x(k5), sum

      integer n, i, j, im1, ip1, nm1, ii, ip

      integer ipvt
      double precision a,b
      common/ cst301 /a(k5,k5),b(k5),ipvt(k5) 

c                            solve ly = b for y:
      ip = ipvt(1)
      x(1) = b(ip)

      do i = 2, n
         sum = 0d0
         im1 = i-1
         do j = 1, im1
            sum = a(i,j)*x(j)+sum
         end do 
         ip = ipvt(i)
         x(i) = b(ip)-sum
      end do 
c                            solve ux = y for x:
      x(n) = x(n)/a(n,n)
      nm1 = n-1

      do ii = 1, nm1
         i = n-ii
         ip1 = i+1
         sum = 0d0
         do j = ip1, n
            sum = a(i,j)*x(j)+sum
         end do
         x(i) = (x(i)-sum)/a(i,i)
         b(i) = x(i)
      end do 

      b(n) = x(n)
 
      end

      subroutine factr1 (n,ier)
c-----------------------------------------------------------------------
c factr1 is a subroutine which calculates the triangular
c decompositions of the matrix 'a'. factor is modified from
c the subroutine of the same name given by conte and de boor
c in 'elementary numerical analysis', mcgraw-hill, 1980.
c factor uses scaled partial pivoting.
c
c input     a- an n by n array containing the elements of matrix a.
c           n- the dimension of the matrix a.
c output    a- an n by n array containing the upper, u, and lower, l,
c              triangular decompositions of input matrix a.
c        ipvt- a vector indicating that row ipvt(k) was used to
c              eliminate the a(n,k).
c         ier- a flag, zero if a is of rank = n, and 1 if a is of
c              lower rank.
c-----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer i,j,k,n,ip1,istr,ier

      double precision temp,ratio,tmax,rmax

      integer ipvt
      double precision a,d,x(k5)
      common/ cst301 /a(k5,k5),d(k5),ipvt(k5)
c-----------------------------------------------------------------------
      ier = 0
c                            initialize ipvt,d
      do i = 1, n
         ipvt(i) = i
         rmax = 0d0
         do j = 1,n
            rmax = dmax1(rmax,dabs(a(i,j)))
         end do 
c                            ax = b is singular if rmax = 0
         if (dabs(rmax).lt.1d-5) goto 9000
         x(i) = rmax
      end do 
c                            begin decomposition:
      do i = 1, n - 1
c                            determine pivot row (istr).
         rmax = dabs(a(i,i))/x(i)
         istr = i
         ip1 = i + 1

         do j = ip1, n
            tmax = dabs(a(j,i))/x(j)
            if (tmax.le.rmax) cycle
            rmax = tmax
            istr = j
         end do 

         if (dabs(rmax).lt.1d-5) goto 9000
c                            if istr gt i, make i the pivot row
c                            by interchanging it with row istr.
         if (istr.gt.i) then 
            j = ipvt(istr)
            ipvt(istr) = ipvt(i)
            ipvt(i) = j
            temp = x(istr)
            x(istr) = x(i)
            x(i) = temp
            do j = 1, n
               temp = a(istr,j)
               a(istr,j) = a(i,j)
               a(i,j) = temp
            end do 
         end if 
c                            eliminate x(k) from rows k+1,...,n.
         do j = ip1,n
            a(j,i) = a(j,i)/a(i,i)
            ratio = a(j,i)
            do k = ip1, n
               a(j,k) = a(j,k)-ratio*a(i,k)
            end do 
         end do 
 
      end do 
     
      if (dabs(a(n,n)).lt.1d-5) ier = 1

      return
c                           algoritmic singularity.
9000  ier = 1
 
      end

      subroutine ufluid (fo2)
c----------------------------------------------------------------------
c subroutine ufluid computes the potential of the components
c of a saturated fluid phase. if the mole fraction of a component is les
c less than 1.d-38 the chemical potential is set to -9.9d09.
c ufluid may call one of three molecular fluid equations of state, or
c alternatively users may supply their own routines, however,
c the routines currently in use return the log of a components fugacity
c which is then added to the reference state potential computed by the
c function gphase.
c----------------------------------------------------------------------
      implicit none
 
      include 'perplex_parameters.h'

      integer i
 
      double precision xf(2),fo2,fs2,gph

      double precision thermo,uf,us 
      common/ cst1 /thermo(k4,k10),uf(2),us(h5)

      double precision p,t,xco2,u1,u2,tr,pr,r,ps
      common/ cst5 /p,t,xco2,u1,u2,tr,pr,r,ps

      double precision f
      common/ cst11 /f(2)

      integer ifct,idfl
      common/ cst208 /ifct,idfl

      integer iff,idss,ifug,ifyn,isyn
      common/ cst10  /iff(2),idss(h5),ifug,ifyn,isyn
c-----------------------------------------------------------------------
c                           compute the chemical potentials of
c                           fluid components in fluid saturated
c                           systems.
      call cfluid (fo2,fs2)

      if (idfl.ne.0) then
         call gphase (idfl,gph)
         uf(idfl) = gph + r * t * f(idfl)
      else
         xf(1) = 1d0 - xco2
         xf(2) = xco2
 
         do i = 1, 2
            if (iff(i).ne.0) then 
               if (xf(i).lt.1d-38) then 
                  uf(i) = -1d10
               else 
                  call gphase (i,gph)
                  uf(i) = gph + r * t * f(i)
               end if
            end if 
         end do

      end if 
 
      end

      subroutine uproj
c----------------------------------------------------------------------
c subroutine uproj computes the potentials of saturated phase components
c and saturated components.
  
c the energies of saturated components are projected through
c saturated volatile components.
c----------------------------------------------------------------------
      implicit none
 
      include 'perplex_parameters.h'
 
      integer i,j,k,l,ict,ll,i1,id

      double precision uss(h6),fo2,gph,u

      double precision g
      common/ cst2 /g(k1)

      double precision cp
      common/ cst12 /cp(k5,k1)

      double precision thermo,uf,us 
      common/ cst1 /thermo(k4,k10),uf(2),us(h5)

      integer ifct,idfl
      common/ cst208 /ifct,idfl

      integer iff,idss,ifug,ifyn,isyn
      common/ cst10  /iff(2),idss(h5),ifug,ifyn,isyn

      integer icomp,istct,iphct,icp
      common/ cst6  /icomp,istct,iphct,icp  

      integer ids,isct,icp1,isat,io2
      common/ cst40 /ids(h5,h6),isct(h5),icp1,isat,io2

      double precision p,t,xco2,u1,u2,tr,pr,r,ps
      common/ cst5 /p,t,xco2,u1,u2,tr,pr,r,ps
c-----------------------------------------------------------------------
      fo2 = 0d0
c                                 compute the chemical potentials of
c                                 saturated phase components.
      if (ifyn.ne.1) call ufluid (fo2)

      do i = 1, isat
c                                 determine stable saturated composants
c                                 and the corresponding chemical potentials
         ict = isct(i)

         ll = icp+i

         do j = 1, ict

            k = ids(i,j)
            call gphase (k,gph)
            
            if (ifct.gt.0) then 
               do l = 1, 2
c                                 legendre transform for saturared phase
c                                 component potentials
                  if (iff(l).ne.0) gph = gph - cp(iff(l),k)*uf(l)
               end do 
            end if 

            uss(j) = gph 

            if (i.gt.1) then 
c                                 if multiple component saturation constraints
c                                 apply saturation hierarchy legendre transform:
               i1 = i-1
               do l = 1, i1
                  uss(j) = uss(j)-cp(icp+l,k)*us(l)
               end do
            end if 

            g(k) = uss(j)
            uss(j) = uss(j)/cp(ll,k)
         end do 
c                                 if O2, check if fo2 has been 
c                                 determined by a fluid phase routine,
c                                 if so, add the transform:
         if (io2.eq.i) then 
            do j = 1, ict 
               uss(j) = uss(j) + r*t*fo2
            end do 
         end if 
c                           now find stable "composant":

         u = uss(1)

         id = 1

         if (ict.ne.1) then 
            do j = 2, ict
               if (uss(j).gt.u) cycle  
               id = j
               u = uss(j)
            end do 
         end if 
c                               save the id of the stable composant.
         idss(i) = ids(i,id)
c                               and its chemical potential.
         us(i) = u
c                               in case a phase in the component
c                               saturation space is an endmember of
c                               a solution transform the endmember G's:
         do j = 1, ict
            k = ids(i,j)
            g(k) = g(k) - cp(icp+i,k)*u
         end do 

      end do 

      end

      subroutine initlp 
c--------------------------------------------------------------------
c initialize arrays and constants for lp minimizarion
c---------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer i,j,k,l,inc,kphct,id,jk

      logical bad

      double precision u,s,vol,tot 

      double precision ctot
      common/ cst3  /ctot(k1)

      double precision cp
      common/ cst12 /cp(k5,k1)

      double precision a,b,c
      common/ cst313 /a(k5,k1),b(k5),c(k1)

      double precision vmax,vmin,dv
      common/ cst9 /vmax(l2),vmin(l2),dv(l2)

      integer icomp,istct,iphct,icp
      common/ cst6  /icomp,istct,iphct,icp  

      integer jphct,istart
      common/ cst111 /jphct,istart

      integer jbulk
      double precision cblk
      common/ cst300 /cblk(k5),jbulk
c                                 stuff used in lpnag 
      double precision wmach(9)
      common /ax02za/wmach

      integer ldt,ldq
      common /be04nb/ldt,ldq

      logical usv
      integer pindex,tindex
      common/ cst54 /pindex,tindex,usv

      integer iam,jam,tloop,ploop
      common/ cst55 /iam(k1),jam(k1),tloop,ploop

      integer npt,jdv
      logical fulrnk
      double precision cptot,ctotal
      common/ cst78 /cptot(k5),ctotal,jdv(k19),npt,fulrnk
c-----------------------------------------------------------------------
      inc = istct - 1

      tloop = 400
      ploop = 400
      dv(1) = (vmax(1)-vmin(1))/(ploop-1)
      dv(2) = (vmax(2)-vmin(2))/(tloop-1)
c                                 load arrays for lp solution
      jphct = iphct - inc

      if (.not.usv) then
c                                 pressure and temperature are allowed 
c                                 EoS variables
         ctotal = 0d0

         do i = 1, icp
            ctotal = ctotal + cblk(i)
         end do 
c                                 composition constraint
         do i = 1, icp
            b(i) = cblk(i)/ctotal
         end do 

         do i = 1, jphct
            id = i + inc
            iam(i) = id
            do j = 1, icp
               a(j,i) = cp(j,id)/ctot(id)
            end do
         end do

         ldt = icp + 1
         ldq = icp + 1

      else
c                                 using usv formulation
         kphct = 0 

         do i = 1, jphct

            id = i + inc
            jk = 0
c                                 for each static chemical cpd
            do j = 1, tloop
c                                 for each temperature
               do k = 1, ploop
c                                 for each pressure
c                 
                  jk = jk + 1  

                  call pt4sv (jk)  

                  call getusv (u,s,vol,id,bad)
  
          
                  kphct = kphct + 1
                  
                  tot = ctot(id) + s + vol
                  
                  do l = 1, jbulk
                    a(l,kphct) = cp(l,id)/tot
                  end do

                  a(icp+1,kphct) = s/tot
                  a(icp+2,kphct) = vol/tot
                  c(kphct) = u/tot
                  iam(kphct) = id
                  jam(kphct) = jk

               end do 

            end do 

         end do 

         jphct = kphct

         ldt = jbulk + 1
         ldq = jbulk + 1

      end if 
c                                 cold start istart = 0
      istart = 0
c                                 stuff for lpnag
      wmach(3) = 1.11022302462516d-16
      wmach(4) = dsqrt(wmach(3))
      wmach(5) = 2.22507385850721d-308
      wmach(7) = 1d0/wmach(5)
      wmach(8) = dsqrt(wmach(7))
      wmach(9) = max(1d0/wmach(4),1d2)
      wmach(2) = wmach(3)**0.8d0
      wmach(1) = wmach(3)**0.9d0

      end 

      subroutine gall 
c-----------------------------------------------------------------------
c subroutine gall computes molar free energies of all static compounds.
c-----------------------------------------------------------------------
      implicit none
 
      include 'perplex_parameters.h'

      integer i,j,k,id

      double precision dg1,gval,dg,gzero,g0(k5),gex,x0

      integer icomp,istct,iphct,icp
      common/ cst6 /icomp,istct,iphct,icp

      integer ipoint,imyn
      common/ cst60 /ipoint,imyn

      double precision g
      common/ cst2 /g(k1)

      double precision cp
      common/ cst12 /cp(k5,k1)

      double precision thermo,uf,us 
      common/ cst1 /thermo(k4,k10),uf(2),us(h5)

      integer ifct,idfl
      common/ cst208 /ifct,idfl

      integer iff,idss,ifug,ifyn,isyn
      common/ cst10  /iff(2),idss(h5),ifug,ifyn,isyn

      integer isoct
      common/ cst79 /isoct

      integer ids,isct,icp1,isat,io2
      common/ cst40 /ids(h5,h6),isct(h5),icp1,isat,io2

      integer ixp
      double precision sxs,exces
      common/ cst304 /sxs(k13),exces(m3,k1),ixp(k1)

      integer jend
      common/ cxt23 /jend(h9,k12)
c                                 working arrays
      double precision z, pa, p0a, x, w, y
      common/ cxt7 /x(m4),y(m4),pa(m4),p0a(m4),z(mst,msp),w(m1)
c                                 model type
      logical lorder, lexces, llaar, lrecip
      common/ cxt27 /lorder(h9),lexces(h9),llaar(h9),lrecip(h9)

      integer lstot,mstot,nstot,ndep,nord
      common/ cxt25 /lstot(h9),mstot(h9),nstot(h9),ndep(h9),nord(h9)

      double precision p,t,xco2,u1,u2,tr,pr,r,ps
      common/ cst5 /p,t,xco2,u1,u2,tr,pr,r,ps

      integer ksmod, ksite, kmsol, knsp
      common/ cxt0  /ksmod(h9),ksite(h9),kmsol(h9,m4,mst),knsp(m4,h9)
c-----------------------------------------------------------------------
c                                 compute the chemical potential
c                                 of the projected components.
      call uproj
c                                 first do the endmembers:
      do id = istct, ipoint

         call gcpd(id,gval)
c                                 this is a screw up solution
c                                 necessary cause uf(1) and uf(2)
c                                 are allocated independent of ifct!
         if (ifct.gt.0) then 
            do j = 1, 2
               if (iff(j).ne.0) gval = gval - cp(iff(j),id)*uf(j)
            end do 
         end if 

         do j = 1, isat
            gval = gval - us(j) * cp(icp+j,id)
         end do

         g(id) = gval 

      end do 
c                                 now do solutions:
      do i = 1, isoct
c                                 check if normal solution:
         if (.not.llaar(i).and.(ksmod(i).eq.7.or.ksmod(i).eq.5.or.
     *       ksmod(i).eq.2.or.ksmod(i).eq.24.or.ksmod(i).eq.25.or.
     *       ksmod(i).eq.28)) then 
c                                 it's normal margules or ideal:
            do j = 1, jend(i,2)
c                                 initialize with excess energy, dqf,
c                                 and configurational entropy terms
               call gexces (id,g(id))

               do k = 1, lstot(i) 
                  g(id) = g(id) + g(jend(i,2+k)) * sxs(ixp(id)+k)
               end do 

               id = id + 1

            end do 

         else if (ksmod(i).eq.0) then
c                                 it's a fluid compound, the way 
c                                 things are now it must have two
c                                 components.
            do j = 1, mstot(i)
               g0(j) = gzero(jend(i,2+j))
            end do 

            do j = 1, jend(i,2)

               call fexces (id,gval)

               g(id) = g0(1) * sxs(ixp(id)+1) + g0(2) * sxs(ixp(id)+2) 
     *                                        + gval
               id = id + 1

            end do 

         else if (lrecip(i).and.lorder(i)) then
c                                 reciprocal solution with ordering 

c                                 compute margules coefficients
            call setw (i)
c                                 now for each compound:
            do j = 1, jend(i,2)
c                                 assign x's
               do k = 1, nstot(i) 
                  p0a(k) = sxs(ixp(id)+k)
                  pa(k) = p0a(k)
               end do 
c                                 get the speciation energy effect
               call specis (dg,i)
c                                 and endmember dqf
               call gexces (id,dg1)

               g(id) = dg + dg1 
c                                 add in g from real endmembers, this
c                                 must include the g for the disordered equivalent
c                                 of the ordered species
               do k = 1, lstot(i)

                  g(id) = g(id) + g(jend(i,2+k)) * p0a(k)

               end do 

               id = id + 1

            end do 

         else if (lorder(i)) then
c                                 compute margules coefficients
            call setw (i)
c                                 now for each compound:
            do j = 1, jend(i,2)
c                                 here excess gets the endmember entropies
c                                 and dqf corrections
               call gexces (id,g(id))

               do k = 1, lstot(i)
                  p0a(k) = sxs(ixp(id)+k)
                  pa(k) = p0a(k)
                  g(id) = g(id) + g(jend(i,2+k)) * p0a(k)
               end do 
c                                 get the speciation energy effect
               call specis (dg,i)

               g(id) = g(id) + dg  

               id = id + 1

            end do 

         else if (llaar(i)) then 
c                                 compute margules coefficients
            call setw (i)
c                                 because the hp van laar may have p-t
c                                 dependent volumes, the full expression
c                                 must be evaluated here:                   
            do j = 1, jend(i,2)
c                                 initialize with dqf,
c                                 and configurational entropy terms
               call gexces (id,g(id))

               do k = 1, lstot(i) 
                  x(k) =  sxs(ixp(id)+k)
                  g(id) = g(id) + g(jend(i,2+k)) * x(k)
               end do 
c                                 add the real excess energy
               g(id) = g(id) + gex(i,x)

               id = id + 1

            end do 

         else if (ksmod(i).eq.23) then
c                                 toop melt:
            do j = 1, nstot(i)
               g0(j) = gzero(jend(i,2+j))
            end do 

            do j = 1, jend(i,2)
               call toop (id,g(id))
               do k = 1, nstot(i) 
                  g(id) = g(id) + g(jend(i,2+k)) * sxs(ixp(id)+k)
               end do 
               id = id + 1
            end do 

         else if (ksmod(i).eq.26) then
c                                 H2O-CO2-Salt:
            do j = 1, jend(i,2)
        
               call hcneos (g(id),sxs(ixp(id)+1),
     *                      sxs(ixp(id)+2),sxs(ixp(id)+3))

               do k = 1, nstot(i) 
                  g(id) = g(id) + g(jend(i,2+k)) * sxs(ixp(id)+k)
               end do 

               id = id + 1

            end do

         else if (ksmod(i).eq.27) then 

            do j = 1, jend(i,2)

               g(id) = 0d0 
c                                 ideal gas mix
               do k = 1, mstot(i)
                  x0 = sxs(ixp(id)+k)
                  if (x0.le.0d0) cycle 
                  g(id) = g(id) + (g(jend(i,2+k)) + r*t*dlog(x0)) * x0 
               end do

               id = id + 1

            end do  
 
         end if 

      end do 

      end

      logical function solvus (id1,id2,ids)
c-----------------------------------------------------------------------
c function to test if a solvus separates two static pseudocompounds of
c solution ids.
c-----------------------------------------------------------------------
      implicit none
 
      include 'perplex_parameters.h'

      integer i, id1, id2, ids

      integer icomp,istct,iphct,icp
      common/ cst6 /icomp,istct,iphct,icp 

      double precision cp
      common/ cst12 /cp(k5,k1)

      double precision dcp,soltol
      common/ cst57 /dcp(k5,h8),soltol

      integer iopt
      logical lopt
      double precision nopt
      common/ opts /nopt(i10),iopt(i10),lopt(i10)
c-----------------------------------------------------------------------
      solvus = .false.

      do i = 1, icp

         if (dcp(i,ids).eq.0d0) cycle 

         if (dabs(cp(i,id1)-cp(i,id2))/dcp(i,ids).gt.soltol) then 
            solvus = .true.
            exit
         end if 

      end do 

      end 

      subroutine fopen (n2name,prt,plt,n9name,jbulk,icp,icopt)
c-----------------------------------------------------------------------
c open files for subroutine input1.
c-----------------------------------------------------------------------
      implicit none
 
      include 'perplex_parameters.h'

      logical first

      integer ierr,icopt,jbulk,icp
 
      character*100 blank*1,n2name,prt*3,plt*3,name,n9name

      integer io3,io4,io9
      common / cst41 /io3,io4,io9

      character*100 prject,tfname
      common/ cst228 /prject,tfname

      integer jtest,jpot
      common/ debug /jtest,jpot

      integer iopt
      logical lopt
      double precision nopt
      common/ opts /nopt(i10),iopt(i10),lopt(i10)

      integer iam
      common/ cst4 /iam

      save first,blank

      data first,blank/.true.,' '/
c----------------------------------------------------------------------
c                                 open thermodynamic data file
      call fopen2 (0,n2name)

      if (first) then 
         call mertxt (name,prject,'.dat',0)
         write (*,1160) name
         write (*,1170) n2name
      end if 

      if (n9name.ne.blank) then

         io9 = 0 
c                                 open solution model file
         open (n9,file = n9name,iostat = ierr,status = 'old')
         if (ierr.ne.0) call error (120,0d0,n9,n9name)

         if (first) write (*,1210) n9name

      else

         io9 = 1
         if (first) write (*,1210) 'not requested'

      end if
c                                 open print/plot files if requested
      if (prt.ne.blank.and.prt.ne.'no_') then 
         io3 = 0 
         call mertxt (name,prject,'.prn',0)
         open (n3, file = name)
      else
         io3 = 1
         name = 'none requested'
      end if

      if (first) write (*,1180) name

      if (plt.ne.blank.and.plt.ne.'no_') then
         io4 = 0
         call mertxt (name,prject,'.plt',0)
         open (n4, file = name)
      else
         io4 = 1
         name = 'none requested'
      end if

      if (first) write (*,1190) name

      if (jbulk.ge.icp.and.io4.ne.1) then
c                                 create special plot output file
         call mertxt (name,prject,'.blk',0)
         open (n5, file = name)
         if (first) write (*,1220) name

      else if (jbulk.ge.icp.and.io4.eq.1) then 

         if (first) write (*,1220) 'none requested'

      end if

      first = .false.

1160  format (/,'Reading problem definition from file: ',a)
1170  format ('Reading thermodynamic data from file: ',a)
1180  format ('Writing print output to file: ',a)
1190  format ('Writing plot output to file: ',a)
1210  format ('Reading solution models from file: ',a)
1220  format ('Writing bulk composition plot output to file: ',a)

      end 

      subroutine grxn (gval) 
c-----------------------------------------------------------------------
c grxn computes the free energy of univariant equilibria
c defined by the data in commonn block cst21 which is initialized
c in the subprogram balanc.  grxn is partially redundant with
c the function gphase but because of the frequency that these
c these routines are used a significant increase in efficiency is
c gained by maintaining separate functions.
c-----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer j

      double precision gval,gproj

      integer iffr,isr
      double precision vuf,vus
      common/ cst201 /vuf(2),vus(h5),iffr,isr

      integer iff,idss,ifug,ifyn,isyn
      common/ cst10  /iff(2),idss(h5),ifug,ifyn,isyn

      integer idr,ivct
      double precision vnu
      common/ cst25 /vnu(k7),idr(k7),ivct
c-----------------------------------------------------------------------
c                                 compute potentials of saturated phases
c                                 and components, note that in this
c                                 version of vertex the stoichiometry of
c                                 such components may vary.

c                                 no saturated phase components and no
c                                 saturated components:
      if (iffr.eq.1.and.isyn.eq.1) goto 10
c                                 note that this call to uproj makes a
c                                 subsequent call in gall redundant if
c                                 sfol1 is used to trace a univariant
c                                 curve.
      call uproj
c                                 compute free energy change of the rxn
10    gval = 0d0

      do j = 1, ivct
         gval = gval + vnu(j) * gproj(idr(j))
      end do 

      end

      subroutine yclos0 (x,is,jphct)
c----------------------------------------------------------------------
c subroutine to save optimization results for non-iterative refinement
c----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer i,jphct,is(k1+k5)

      double precision x(k1) 
c                                 compositions of stable adaptive
c                                 coordinates (and solution ids).
      integer kkp, np, ncpd, ntot
      double precision cp3, amt
      common/ cxt15 /cp3(k0,k5),amt(k5),kkp(k5),np,ncpd,ntot

      integer npt,jdv
      logical fulrnk
      double precision cptot,ctotal
      common/ cst78 /cptot(k5),ctotal,jdv(k19),npt,fulrnk

      integer iopt
      logical lopt
      double precision nopt
      common/ opts /nopt(i10),iopt(i10),lopt(i10)
c----------------------------------------------------------------------

      npt = 0 

      do i = 1, jphct

         if (is(i).eq.1.or.x(i).lt.nopt(9)) cycle  
c                                 acceptable cases 0 active, between bounds
c                                                  2 active, upper bound 
            npt = npt + 1
            jdv(npt) = i 
            amt(npt) = x(i)
 
      end do
    
      end 

      subroutine setx3 (ind,id,ids)
c----------------------------------------------------------------------
c subroutine to recover geometric reciprocal solution compositions (x(i,j))
c from the xcoor (reciprocal) or sxs (single site) arrays loaded in soload
c----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer i, j, id, ids, jcoor, ind
c                                 x coordinate description
      integer istg, ispg, imlt, imdg

      common/ cxt6i /istg(h9),ispg(h9,mst),imlt(h9,mst),imdg(ms1,mst,h9)
c                                 stored x coordinate
      double precision xcoor
      integer icoor
      common/ cxt10 /xcoor(k18),icoor(k1)
c                                 single site solution coordinates:
      integer ixp
      double precision sxs,exces
      common/ cst304 /sxs(k13),exces(m3,k1),ixp(k1)
c                                  x-coordinates for the final solution
      double precision x3
      common/ cxt16 /x3(k21,mst,msp)

      integer ipoint,imyn
      common/ cst60 /ipoint,imyn

      integer lstot,mstot,nstot,ndep,nord
      common/ cxt25 /lstot(h9),mstot(h9),nstot(h9),ndep(h9),nord(h9)
c----------------------------------------------------------------------
      if (id.gt.ipoint) then 
c                                 a normal solution
         if (istg(ids).eq.1) then 
c                                 one site solution
            do j = 1, nstot(ids)
               x3(ind,1,j) = sxs(ixp(id)+j) 
            end do 

         else if (ispg(ids,1).gt.1) then 
c                                 multi-site solution
            jcoor = icoor(id)

            do i = 1, istg(ids)
               do j = 1, ispg(ids,i)
                  jcoor = jcoor + 1
                  x3(ind,i,j) = xcoor(jcoor)
               end do 
            end do 

         else 
c                                 a dummy site
            x3(ind,1,1) = 1d0
          
            do j = 1, nstot(ids)
               x3(ind,2,j) = sxs(ixp(id)+j) 
            end do 

         end if 

      else 
c                                 an endmember 
         call endcp (ind,id,ids)

      end if

      end 

      double precision function ginc0 (dt,dp,id)
c-----------------------------------------------------------------------
c id indicates a static pseudocompound, use ginc for dynamic compound
c-----------------------------------------------------------------------
      implicit none

      double precision dt,dp,gee

      integer id

      double precision p,t,xco2,u1,u2,tr,pr,r,ps
      common/ cst5 /p,t,xco2,u1,u2,tr,pr,r,ps

      p = p + dp 
      t = t + dt 

      call gphase (id,gee)

      p = p - dp 
      t = t - dt

      ginc0 = gee 

      end 

      subroutine getusv (u,s,v,id,bad)
c-----------------------------------------------------------------------
c getusv computes u,s,v by centered finite differences from the Gibbs energy

c the difference increments are

c dt0, dp0 for 1st order derivatives (entropy,volume and enthalpy)
c-----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer id

      logical bad

      double precision dt0,dp0,dp1,dp2,g0,v,ginc0,s,u

      double precision p,t,xco2,u1,u2,tr,pr,r,ps
      common/ cst5 /p,t,xco2,u1,u2,tr,pr,r,ps

      save dt0
      data dt0/0.5d0/
c----------------------------------------------------------------------

      dp0 = 0.5d-3 * p 
      dp1 = 0.5d-2 * p
      dp2 = 0.5d-1 * p
            
      g0 = ginc0(0d0,0d0,id)
c                                 straight derivatives:
c                                 first order
      if (p-dp0.le.0d0) then 

         v = (ginc0(0d0,dp0,id) - g0)/dp0
         if (v.lt.0d0.or.dabs(v).gt.1d9)  
c                                 expand increment if invalid v
     *   v = (ginc0(0d0,dp1,id) - g0)/dp1
         if (v.lt.0d0.or.dabs(v).gt.1d9)  
c                                 expand increment more if invalid v
     *   v = (ginc0(0d0,dp2,id) - g0)/dp2

      else 

         v = (ginc0(0d0,dp0,id) - ginc0(0d0,-dp0,id))/dp0/2d0
         if ((v.lt.0d0.or.dabs(v).gt.1d9).and.p-dp1.gt.0d0)  
c                                 expand increment if invalid v
     *   v = (ginc0(0d0,dp1,id) - ginc0(0d0,-dp1,id))/dp1/2d0
         if ((v.lt.0d0.or.dabs(v).gt.1d9).and.p-dp2.gt.0d0)  
c                                 expand increment more if invalid v
     *   v = (ginc0(0d0,dp2,id) - ginc0(0d0,-dp2,id))/dp2/2d0

      end if 
c                                 in case the evaluating routine fails
c                                 on both calls to ginc 
      if (v.eq.0d0) v = 1d0

      s = (ginc0(-dt0,0d0,id) - ginc0(dt0,0d0,id))/dt0/2d0

      u = g0 + t*s - p*v
 
      if (s.lt.0d0.or.v.lt.0d0) then 
         bad = .true.
      else
         bad = .false.
      end if 

      end 

      subroutine pt4sv (ind)
c--------------------------------------------------------------------
c subroutine to recover the p-t condition of discreitization in USV
c calculations.
c---------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer ind,tind,pind

      double precision v,tr,pr,r,ps
      common / cst5 /v(l2),tr,pr,r,ps

      double precision vmax,vmin,dv
      common/ cst9 /vmax(l2),vmin(l2),dv(l2)

      integer iam,jam,tloop,ploop
      common/ cst55 /iam(k1),jam(k1),tloop,ploop
c----------------------------------------------------------------------

      tind = (ind-1)/tloop
      pind = ind - tind*tloop - 1
      v(2) = vmin(2) + tind*dv(2)
      v(1) = vmin(1) + pind*dv(1)

      end 

      subroutine yclos2 (clamda,x,is,iter,opt)
c----------------------------------------------------------------------
c subroutine to identify pseudocompounds close to the solution for 
c subsequent refinement, for iteration > 1. 
c----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer i, is(k21+k5), id, jmin(k19), opt, mpt, iter, tic

      double precision clamda(k21+k5), clam(k19), x(k21)

      integer iopt
      logical lopt
      double precision nopt
      common/ opts /nopt(i10),iopt(i10),lopt(i10)

      integer jphct
      double precision g2, cp2
      common/ cxt12 /g2(k21),cp2(k5,k21),jphct

      integer icomp,istct,iphct,icp
      common/ cst6  /icomp,istct,iphct,icp

      integer npt,jdv
      logical fulrnk
      double precision cptot,ctotal
      common/ cst78 /cptot(k5),ctotal,jdv(k19),npt,fulrnk

      integer hkp,mkp
      common/ cst72 /hkp(k21),mkp(k19)

      integer kkp, np, ncpd, ntot
      double precision cp3, amt
      common/ cxt15 /cp3(k0,k5),amt(k5),kkp(k5),np,ncpd,ntot

      save tic
      data tic/0/
c----------------------------------------------------------------------
c                                 mpt is the number of points refined
c                                 from the previous cycle, opt is the
c                                 number of points in the original 
c                                 solution.
      mpt = npt

      do i = 1, npt
         jmin(i) = 0 
         clam(i) = 1d99
      end do 

      npt = 0

      do i = 1, jphct
c                                 id indicates the original refinement
c                                 point.
         id = hkp(i)
c                                 check the stability of all points 
         if (is(i).ne.1.and.x(i).gt.0d0) then 
c                                 a stable point, add to list
            npt = npt + 1
            jdv(npt) = i

         else if (clamda(i).lt.clam(id)) then 
c                                 find the nearest phase           
            jmin(id) = i
            clam(id) = clamda(i)

         end if 

      end do 

      if (iter.le.iopt(10)) then
c                                 if not done iterating, add the metastable
c                                 phases
         do i = 1, opt
            if (jmin(i).eq.0) cycle 
            npt = npt + 1
            jdv(npt) = jmin(i)
         end do
c                                 sort the phases, this is only necessary if
c                                 metastable phases have been added
         call sortin
c                                 make a pointer to the original refinement 
c                                 point
         do i = 1, npt
            mkp(i) = hkp(jdv(i))
         end do 

      else  
  
         mpt = npt 
         npt = 0  
c                                 check zero modes the amounts
         do i = 1, mpt

            if (x(jdv(i)).ge.nopt(9)) then 
               npt = npt + 1
               amt(npt) = x(jdv(i))
               jdv(npt) = jdv(i)
            else if (lopt(13).and.x(jdv(i)).lt.-nopt(9)
     *                             .and.tic.lt.5) then 

               call warn (2,x(jdv(i)),i,'REBULK')
               tic = tic + 1

               if (tic.eq.5) call warn (49,x(1),2,'YCLOS2')

            end if 

         end do 

         if (npt.ne.icp) then
 
            fulrnk = .false.
         
         else 

            fulrnk = .true.

         end if 


      end if 

c1000  format (/,'**warning ver666** the compositional resolution ',
c     *       'specified for this problem is too',/,' high. The global ',
c     *       'minimum may not be clearly defined. If this ambiguity ',
c     *       'causes',
c     *     /,'spurious results, reduce the resolution by changing any ',
c     *       'of the following keywords ',/,'in perplex_option.dat:',//,
c     *    5x,'increase initial_resolution',/,
c     *    5x,'decrease auto_refine_factor_I',/,
c     *    5x,'decrease iteration (first value)',//,
c     *       'Typically compositional resolution <0.05 mol% causes ',
c     *       'numerical instability',/)   

      end

      subroutine rebulk (static)
c----------------------------------------------------------------------
c upon successful completion of an optimization with either static or
c dynamic pseudocompounds rebulk:
c     1) loads the generic arrays cp3, cptot, ctot3, kkp and x3
c     2) computes the amounts of saturated component phases.
c     3) computes the dependent potentials.
c     4) checks for solvi and homogenizes miscible phases.
c----------------------------------------------------------------------
      implicit none
 
      include 'perplex_parameters.h'

      integer i,j,k,id,ier,tictoc,ipvt(k8)

      logical static, bad

      double precision c(k5),u,comp(k8,k8)

      integer iff,idss,ifug,ifyn,isyn
      common/ cst10  /iff(2),idss(h5),ifug,ifyn,isyn
 
      integer icomp,istct,iphct,icp
      common/ cst6  /icomp,istct,iphct,icp

      double precision cp
      common/ cst12 /cp(k5,k1)

      integer jbulk
      double precision cblk
      common/ cst300 /cblk(k5),jbulk
c                                 adaptive x(i,j) coordinates
      integer jcoct, jcoor, jkp
      double precision zcoor
      common/ cxt13 /zcoor(k20),jcoor(k21),jkp(k21),jcoct
c                                 compositions of stable adaptive
c                                 coordinates (and solution ids).
      integer kkp,np,ncpd,ntot
      double precision cp3,amt
      common/ cxt15 /cp3(k0,k5),amt(k5),kkp(k5),np,ncpd,ntot
c                                 options from perplex_option.dat
      integer iopt
      logical lopt
      double precision nopt
      common/ opts /nopt(i10),iopt(i10),lopt(i10)

      integer ikp
      common/ cst61 /ikp(k1)

      integer npt,jdv
      logical fulrnk
      double precision cptot,ctotal
      common/ cst78 /cptot(k5),ctotal,jdv(k19),npt,fulrnk

      integer iam,jam,tloop,ploop
      common/ cst55 /iam(k1),jam(k1),tloop,ploop
c                                 hcp is different from icp only if usv
      integer hcp,idv
      common/ cst52  /hcp,idv(k7) 

      double precision mu
      common/ cst330 /mu(k8)

      integer jtest,jpot
      common/ debug /jtest,jpot

      integer ids,isct,icp1,isat,io2
      common/ cst40 /ids(h5,h6),isct(h5),icp1,isat,io2

      logical usv
      integer pindex,tindex
      common/ cst54 /pindex,tindex,usv

      double precision ctot
      common/ cst3  /ctot(k1)

      integer ipoint,imyn
      common/ cst60 /ipoint,imyn

      double precision thermo,uf,us
      common/ cst1 /thermo(k4,k10),uf(2),us(h5)

      double precision g
      common/ cst2 /g(k1)

      integer jphct
      double precision g2, cp2
      common/ cxt12 /g2(k21),cp2(k5,k21),jphct

      save tictoc
      data tictoc/0/
c----------------------------------------------------------------------
      do i = 1, npt

         if (static) then 

            id = iam(jdv(i))
c                                 set identifier flag
            if (id.le.ipoint) then
               kkp(i) = -id
            else  
               kkp(i) = ikp(id)
            end if 

            cptot(i) = ctot(id)
c                                 save g for potential calculation
            mu(i) = g(id)
           
            do j = 1, icomp
               if (j.gt.icp.and.usv) exit
               cp3(j,i) = cp(j,id)
            end do
c                                 set the x3 array
            if (ikp(id).ne.0) call setx3 (i,id,ikp(id))

            if (usv) then 
c                                 usv calculations are currently
c                                 not set up for solutions and use
c                                 only static optimization
               call pt4sv (jam(jdv(i)))

               call getusv (u,cp3(icp1,i),cp3(jbulk,i),id,bad)

            end if 

         else 
c                                 getcmp assigns cp3, cptot, x3, and kkp
            call getcmp (i,jdv(i),jkp(jdv(i)))

         end if          
c                                 convert normalized amounts to molar 
c                                 amounts
         amt(i) = ctotal*amt(i)/cptot(i)
c                                 convert normalized g's to molar g's
         mu(i) = g2(jdv(i))*cptot(i)

      end do 

      if (jbulk.gt.icp) then  
c                                 get the amounts of the saturated phases:
         do i = icp+1, jbulk
c                                 k is the saturated component pointer
            k = i - icp
c                                 initialize bulk                                 
            c(k) = cblk(i)
c                                 save chemical potentials from gproj
            mu(i) = us(k)
c                                 subtract the amount of the component in the 
c                                 phases in the thermodynamic c-space
            do j = 1, npt 
               c(k) = c(k)- amt(j)*cp3(i,j)
            end do 

         end do 

         do i = jbulk, jbulk-icp+1, -1
c                                  cycle through the saturated phases
            npt = npt + 1
            id = idss(i-icp)
c                                  set case for solution in saturated component
c                                  space, the endmember composition is not set,
c                                  this is gonna cause problems, at least for 
c                                  meemum
            if (ikp(id).eq.0) then 
               kkp(npt) = -id
            else 
               write (*,1000) 
               stop 
            end if 
c                                  amount of the staurated phase
            amt(npt) = c(i)/cp(i,id)
c                                  warn on undersaturation
            if (amt(npt).lt.nopt(9)) then 
               if (amt(npt).lt.-nopt(9).and.tictoc.lt.5) 
     *                             call warn (2,amt(npt),i,'REBULK')
               npt = npt - 1
               tictoc = tictoc + 1
               exit
            end if 
c                                  remove the saturated phase from 
c                                  the bulk composition.
            do j = icp+1, i - 1
               c(j) = c(j) - amt(npt)*cp(j,id)
            end do 
c                                  load the saturated phase composition 
            do j = 1, icomp
               cp3(j,i) = cp(j,id)
            end do           

         end do

      end if 

      ntot = npt

      if (usv.or.jpot.eq.0) then
c                                 compute chemical potentials
         if (npt.ne.hcp) then 
c                                 not full rank
            do i = 1, hcp
               mu(i) = nopt(7)
            end do
          
         else 

            do i = 1, hcp
               do j = 1, hcp 
                  comp(i,j) = cp3(j,i)
               end do 
            end do 

            call factor (comp,hcp,ipvt,ier)

            if (ier.eq.1) then 

               do i = 1, hcp
                  mu(i) = nopt(7)
               end do
     
            else 
 
               call subst (comp,ipvt,hcp,mu,ier)

               if (ier.eq.1) then 
                  do i = 1, hcp
                     mu(i) = nopt(7)
                  end do
               end if 
             
            end if 

         end if 

      end if 
c                                 test for solvi and average
c                                 homogeneous phases.
      call avrger
      
1000  format (/,'**error ver901** solutions not allowed in saturated ',
     *   'component composition space',/,'in adaptive optimization ',
     *   'calculations, this limitation can be removed upon request.')

      end

c----------------------------------------------------------------------
  
c TLIB - a library of subprograms called by the PERPLEX programs.

c Copyright (c) 1998 by James A. D. Connolly, Institute for Mineralogy
c & Petrography, Swiss Federal Insitute of Technology, CH-8092 Zurich,
c SWITZERLAND. All rights reserved.
 
c Please do not distribute this source.

c----------------------------------------------------------------------

      subroutine vrsion
c----------------------------------------------------------------------
c a version stamp for each executable
c----------------------------------------------------------------------
	implicit none

      write (*,'(/,a)') 
     *      'Perple_X version 6.6.5.9, compiled 6/20/2011.'

      end

      subroutine redop1 (output,opname)
c----------------------------------------------------------------------
c redop1 - redop1 looks for the perplex_option.dat file, if it finds
c the option file it scans the file for keywords and sets options
c accordingly.

c iam - indicates calling program 1 - vertex
c                                 2 - meemum
c                                 3 - werami
c                                 all other values no output

c option variables - keyword associations

c lopt(1)  - closed_c_space -> T = closed compositional variables
c lopt(2)  - set in getprp -> T = cumulative modes 
c lopt(3)  - hard_limits -> T = on
c lopt(4)  - Anderson-Gruneisen -> Helffrich Murnaghan correction
c lopt(5)  - site_check -> T = reject invalid site fractions
c lopt(6)  - melt_is_fluid -> T = classify melts as fluids in output
c lopt(7)  - saturated phase in data base, set by topN2
c lopt(8)  - approx_alpha -> T = approx exp(x)=1+x in volume integral
c lopt(9)  - automatic solvus tolerance -> T
c lopt(10) - pseudocompound_glossary
c lopt(11) - auto_refine_file
c lopt(12) - option_list_files
c lopt(13) - true if user set finite zero mode check
c lopt(14) - logarithmic_p
c lopt(15) - spreadsheet format -> T = explicit output of independent variables 
c lopt(16) - bounds, T -> VRH averaging, F -> HS
c lopt(17) - explicit_bulk_modulus, T-> use if available.
c nopt(5)  - speciation_tolerance
c nopt(8)  - solvus_tolerance
c nopt(20) - T_melt - kill melt endmembers at T < nopt(20)
c----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer ier, jer, i, loopx, loopy

      logical output

      character*3 key*22, val, valu(i10), nval1*12, nval2*12,
     *            nval3*12,opname*100,strg*40,strg1*40

      double precision dnan

      integer jtest,jpot
      common/ debug /jtest,jpot

      character*100 prject,tfname
      common/ cst228 /prject,tfname

      integer iopt
      logical lopt
      double precision nopt
      common/ opts /nopt(i10),iopt(i10),lopt(i10)

      double precision bp1,bm1,bpm,lbpm
      common/ cst46 /bp1,bm1,bpm,lbpm

      integer grid
      double precision rid 
      common/ cst327 /grid(5,2),rid(2)

      integer isec,icopt,ifull,imsg,io3p
      common/ cst103 /isec,icopt,ifull,imsg,io3p

      integer io3,io4,io9
      common / cst41 /io3,io4,io9

      integer iam
      common/ cst4 /iam
c----------------------------------------------------------------------
c                                 default option values:

c                                 closed or open compositional space
      lopt(1) = .true.
c                                 Anderson-Gruneisen correction
      lopt(4) = .true.
c                                 reject invalid site fractions
      lopt(5) = .true.
c                                 melt_is_fluid
      lopt(6) = .false.
c                                 approx_alpha
      lopt(8) = .true.
c                                 automatic solvus tolerance
      lopt(9) = .true.
c                                 pseudocompound_file
      lopt(10) = .false.
c                                 auto_refine_file
      lopt(11) = .false.
c                                 option_list_files
      lopt(12) = .false.
c                                 user set finite zero mode
      lopt(13) = .false.
c                                 logarithimic P
      lopt(14) = .false.
c                                 spreadsheet format
      lopt(15) = .false.
c                                 minimum replicate label distance
      nopt(4) = 0.025
c                                 speciation_tolerance
      nopt(5) = 1d-3
c
      iopt(2) = 0 
      valu(2) = 'mol'
      iopt(3) = 0 
      valu(3) = 'vol'
c                                 interpolation keyword
      iopt(4) = 0
      valu(4) = 'on '
c                                 extrapolation keyword
      iopt(5) = 0
      valu(5) = 'off'
c                                 vrh_weighting keyword
      nopt(6) = 0.5d0
c                                 bad_number keyword
      nopt(7) = 0d0
c                                 zero_mode (<0 off)
      nopt(9) = 1d-6
c                                 tolerance below which a component is considered to 
c                                 be zero during fractionation
      nopt(11) = 1d-6
c                                 number of iterations for
c                                 pseudocompound refinement
      iopt(10) = 4
c                                 number of increments used
c                                 in refinement
      iopt(11) = 3
c                                 max number of points to 
c                                 be refined in addition to 
c                                 active points
      iopt(12) = 4
c                                 
c                                 quench temperature (K)
      nopt(12) = 0d0
c                                 initial resolution for adaptive 
c                                 refinement
      nopt(13) = 0.1d0
c                                 solvus_tolerance keyword
      nopt(8) = nopt(13)
c                                 reach for adaptive refinement
      nopt(14) = 0.9d0
c                                 perturbation to eliminate pseudocompound
c                                 degeneracies
      nopt(15) = 5d-3
c                                 poisson ratio to be use for calculating
c                                 missing shear moduli
      valu(15) = 'on '
      nopt(16) = 0.35d0
      iopt(16) = 1
c                                 stretch factor (b-1) for conformal
c                                 subdivision
      bm1 = 0.0164d0
c                                 subdivision model, 0 - solution model
c                                 1 - cartesian, 2 - stretch
      iopt(13) = 0 
      valu(13)  = 'off'
c                                 autorefine, 2 - automatic, 1 - manual, 0 - no
      iopt(6) = 2
      valu(6) = 'aut'
c                                 increase in resolution for adaptive minimization 
      nopt(17) = 3d0 
c                                 increase in resolution for composition and mixed variable diagram calculations
      nopt(18) = 1d1
c                                 increase in resolution for Schreinemakers diagram calculations   
      nopt(19) = 3d0 
c                                 T_melt cutoff 
      nopt(20) = 873d0
c                                 fractional slop on autorefine limit
      nopt(3) = 1d-2
c                                 hard_limits for solution model refinement
      valu(16) = 'off'
      lopt(3) = .false.
c                                 compare local and max disorder state for o-d models
      valu(17) = 'on '
      iopt(17) = 1
c                                 assume linear boundaries within a cell during gridded minimization
      valu(18) = 'on '
      iopt(18) = 1
c                                 averaging scheme
      valu(19) = 'VRH'
      lopt(16) = .true.
c                                 use explicit bulk modulus when available
      lopt(17) = .false.
c                                 -------------------------------------
c                                 werami output options:

c                                 cumulative_modes
c     valu(15) = 'off'
c     iopt(15) = 0
c                                 -------------------------------------
c                                 for gridded minimization:
c                                 # nodes in i direction
      grid(1,1) = 20 
      grid(1,2) = 40
c                                 # nodes in j direction
      grid(2,1) = 20 
      grid(2,2) = 40
c                                 # of levels
      grid(3,1) = 1
      grid(3,2) = 4
c                                 1d fractionation path
      grid(4,1) = 20 
      grid(4,2) = 150
c                                 -------------------------------------
c                                 for schreinemakers etc:
c                                 max variance 
      grid(5,1) = 1
      grid(5,2) = 99
c                                 default increment (relative)
      rid(1) = 0.1d0
      rid(2) = 0.025d0
c                                 reaction format
      ifull = 0 
      valu(7) = 'min'
c                                 reaction list 
      jtest = 0 
      valu(9) = 'off'
c                                 console msgs
      imsg = 0
      valu(8) = 'on '
c                                 efficiency level
      isec = 3
c                                 short print
      io3p = 1
      valu(10) = 'on '
c                                 print dependent potentials
      jpot = 1
      valu(11) = 'off'
c                                 -------------------------------------
c                                 look for file
      open (n8, file = opname, iostat = jer, status = 'old')
c                                 if no option file (jer.ne.0) use defaults
      ier = jer
c                                 read cards to end of 
c                                 option file
      do while (ier.eq.0) 

         call redcd1 (n8,ier,key,val,nval1,nval2,nval3,strg,strg1)
c                                 ier ne 0 bad record or eof
         if (ier.ne.0) exit 
c                                 if here we should have a keyword and
c                                 value
         if (key.eq.'composition') then 
c                                 phase composition key
            if (val.eq.'wt') then
               iopt(2) = 1
            else 
               iopt(2) = 0
            end if 
            valu(2) = val

         else if (key.eq.'proportions') then 
c                                 phase proportion key
            if (val.eq.'wt') then
               iopt(3) = 1
            else if (val.eq.'mol') then 
               iopt(3) = 2 
            else 
c                                 volume is default
               iopt(3) = 0
            end if 
            valu(3) = val

         else if (key.eq.'interpolation') then 
c                                 interpolation key
            if (val.eq.'off') iopt(4) = 0
            valu(4) = val
            if (val.eq.'on ') read (nval1,*) iopt(4)

         else if (key.eq.'extrapolation') then 
c                                 extrapolation key
            if (val.eq.'on ') then
               iopt(5) = 0
            else 
               iopt(5) = 1
            end if 
            valu(5) = val 

         else if (key.eq.'bounds') then 
c                                 
            if (val.eq.'HS'.or.val.eq.'hs')  then
              lopt(16) = .false.
              valu(19) = 'HS '
            end if 

         else if (key.eq.'vrh/hs_weighting'.or.
     *            key.eq.'vrh_weighting') then 
c                                 vrh/hs weighting key
            read (strg,*) nopt(6)

         else if (key.eq.'bad_number') then
c                                 bad number key 
            if (val.eq.'NaN'.or.val.eq.'nan') then
               nopt(7) = dnan()
            else 
               read (strg,*) nopt(7)
            end if 

         else if (key.eq.'solvus_tolerance') then 

            if (val.ne.'aut') then 
               lopt(9) = .false.
               read (strg,*) nopt(8)
            end if 

         else if (key.eq.'speciation_tolerance') then 

            read (strg,*) nopt(5)

         else if (key.eq.'zero_bulk') then
c                                 zero_bulk key
            read (strg,*) nopt(11)

         else if (key.eq.'zero_mode') then
c                                 zero_mode key
            read (strg,*) nopt(9)
            if (nopt(9).gt.0d0) lopt(13) = .true.

         else if (key.eq.'iteration') then
c                                 max iteration key
            read (strg,*)  iopt(10)
            read (nval1,*) iopt(11)
            read (nval2,*) iopt(12)

         else if (key.eq.'initial_resolution') then
c                                 initial_resolution key 
            read (strg,*) nopt(13)

         else if (key.eq.'reach_factor') then 
c                                 reach_factor key
            read (strg,*) nopt(14)

         else if (key.eq.'stretch_factor') then
c                                 stretch_factor key = b - 1       
            read (strg,*) bm1

         else if (key.eq.'subdivision_override') then 
c                                 subdivision overide key
            valu(13) = val

            if (val.eq.'lin') then
               iopt(13) = 1
            else if (val.eq.'str') then
               iopt(13) = 2
            else 
               iopt(13) = 0 
            end if 

         else if (key.eq.'auto_refine') then
c                                 autorefine
            valu(6) = val

            if (val.eq.'off') then
               iopt(6) = 0
            else if (val.eq.'man') then
               iopt(6) = 1
            end if 

            if (nval1.gt.'0') then 
               write (*,1100) nval1
               stop
            end if 

         else if (key.eq.'auto_refine_factor_I') then
c   
            read (strg,*) nopt(17)

         else if (key.eq.'auto_refine_factor_II') then
c   
            read (strg,*) nopt(18)

         else if (key.eq.'auto_refine_factor_III') then
c   
            read (strg,*) nopt(19)

         else if (key.eq.'auto_refine_slop') then
c   
            read (strg,*)  nopt(3)

         else if (key.eq.'x_nodes') then
c                                 number of x nodes at level 1 before autorefine
            read (strg,*) grid(1,1)
c                                 number of x nodes for autorefine
            read (nval1,*) grid(1,2)

         else if (key.eq.'y_nodes') then
c                                 number of y nodes at level 1
            read (strg,*) grid(2,1)
c                                 number of y nodes for autorefine
            read (nval1,*) grid(2,2)

         else if (key.eq.'grid_levels') then 
c                                 number of grid levels before autorefine
            read (strg,*) grid(3,1)
c                                 number of grid levels for autorefine
            read (nval1,*) grid(3,2)

         else if (key.eq.'1d_path') then 
c                                 number of grid points for 1d path before autorefine
            read (strg,*) grid(4,1)
c                                 number of grid points for 1d path for autorefine
            read (nval1,*) grid(4,2)

         else if (key.eq.'variance') then 
c                                 max variance of traced equilibria before autorefine
            read (strg,*) grid(5,1)
c                                 max variance of traced equilibria for autorefine
            read (nval1,*) grid(5,2)      

         else if (key.eq.'increment') then 
c                                 default exploratory relative increment    
            read (strg,*) rid(1)  
c                                 default autorefine relative increment
            read (nval1,*) rid(2)

         else if (key.eq.'reaction_format') then 

            valu(7) = val

            if (val.eq.'ful') then 
               ifull = 1
            else if (val.eq.'sto') then 
               ifull = 2
            else if (val.eq.'S+V') then 
               ifull = 3
            else if (val.eq.'eve') then
               ifull = 4
            else 
               valu(7) = 'min'
            end if 
  
         else if (key.eq.'console_messages') then 
            
            if (val.eq.'off') then 
               valu(8) = val
               imsg = 1
            else 
               valu(8) = 'on '
            end if 

         else if (key.eq.'reaction_list') then

            if (val.eq.'on ') then 
               valu(9) = val
               jtest = 3 
            else 
               valu(9) = 'off'
            end if

         else if (key.eq.'efficiency') then 

            read (strg,*) isec

            if (isec.lt.1.or.isec.gt.5) isec = 3 

         else if (key.eq.'short_print') then 

            if (val.eq.'off') then 
               io3p = 0
               valu(10) = 'off'
            end if 

         else if (key.eq.'dependent_potentials') then 

            if (val.eq.'on ') then 
               jpot = 0
               valu(11) = 'on '
            end if

         else if (key.eq.'replicate_label') then 
c                                 replicate lable tolerance for PSSECT
c                                 replicate fields are labled only if they
c                                 are further apart than the normalized distance 
c                                 specified by this keyword.   
            read (strg,*) nopt(4)

         else if (key.eq.'hard_limits') then 

            if (val.eq.'on ') then 
               lopt(3) = .true.
            else 
               valu(16) = 'off'
            end if

         else if (key.eq.'T_stop') then 
c                                 equilibrium cutoff T (K)    
            read (strg,*) nopt(12)

         else if (key.eq.'T_melt') then 
c                                 cutoff T (K) for melt endmember stability    
            read (strg,*) nopt(20)

         else if (key.eq.'order_check') then 
c                                 compare local and max disorder state for o-d models
            if (val.eq.'off') then 
               iopt(17) = 0
               valu(17) = 'off'
            end if 

         else if (key.eq.'linear_model') then   
c                                 assume linear boundaries within a cell during gridded minimization
            if (val.eq.'off') then 
               iopt(18) = 0
               valu(18) = 'off'
            end if 

         else if (key.eq.'closed_c_space') then
 
            if (val.ne.'T') lopt(1) = .false. 

         else if (key.eq.'logarithmic_p') then
 
            if (val.eq.'T') lopt(14) = .true. 

         else if (key.eq.'spreadsheet') then
 
            if (val.eq.'T') lopt(15) = .true. 

         else if (key.eq.'Anderson-Gruneisen') then

            if (val.eq.'F') lopt(4) = .false.

         else if (key.eq.'approx_alpha') then

            if (val.eq.'F') lopt(8) = .false.

         else if (key.eq.'site_check') then 

            if (val.eq.'F') lopt(5) = .false.

         else if (key.eq.'melt_is_fluid') then 

            if (val.eq.'T') lopt(6) = .true.

         else if (key.eq.'pc_perturbation') then
c                                 perturbation to eliminate pseudocompound degeneracies  
            read (strg,*) nopt(15)

         else if (key.eq.'pseudocompound_file') then

            if (val.eq.'T') lopt(10) = .true.

         else if (key.eq.'auto_refine_file') then

            if (val.eq.'T') lopt(11) = .true.

         else if (key.eq.'option_list_files') then

            if (val.eq.'T') lopt(12) = .true.

         else if (key.eq.'explicit_bulk_modulus') then 

            if (val.eq.'T') lopt(17) = .true.

         else if (key.eq.'poisson_ratio') then 
c                                 handle missing shear moduli
            if (val.eq.'on ') then
               read (nval1,*) nopt(16)
            else if (val.eq.'off') then 
               valu(15) = val
               iopt(16) = 0
            else if (val.eq.'all') then 
               read (nval1,*) nopt(16)
               valu(15) = val
               iopt(16) = 2
            end if             

         else if (key.ne.'|') then 

            write (*,1110) key

         end if 

      end do 
    
      close (n8)
c                                 -------------------------------------
c                                 write and optional file choices
      if (jer.ne.0) then 
         write (*,1120) opname
      else 
         write (*,1130) opname
      end if

      if (iam.eq.1) then 
c                                 vertex only files:
         if (icopt.eq.1.or.icopt.eq.3) then 

            if (jtest.eq.3) then 
               call mertxt (tfname,prject,'_reaction_list.txt',0)
               open (n6,file=tfname)
            else 
               tfname = 'not requested'
            end if 

            write (*,1170) tfname

         end if 
c                                 auto refine summary
         if (iopt(6).ne.0.and.io9.eq.0) then
 
            if (lopt(11)) then 
               call mertxt (tfname,prject,'_auto_refine.txt',0)
            else 
               tfname = 'not requested'
            end if 

            write (*,1150) tfname

         end if 
 
      end if 

c                                 pseudocompound glossary
      if (io9.eq.0.and.iam.lt.3) then
 
         if (lopt(10)) then 
            call mertxt (tfname,prject,'_pseudocompound_glossary.txt',0)
         else 
            tfname = 'not requested'
         end if 

         write (*,1140) tfname

      end if 
c                                 computational options this is redundant
      if (iam.lt.4) then 
         if (lopt(12)) then 
            if (iam.eq.1) then           
               call mertxt (tfname,prject,'_VERTEX_options.txt',0)
            else if (iam.eq.2) then 
               call mertxt (tfname,prject,'_MEEMUM_options.txt',0)
            else if (iam.eq.3) then 
               call mertxt (tfname,prject,'_WERAMI_options.txt',0)
            end if 
         else 
            tfname = 'not requested'
         end if 
 
         write (*,1160) tfname
      end if 
c                                 -------------------------------------
c                                 error traps:
      if (iopt(10).gt.0) then 
         iopt(5) = 0
         valu(5) = 'off'
      end if 

      if (iopt(11).lt.3) then 
         write (*,1040)
         iopt(11) = 3
      end if 

      if (iopt(12).gt.7.or.iopt(12).lt.3) then 
         write (*,1090)
         iopt(12) = 4
      end if 
c                                 reach factor
      if (2d0*nopt(14).gt.dfloat(iopt(11)).or.nopt(14).le.0d0) then
         write (*,1030)
         nopt(14) = 0.9d0 
      end if 
c                                 initial resolution
      if (nopt(13).ge.1d0.or.nopt(13).lt.0d0) then 
         write (*,1050)
         nopt(13) = 0.1d0
      end if 
c                                 stretching parameters
      if (bm1.lt.0d0) then 
         write (*,1060)
         bm1 = 0.0164
      end if 
c                                 auto-refine factor II
      if (icopt.eq.1.and.nopt(19).lt.1d0) then 
c                                 auto-refine factor III
         nopt(19) = 3d0
         write (*,1070) nopt(19)
      else if (icopt.le.3.and.nopt(18).lt.1d0) then 
         nopt(18) = 1d1
         write (*,1070) nopt(18)
      else if (nopt(17).lt.1d0) then 
c                                 auto-refine factor I
         nopt(17) = 3d0
         write (*,1070) nopt(17)
      end if 
c                                 auto-refine slop
      if (nopt(3).lt.0d0.or.nopt(3).gt.1d0) then 
         nopt(3) = 0.01d0
         write (*,1080)
      end if 
c                                 solvus tolerance
      if (lopt(9)) nopt(8) = nopt(13)     
c                                 grid parameters
      do i = 1, 2

         if (grid(3,i).le.0.or.grid(3,i).gt.l8) grid(3,i) = 4

         loopy = (grid(2,i)-1) * 2**(grid(3,i)-1) + 1
         loopx = (grid(1,i)-1) * 2**(grid(3,i)-1) + 1

         if (loopy.gt.l7) then 
            call warn (92,nopt(1),loopy,'y_node')
            grid(2,i) = (l7 - 1)/2**(grid(3,i)-1) + 1
         end if 

         if (loopx.gt.l7) then 
            call warn (92,nopt(1),loopx,'x_node')
            grid(1,i) = (l7 - 1)/2**(grid(3,i)-1) + 1
         end if 

         if (grid(4,i).gt.l7) then 
            call warn (92,nopt(1),loopx,'1dpath')
            grid(4,i) = l7 - 1
         end if  

         if (grid(5,i).lt.1) then 
            call warn (113,rid(i),grid(5,i),'VARIAN')
            grid(5,i) = 1
         end if 

         if (rid(i).lt.1d-2) then 
            call warn (114,rid(i),i,'INPUT1')
         end if 

      end do
c                                 stretching
      bp1 = 2d0 + bm1
      bpm = bp1/bm1
      lbpm = dlog(bpm)
c                                 --------------------------------------
c                                 program/computation specific settings
c                                 meemum, turn autorefine off.
      if (iam.eq.2) iopt(6) = 0 
c                                 set autorefine factor
      if (icopt.eq.1) then
         nopt(17) = nopt(19)
      else if (icopt.le.3) then 
         nopt(17) = nopt(18)
      end if 
c                                 compute resolution 
      if (iam.eq.1.and.icopt.le.3) then 
         nopt(10) = nopt(13)
      else
         nopt(10) = 2d0*nopt(13)*nopt(14)*
     *              (nopt(14)/dfloat(iopt(11)))**iopt(10)
      end if 
c                                 --------------------------------------
c                                 output
      if ((iam.eq.1.and.output).or.iam.eq.2
     *                         .or.iam.eq.3
     *                         .or.iam.eq.5) then
c                                 console
         call outopt (6,valu)

         if (lopt(12).and.iam.ne.5) then 
c                                 file version, create the file name 
            if (iam.eq.1) then           
               call mertxt (tfname,prject,'_VERTEX_options.txt',0)
            else if (iam.eq.2) then 
               call mertxt (tfname,prject,'_MEEMUM_options.txt',0)
            else if (iam.eq.3) then 
               call mertxt (tfname,prject,'_WERAMI_options.txt',0)
            end if 

            open (n8, file = tfname)
            call outopt (n8,valu)
            close (n8) 

            write (*,1000) tfname

         end if 

      end if  
c                                 -------------------------------------
c                                 recalculate parameters:
c                                 proportionality constant for shear modulus
      nopt(16) = 1.5d0*(1d0-2d0*nopt(16))/(1d0+nopt(16))
c                                 the value of nopt(10) is multiplied to 
c                                 give the relaxation bounds.
      nopt(10) = 1d1*nopt(10)
      if (nopt(10).gt.nopt(13)) nopt(10) = nopt(13)

1000  format ('Context specific options are echoed in: ',a,/)
1030  format (/,'Warning: the reach_factor cannot exceed value2 of the',
     *         ' iteration keyword.',/,'the keyword will be',
     *         ' assigned its default value.',/)
1040  format (/,'Warning: value2 of the iteration keyword must be ',
     *         ' >= 3',/,'value2 will be',
     *         ' assigned its default value.',/)
1050  format (/,'Warning: initial_resolution keyword must be ',
     *         '< 1',/,'the keyword will be',
     *         ' assigned its default value.',/)
1060  format (/,'Warning: the stretch_factor cannot be less than zero',
     *        /,' the keyword will be  assigned its default value',/)
1070  format (/,'Warning: auto_refine_factors must be ',
     *         '> 1',/,'the keyword will be',
     *         ' assigned its default value (',i2,').',/)
1080  format (/,'Warning: auto_refine_slop must be ',
     *         ' >=0 and <1',/,'the keyword will be',
     *         ' assigned its default value.',/)
1090  format (/,'Warning: value3 of the iteration keyword must be ',
     *         ' >2 and <8',/,'value3 will be',
     *         ' assigned its default value [4].',/)
1100  format (/,'Error: data (',a
     *       ,') follows the auto_refine keyword value '
     *       ,'most probably',/,'you are using an obsolete copy of ',
     *        'perplex_option.dat recopy or edit the file.',/)
1110  format (/,'Warning: unrecognized option text: ',a,/,
     *       'If the text is intentional, check spelling and case.',/) 
1120  format (/,'Warning: the Perple_X option file: ',a,/,
     *       'was not found, default option values will be used.',/) 
1130  format (/,'Reading computational options from: ',a)
1140  format ('Writing pseudocompound glossary to file: ',a)
1150  format ('Writing auto refine summary to file: ',a)
1160  format ('Writing computational option summary to file: ',a)
1170  format ('Writing complete reaction list to file: ',a)
      end 

      subroutine outopt (n,valu)
c----------------------------------------------------------------------
c outopt - for program IAM, outputs context specific options to LUN N,
c called by redop1  
c----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer i, len, n

      character*3 valu(i10), nval1*12, text(14)*1

      integer iopt
      logical lopt
      double precision nopt
      common/ opts /nopt(i10),iopt(i10),lopt(i10)

      double precision bp1,bm1,bpm,lbpm
      common/ cst46 /bp1,bm1,bpm,lbpm

      integer grid
      double precision rid 
      common/ cst327 /grid(5,2),rid(2)

      logical oned
      common/ cst82 /oned

      integer icont
      double precision dblk,cx
      common/ cst314 /dblk(3,k5),cx(2),icont

      integer isec,icopt,ifull,imsg,io3p
      common/ cst103 /isec,icopt,ifull,imsg,io3p

      integer iam
      common/ cst4 /iam
c----------------------------------------------------------------------
c                                 generic blurb
      if (iam.eq.1) then 
         write (n,1000) 'VERTEX'
      else if (iam.eq.2) then 
         write (n,1000) 'MEEMUM'
      else if (iam.eq.3) then 
         write (n,1000) 'WERAMI'
      else if (iam.eq.5) then 
         write (n,1000) 'FRENDLY' 
      end if 

      if (iam.le.2) then 
c                                 VERTEX/MEEMUM:
c                                 solvus tolerance text
         if (lopt(9)) then 

           nval1 = 'aut    '

         else 

           call numtxt (nopt(8),text,len)
           if (len.gt.14) len = 14
           write (nval1,'(14a)') (text(i),i=1,len)

         end if 

         if (iam.eq.1) write (n,1015) valu(6)
c                                 context specific parameters:
         if (icopt.le.3.and.iam.eq.1) then 
c                                 non-adaptive calculations
            if (iopt(6).ne.0) then
c                                 auto refine
               if (icopt.eq.1) then 
c                                 schreinemakers
                  write (n,1140) nopt(17)
               else
c                                 composition and mixed variable
                  write (n,1150) nopt(17)

               end if
c                                 auto-refine slop
               write (n,1260) nopt(3)

            end if   
c                                 reaction format and lists
            if (icopt.gt.0) then

               write (n,1160) grid(5,1),grid(5,2),rid(1),rid(2), 
     *                        isec,valu(7),valu(9),valu(8),valu(10)

            end if                     

         else 
c                                 iopt(6) is automatically off
c                                 for meemum             
            if (iopt(6).ne.0) then 
               write (n,1170) nopt(17)
               write (n,1260) nopt(3)
            end if 
c                                 adaptive optimization
            write (n,1180) nopt(9),nopt(11),iopt(10),iopt(11),
     *                     iopt(12),nopt(14)
c                                 gridding parameters
            if (iam.eq.1.and.icopt.eq.5.and.oned) then
c                                 1d multilevel grid
               write (n,1190) grid(2,1),grid(2,2),l7,
     *                  (grid(2,1)-1) * 2**(grid(3,1)-1) + 1,
     *                  (grid(2,2)-1) * 2**(grid(3,2)-1) + 1,
     *                  grid(3,1),grid(3,2),l8

            else if (iam.eq.1.and.icopt.eq.5) then
c                                 2d multilevel grid
               write (n,1200) grid(1,1),grid(1,2),l7,
     *                  (grid(1,1)-1) * 2**(grid(3,1)-1) + 1,
     *                  (grid(1,2)-1) * 2**(grid(3,2)-1) + 1,
     *                  grid(2,1),grid(2,2),l7,
     *                  (grid(2,1)-1) * 2**(grid(3,1)-1) + 1,
     *                  (grid(2,2)-1) * 2**(grid(3,2)-1) + 1,
     *                  grid(3,1),grid(3,2),l8,valu(18)

            else if (iam.eq.1.and.(icopt.eq.7.or.icopt.eq.10)) then 
c                                 1d fractionation grid
                write (n,1210) grid(4,1),grid(4,2),l7

            end if 
c                                 closed or open composition space
            if (iam.eq.1.and.icont.gt.1) write (n,1220) lopt(1)

         end if 
c                                 generic subdivision parameters:      
         write (n,1010) nopt(13),bm1,valu(13),valu(16)
c                                 pc-perturbation
         if (iam.eq.1.and.icopt.le.3) write (n,1011) nopt(15)
c                                 generic thermo parameters:
         write (n,1012) nval1,nopt(5),nopt(12),nopt(20),valu(17),
     *                     lopt(8),lopt(4),lopt(5)

         if (iam.eq.1.and.icopt.ne.1) then 
c                                 vertex output options, dependent potentials
            write (n,1013) valu(11)
c                                 logarithmic_p, bad_number
            if (icopt.gt.3) write (n,1014) lopt(14),nopt(7)

         end if 

      end if

      if (iam.eq.3) then 
c                                 WERAMI input/output options
         write (n,1230) lopt(15),lopt(14),nopt(7),(valu(i),i=2,5),
     *                  lopt(6)
c                                 WERAMI info file options
         write (n,1241) lopt(12)       
c                                 WERAMI thermodynamic options
         write (n,1016) lopt(8),lopt(4)

      else if (iam.eq.2) then 
c                                 MEEMUM input/output options
         write (n,1231) lopt(14),nopt(7),(valu(i),i=2,3),lopt(6)

      else if (iam.eq.5) then 
c                                 FRENDLY input/output options
         write (n,1232) lopt(15),lopt(14),nopt(7),lopt(6)

      end if 
c                                 seismic property options
      if (iam.eq.2.or.iam.eq.3.or.iam.eq.5) write (n,1233) valu(19),
     *                                nopt(6),lopt(17),valu(15),nopt(16)
c                                 FRENDLY thermo options
      if (iam.eq.5) write (n,1016) lopt(8),lopt(4) 

      if (iam.le.2) then 
c                                 info file options
         write (n,1240) lopt(12),lopt(10)
         if (iam.eq.1) write (n,1250) lopt(11)

      end if 
c                                 resolution blurb
      if (iam.le.2.and.nopt(13).gt.0d0) then

         if (iam.eq.2.or.iopt(6).eq.0) then
c                                 meemum or autorefine off
            write (n,1090) nopt(10)*1d2
         else 
            write (n,1095) nopt(10)*1d2,nopt(10)*1d2/nopt(17)
         end if 

      end if 

      write (n,1020) 

1000  format (/,'Perple_X computational option settings for ',a,':',//,
     *      '    Keyword:               Value:     Permitted values ',
     *          '[default]:')
1010  format (/,2x,'Solution subdivision options:',//,
     *        4x,'initial_resolution     ',f4.2,7x,
     *           '0->1 [0.1], 0 => off',/,
     *        4x,'stretch_factor         ',f5.3,6x,'>0 [0.0164]',/,
     *        4x,'subdivision_override   ',a3,8x,'[off] lin str',/,
     *        4x,'hard_limits            ',a3,8x,'[off] on')
1011  format (4x,'pc_perturbation        ',f6.4,5x,'[5d-3]')
c                                 generic thermo options
1012  format (/,2x,'Thermodynamic options:',//,
     *        4x,'solvus_tolerance       ',a7,4x,          
     *           '[aut] or 0->1; aut = automatic, 0 => ',
     *           'p=c pseudocompounds, 1 => homogenize',/,
     *        4x,'speciation_tolerance   ',e7.1,4x,             
     *       '0->1 [1e-3]; order-disorder speciation precision',/,
     *        4x,'T_stop (K)             ',f6.1,5x,'[0]',/,
     *        4x,'T_melt (K)             ',f6.1,5x,'[873]',/,
     *        4x,'order_check            ',a3,8x,'off [on]',/,
     *        4x,'approx_alpha           ',l1,10x,'[T] F',/,
     *        4x,'Anderson-Gruneisen     ',l1,10x,'[T] F',/,
     *        4x,'site_check             ',l1,10x,'[T] F')
1013  format (/,2x,'Input/Output options:',//,
     *        4x,'dependent_potentials   ',a3,8x,'off [on]')
1014  format (4x,'logarithmic_p          ',l1,10x,'[F] T',/,
     *        4x,'bad_number          ',f7.1,7x,'[0.0]')
1015  format (/,2x,'Auto-refine options:',//,
     *        4x,'auto_refine            ',a3,8x,'off [manual] auto')
c                                 thermo options for frendly
1016  format (/,2x,'Thermodynamic options:',//,
     *        4x,'approx_alpha           ',l1,10x,'[T] F',/,
     *        4x,'Anderson-Gruneisen     ',l1,10x,'[T] F')
1020  format (/,'To change these options see: ',
     *        'www.perplex.ethz.ch/perplex_options.html',/)      
1090  format (/,2x,'Worst case (Cartesian) compositional resolution: ',
     *        f7.3,' mol %')
1095  format (/,2x,
     *        'Worst case (Cartesian) compositional resolution (mol %)',
     *        ': ',//,4x,'Exploratory stage: ',f7.3,/,
     *                4x,'Auto-refine stage: ',f7.3)
1140  format (4x,'auto_refine_factor_III ',f4.1,7x,'>=1 [3]')
1150  format (4x,'auto_refine_factor_II  ',f4.1,8x,'>=1 [10]')
1160  format (/,2x,'Schreinemakers and Mixed-variable diagram ',
     *           'options:',//,
     *        4x,'variance               ',i2,' /',i2,5x,
     *           '[1/99], >0, maximum true variance',/,
     *        4x,'increment           ',f5.3,'/',f5.3,3x,
     *           '[0.1/0.025], ',
     *           'default search/trace variable increment',/,
     *        4x,'efficiency               ',i1,8x,'[3] >0 < 6',/,      
     *        4x,'reaction_format        ',a3,8x,'[min] ',
     *           'full stoichiometry S+V everything',/,
     *        4x,'reaction_list          ',a3,8x,'[off] on',/,
     *        4x,'console_messages       ',a3,8x,'[on] off',/,
     *        4x,'short_print_file       ',a3,8x,'[on] off')
1170  format (4x,'auto_refine_factor_I   ',f4.1,7x,'>=1 [3]')
1180  format (/,2x,'Free energy minimization options:',//,
     *        4x,'zero_mode              ',e7.1,4x,
     *           '0->1 [1e-6]; < 0 => off',/,
     *        4x,'zero_bulk              ',e7.1,4x,
     *           '0->1 [1e-6]; < 0 => off'/,
     *        4x,'iteration limit        ',i2,9x,
     *           '>0 [4]; iteration keyword value 1',/,
     *        4x,'refinement factor      ',i2,9x,
     *           '>2*r [12]; iteration keyword value 2',/,
     *        4x,'refinement points      ',i2,9x,
     *           '3->7 [4]; iteration keyword value 3',/,
     *        4x,'reach_factor           ',f3.1,8x,'>0.5 [0.9]')
1190  format (/,2x,'1D grid options:',//,
     *        4x,'y_nodes               ',i3,' /',i3,4x,'[20/40], >0, '
     *          ,'<',i4,'; effective y-resolution ',i4,' /',i4,
     *           ' nodes',/
     *        4x,'grid_levels             ',i1,' /',i2,5x,'[1/4], >0, '
     *          ,'<',i2,/)
1200  format (/,2x,'2D grid options:',//,
     *        4x,'x_nodes               ',i3,' /',i3,4x,'[20/40], >0, '
     *          ,'<',i4,'; effective x-resolution ',i4,' /',i4
     *          ,' nodes',/
     *        4x,'y_nodes               ',i3,' /',i3,4x,'[20/40], >0, '
     *          ,'<',i4,'; effective y-resolution ',i4,' /',i4,
     *           ' nodes',/
     *        4x,'grid_levels             ',i1,' /',i2,5x,'[1/4], >0, '
     *          ,'<',i2,/,
     *        4x,'linear_model             ',a3,6x,'off [on]')
1210  format (/,2x,'Fractionation path options:',//,
     *        4x,'1d_path               ',i3,' /',i3,4x,
     *           '[20/150], >0, <',i4)
1220  format (/,2x,'Composition options:',//,
     *        4x,'closed_c_space         ',l1,10x,'F [T]')
1230  format (/,2x,'Input/Output options:',//,
     *        4x,'spreadsheet            ',l1,10x,'[F] T',/,
     *        4x,'logarithmic_p          ',l1,10x,'[F] T',/,
     *        4x,'bad_number          ',f7.1,7x,'[0.0]',/,
     *        4x,'compositions           ',a3,8x,'wt  [mol]',/,
     *        4x,'proportions            ',a3,8x,'wt  [vol] mol',/,
     *        4x,'interpolation          ',a3,8x,'off [on ]',/,
     *        4x,'extrapolation          ',a3,8x,'on  [off]',/,
     *        4x,'melt_is_fluid          ',l1,10x,'[F] T')
1231  format (/,2x,'Input/Output options:',//,
     *        4x,'logarithmic_p          ',l1,10x,'[F] T',/,
     *        4x,'bad_number          ',f7.1,7x,'[0.0]',/,
     *        4x,'compositions           ',a3,8x,'wt  [mol]',/,
     *        4x,'proportions            ',a3,8x,'wt  [vol] mol',/,
     *        4x,'melt_is_fluid          ',l1,10x,'[F] T')
1232  format (/,2x,'Input/Output options:',//,
     *        4x,'spreadsheet            ',l1,10x,'[F] T',/,
     *        4x,'logarithmic_p          ',l1,10x,'[F] T',/,
     *        4x,'bad_number          ',f7.1,7x,'[0.0]',/,
     *        4x,'melt_is_fluid          ',l1,10x,'[F] T')
1233  format (/,2x,'Seismic velocity options:',//,
     *        4x,'bounds                 ',a3,8x,'HS  [VRH]',/,
     *        4x,'vrh/hs_weighting       ',f3.1,8x,'0->1 [0.5]',/,
     *        4x,'explicit_bulk_modulus  ',l1,10x,'[F] T',/,
     *        4x,'poisson_ratio          ',a3,8x,'off [on ] all; ',
     *        'Poisson ratio = ',f4.2)
1240  format (/,2x,'Information file output options:',//,
     *        4x,'option_list_files      ',l1,10x,'[F] T; ',
     *           'echo computational options',/,
     *        4x,'pseudocompound_file    ',l1,10x,'[F] T; ',
     *           'echo static pseudocompound compositions')
1241  format (/,2x,'Information file output options:',//,
     *        4x,'option_list_files      ',l1,10x,'[F] T; ',
     *           'echo computational options')
1250  format (4x,'auto_refine_file       ',l1,10x,'[F] T; ',
     *           'echo auto-refine compositions')
1260  format (4x,'auto_refine_slop       ',f5.3,6x,'[0.01]')

      end

      subroutine redcd1 (lun,ier,key,val,nval1,nval2,nval3,strg,strg1)
c----------------------------------------------------------------------
c this routine seeks a card containing a keyword and as many as 
c six values (char variables nval, nval1...), the first 3 letters of nval
c is also returned in val, if the second value is longer than 12 characters
c it is also saved in the character variable strg*80
c----------------------------------------------------------------------    
      implicit none

      include 'perplex_parameters.h'

      integer lun, len, ier, iscan, i, iscnlt, ibeg, iend, ist

      character card*240, key*22, val*3,
     *          nval1*12, nval2*12, nval3*12, strg*40, strg1*40

      integer length,iblank,icom
      character chars*1
      common/ cst51 /length,iblank,icom,chars(240)
 
      ier = 0 
      key = ' '

      do 

         read (lun,'(a)',iostat=ier) card
         if (ier.ne.0) return

         if (card.ne.' ') then 

            read (card,'(240a)') chars
c                                 find end of data marker '|'
            len = iscan (1,240,'|') - 1
c                                 find a non blank character
            ibeg = iscnlt (1,len,' ')

            if (ibeg.ge.len) cycle
c                                 for programs (actcor,ctransf) 
c                                 that echo data read the full card
            length = iscnlt (240,1,' ')

            exit 

         end if 

      end do 
c                                 find end of keyword 
      iend = ibeg + 1
      iend = iscan (iend,240,' ') - 1

      if (iend-ibeg.gt.21) then 
         ier = 1
         return
      end if
c                                 load chars into key
      write (key,'(22a1)') (chars(i), i = ibeg, iend)

      iend = iend + 1
c                                 now locate the value:
      ibeg = iscnlt (iend,len,' ')
c                                 now find trailing blank
      iend = iscan (ibeg,240,' ') 
c                                 save longer versions (only on first value)
c                                 this is done in case it's long text or 
c                                 several numbers on certain options. 
      strg = ' '
      strg1 = ' '
      nval1 = '0'
      nval2 = '0'
      nval3 = '0'
      
      if (iend-ibeg.gt.39) iend = ibeg+39
      write (strg,'(40a1)') (chars(i), i = ibeg, iend)
      write (strg1,'(40a1)') (chars(i), i = ibeg, ibeg+39)

      write (val,'(3a1)') (chars(i), i = ibeg, ibeg + 2)
c                                 look for a second value
      ist = iscan (ibeg,240,' ')
      if (ist.gt.len) return

      ibeg = iscnlt (ist,len,' ')
      if (ibeg.gt.len) return 

      iend = iscan (ibeg,len,' ')
      if (iend-ibeg.gt.11) iend = ibeg + 11 
      write (nval1,'(12a1)') (chars(i), i = ibeg, iend)
c                                 look for a third value
      ist = iscan (ibeg,240,' ')
      if (ist.gt.len) return 

      ibeg = iscnlt (ist,len,' ')
      if (ibeg.gt.len) return 

      iend = iscan (ibeg,len,' ')
      if (iend-ibeg.gt.11) iend = ibeg + 11 
      write (nval2,'(12a1)') (chars(i), i = ibeg, iend) 
c                                 look for a fourth value
      ist = iscan (ibeg,240,' ')
      if (ist.gt.len) return

      ibeg = iscnlt (ist,len,' ')
      if (ibeg.gt.len) return

      iend = iscan (ibeg,len,' ')
      if (iend-ibeg.gt.11) iend = ibeg + 11 
      write (nval3,'(12a1)') (chars(i), i = ibeg, iend)

      end

      subroutine rdstrg (lun,nstrg,string,eof)
c----------------------------------------------------------------------
c rdstrg - read 240 column card images from unit lun until a non-blank
c (i.e., with data other than comments) record, then read up to three
c strings from the record. on output nstrg is the number of strings read
c from the record. 
c----------------------------------------------------------------------    
      implicit none

      include 'perplex_parameters.h'

      integer len, lun, iscan, i, iscnlt, ibeg, iend, ier, nstrg, imax

      logical eof

      character card*240, string(3)*8

      integer length,iblank,icom
      character chars*1
      common/ cst51 /length,iblank,icom,chars(240)
c----------------------------------------------------------------------

      eof = .false.

      do 
c                                 read cards till a non-blank
c                                 card.
         read (lun,'(a)',iostat=ier) card

         if (ier.ne.0) then
c                                 error on read = eof
            eof = .true.

            return

         else if (card.ne.' ') then 

            read (card,'(240a)') chars
c                                 find end of data marker '|'
            len = iscan (1,240,'|') - 1

            if (len.eq.0) cycle 
c                                 find a non blank character
            ibeg = iscnlt (1,len,' ')

            exit 

         end if 

      end do 
c 
c                                 we have a non-blank card
      nstrg = 1

      do 
c                                 find the end of the string
         iend = iscan (ibeg,240,' ') - 1

         if (iend-ibeg.gt.7) then

            imax = ibeg + 7 

         else

            imax = iend
 
         end if 
c                                 load chars into string
         write (string(nstrg),'(8a1)') (chars(i), i = ibeg, imax)
c                                 find the next string
         ibeg = iscnlt (iend+1,len,' ')

         if (ibeg.gt.len.or.nstrg.eq.3) return
 
         nstrg = nstrg + 1

      end do 

      end

      subroutine rdnumb (numb,def,inumb,idef,reel)
c----------------------------------------------------------------------
c rdnumb - reads a line from terminal input for numeric input, if blank
c assigns default (def, idef); if non numeric prompts for new value.
c----------------------------------------------------------------------    
      implicit none

      integer inumb, idef, ier

      double precision numb, def

      logical defalt, reel

      character card*80
c----------------------------------------------------------------------
      defalt = .true.

      do 
c                                 read input
         read (*,'(a)',iostat=ier) card
c                                 user enters a blank
         if (ier.ne.0.or.card.eq.' ') exit
c                                 read data from card
         if (reel) then 
            read (card,*,iostat=ier) numb
         else 
            read (card,*,iostat=ier) inumb
         end if 

         if (ier.ne.0) then 
            call rerr 
         else
            defalt = .false.
            exit 
         end if 

      end do 

      if (defalt) then 
         if (reel) then 
            numb = def
         else 
            inumb = idef
         end if 
      end if 

      end


      subroutine eohead (n)
c----------------------------------------------------------------------
c eohead reads cards from n until an 'END ' or 'end ' is found in
c the first 4 columns
c----------------------------------------------------------------------
      implicit none

      integer n, ier

      character tag*4

      rewind n

      do 
         read (n,'(a)',iostat=ier) tag
         if (ier.ne.0) call error (37,1d0,n,'EOHEAD')
         if (tag.eq.'end'.or.tag.eq.'END') exit
      end do 

      end

      subroutine rerror (ier,*)
c---------------------------------------------------------------------
c rerror - routine to check for errors during list directed i/o
 
      implicit none

      integer ier
c---------------------------------------------------------------------
 
      if (ier.eq.0) then
         return
      else
         write (*,1000)
         ier = 0
         return 1
      end if
 
1000  format (/,' Your input is incorrect, probably you are using ',
     *        'a character where',/,' you should be using a number ',
     *        'or vice versa, try again...',/)
 
      end

      subroutine rerr 
c---------------------------------------------------------------------
c rerror - routine to write bad input message for interactive i/o
 
      implicit none
c---------------------------------------------------------------------

      write (*,1000)
 
1000  format (/,'Your input is incorrect, probably you are using ',
     *        'a character where',/,'you should be using a number ',
     *        'or vice versa, try again...',/)
 
      end

      subroutine error (ier,realv,int,char)
c---------------------------------------------------------------------
c write error messages and terminate execution
c---------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer ier, int
 
      character char*(*)

      double precision realv

      if (ier.eq.1.or.ier.eq.2) then 
         write (*,1) char,int
      else if (ier.eq.3) then 
         write (*,3)
      else if (ier.eq.4) then
         write (*,4) char 
      else if (ier.eq.5) then 
         write (*,5) int,char,j3
      else if (ier.eq.6) then 
         write (*,6) char
      else if (ier.eq.7) then 
         write (*,7) char
      else if (ier.eq.8) then 
         write (*,8) 
      else if (ier.eq.9) then 
         write (*,9)
      else if (ier.eq.10) then 
         write (*,10) char
      else if (ier.eq.11) then 
         write (*,11) char,int
      else if (ier.eq.13) then
         write (*,13) h8
      else if (ier.eq.14) then
         write (*,14) char
      else if (ier.eq.15) then
         write (*,15) char
      else if (ier.eq.16) then
         write (*,16) h5
      else if (ier.eq.17) then
         write (*,17) int
      else if (ier.eq.18) then
         write (*,18) char
      else if (ier.eq.19) then
         write (*,19) char
      else if (ier.eq.20) then
         write (*,20) int, char
      else if (ier.eq.21) then
         write (*,21) char 
      else if (ier.eq.22) then
         write (*,22) int, char
      else if (ier.eq.23) then
         write (*,23) char
      else if (ier.eq.24) then
         write (*,24) int
      else if (ier.eq.25) then
         write (*,25) h9
      else if (ier.eq.26) then
         write (*,26) int, char
      else if (ier.eq.27) then
         write (*,27) 
      else if (ier.eq.28) then 
         write (*,28) int, char
      else if (ier.eq.29) then 
         write (*,29) int, char
      else if (ier.eq.30) then
         write (*,30) int,char
      else if (ier.eq.31) then
         write (*,31) char
      else if (ier.eq.32) then 
         write (*,32)
      else if (ier.eq.33) then 
         write (*,33) char, int
      else if (ier.eq.34) then
         write (*,34)
      else if (ier.eq.35) then
         write (*,35)
      else if (ier.eq.36) then
         write (*,36)
      else if (ier.eq.37) then
         write (*,37) int
      else if (ier.eq.38) then 
         write (*,38) 
      else if (ier.eq.39) then
         write (*,39) int
      else if (ier.eq.40) then
         write (*,40) int, char
      else if (ier.eq.41) then
         write (*,41) int, char
      else if (ier.eq.42) then
         write (*,42)
      else if (ier.eq.43) then
         write (*,43) char
      else if (ier.eq.44) then 
         write (*,44) 
      else if (ier.eq.45) then 
         write (*,45) 
      else if (ier.eq.46) then 
         write (*,46) realv, char
      else if (ier.eq.47) then 
         write (*,47) char
      else if (ier.eq.48) then 
         write (*,48) char,int
      else if (ier.eq.49) then 
         write (*,49) char,int
      else if (ier.eq.50) then 
         write (*,50) realv, char, int
      else if (ier.eq.51) then
         write (*,51) char
      else if (ier.eq.52) then 
         write (*,52) h9
      else if (ier.eq.53) then 
         write (*,53) 
      else if (ier.eq.54) then 
         write (*,54)
      else if (ier.eq.55) then 
         write (*,55) k16
      else if (ier.eq.56) then 
         write (*,56) k17
      else if (ier.eq.57) then 
         write (*,57) char
      else if (ier.eq.58) then 
         write (*,58) k21, char
      else if (ier.eq.59) then 
         write (*,59) k20, char
      else if (ier.eq.60) then 
         write (*,60) k22, char
      else if (ier.eq.61) then 
         write (*,61) k18, char
      else if (ier.eq.62) then
         write (*,62) char, int, realv
      else if (ier.eq.63) then 
         write (*,63) 
      else if (ier.eq.64) then
         write (*,64) char
      else if (ier.eq.65) then
         write (*,65) char
      else if (ier.eq.66) then
         write (*,66) 
      else if (ier.eq.67) then
         write (*,67) char
      else if (ier.eq.68) then
         write (*,68) char
      else if (ier.eq.69) then 
         write (*,69) char
      else if (ier.eq.89) then
         write (*,89) 
      else if (ier.eq.90) then
         write (*,90) l6
      else if (ier.eq.106) then
         write (*,106) char
      else if (ier.eq.107) then
         write (*,107) int
      else if (ier.eq.108) then
         write (*,108) int
      else if (ier.eq.109) then
         write (*,109) int
      else if (ier.eq.110) then
         write (*,110)
      else if (ier.eq.111) then
         write (*,111)
      else if (ier.eq.112) then
         write (*,112)
      else if (ier.eq.116) then
         write (*,116)
      else if (ier.eq.117) then
         write (*,117)
      else if (ier.eq.118) then
         write (*,118)
      else if (ier.eq.120) then
         write (*,120) char
      else if (ier.eq.122) then
         write (*,122) char
      else if (ier.eq.125) then 
         write (*,125) realv, char
      else if (ier.eq.169) then
         write (*,169) int
      else if (ier.eq.180) then
         write (*,180) char,int
      else if (ier.eq.181) then
         write (*,181) int
      else if (ier.eq.182) then
         write (*,182) k2
      else if (ier.eq.183) then
         write (*,183) k2,char
      else if (ier.eq.197) then
         write (*,197) k5,char
      else if (ier.eq.200) then
         write (*,200)
      else if (ier.eq.204) then
         write (*,204) int
      else if (ier.eq.206) then
         write (*,206) int
      else if (ier.eq.207) then
         write (*,207) realv,char
      else if (ier.eq.208) then
         write (*,208) char
      else if (ier.eq.227) then
         write (*,227) char, int
      else if (ier.eq.228) then 
         write (*,228) char, realv, int
      else if (ier.eq.279) then
         write (*,279) int
      else if (ier.eq.323) then
         write (*,323)
      else
         write (*,999) ier,realv,int,char
      end if
 
      stop

1     format (/,'**error ver001** increase parameter ',a,' to ',i7,' in'
     *       ,' perplex_parameters.h and recompile Perple_X',/)
3     format (/,'**error ver003** the solution model file is',
     *        'in a format that is no longer supported.',/,
     *        'copy the current version from: ',
     *        'www.perplex.ethz.ch/datafiles/solution_model.dat',/)
4     format (/,'**error ver004** you must use ',a,' to analyze this ',
     *        'type of calculation.',/)
5     format (/,'**error ver005** too many ordered species (',i2,') in',
     *        ' solution model ',a,/,'increase dimension j3 (',i2,')',/)
6     format (/,'**error ver006** fractionation path coordinate file: '
     *          ,a,/,'does not exist.',/)
7     format (/,'**error ver007** reference phase ',a,' is not in the ',
     *          'thermodynamic data file.',/)
8     format (/,'**error ver008** the thermodynamic data file ',
     *          'is out of date, download',/,'the current ',
     *          'version from: www.perplex.ethz.ch',/)
9     format (/,'**error ver009** invalid tag (',a,') in the ',
     *          'thermodynamic data file.',/)
10    format (/,'**error ver010** the text string:',/,a,/,'is too long',
     *        ' to be processed.',/,'The maximum allowed length is ',i3,
     *        ' characters.',/)
11    format (/,'**error ver002** invalid ',a,' choice (',i3,')',a,/)
13    format ('**error ver013** too many excluded phases, ',
     *        'increase dimension h8 (',i3,')')
14    format ('**error ver014** programming error, routine ',a)
15    format (/,'**error ver015** missing composant for: ',a,/)
16    format (/,'**error ver016** too many saturated components, ',
     *        'increase dimension h5 (',i2,')')
17    format (/,'**error ver017** too many composants for a saturation',
     *        ' constraint increase dimension h6 (',i3,')')
18    format (/,'**error ver018** ',a,' is defined as a saturated ',
     *        'phase component in the thermodynamic data file.')
19    format (/,'**error ver019** probable cause missing composant,',
     *        ' executing routine ',a)
20    format (/,'**error ver020** error ',i2,' reading solution model',
     *        ' file.',/,'   Reading model: ',a,' Check format.',/)
21    format (/,'**error ver021**error reading ',
     *        'header section of',/,'thermodynamic data ',
     *        'file, last data read:',/,a,/,'Check formatting',/)
22    format (/,'**error ver022** too many divariant assemblages, ',
     *        'increase dimension j9 (',i8,') routine: ',a)
23    format (/,'**error ver023**error reading',
     *        ' thermodynamic data file.',/,'Last data read:',
     *        /,a,/,'Check formatting.',/)
24    format (/,'**error ver024** too many solution models in',
     *        ' solution model file',/,' increase parameter i9 (',
     *        i3,')')
25    format (/,'**error ver025** too many solution models ',
     *        ' increase parameter h9 (',i3,')')
26    format (/,'**error ver026** the number of fixed components (',
     *        i2,') in ',a,/,' is >= the number of components ',/)
27    format (/,'**error ver027** Error reading the computational',
     *        ' option file.',//,'Probable cause: You are using an ',
     *        'input file created by an out-of-date',/,
     *        '                version of BUILD, or you have',
     *        ' incorrectly edited the',/'                input file',
     *        ' created by BUILD',/)
28    format (/,'**error ver028** invalid buffer choice (',i3,') in',
     *          ' routine: ',a,/)
29    format (/,'**error ver029** unknown term type ',i6,' for',
     *          ' solution model: ',a,/)
30    format (/,'**error ver030** the number of mixing sites ',i2,
     *          ' is < the number of independent sites',/,' for',
     *          ' solution model: ',a,/)
31    format (/,'**error ver031** erroneous solution model',
     *          ' parameter for: ',a,/)
32    format (/,'**error ver032** stability field calculations (',
     *          'option 2) are disabled in this version of PERPLEX',/)
33    format (/,'**error ver033** expression with too many terms in ',a
     *       ,/,'increase m0 or j6 to',i2,'.',/)
34    format (/,'**error ver034** vmax is lt vmin, check input.')
35    format (/,'**error ver035** dv is lt 0, check input.')
36    format (/,'**error ver036** missing composant for the saturated',
     *        ' phase,',/,'you have probably excluded either H2O or',
     *        ' CO2,',/,'or a composant is duplicated in the',
     *        ' thermodynamic data file',/)
37    format (/,'**error ver037** no end marker in header',/,
     *        'section of thermodynamic data file unit ',i2,/)
38    format (/,'**error ver038** you have configured a ',
     *       'problem with only one independent variable.',/,
     *       'This case cannot be handled by constrained minimization',
     *       ' use the unconstrained computational mode.'/)
39    format (/,'**error ver039** too many end-members, ',
     *        'increase dimension k12 (',i2,') Routine: ',a)
40    format (/,'**error ver040** too many compositional coordinates, ',
     *        'increase dimension k13 (',i7,')  Routine: ',a)
41    format (/,'**error ver041** too many pseudocompounds, ',
     *        'increase dimension k1 (',i7,') Routine: ',a)
42    format (/,'**error ver042** optimization failed because the ',
     *          'possible phases of the',/,
     *        'system do not span the specified bulk composition.',/,
     *        'To avoid this problem add phases or modify the bulk ',
     *        'composition.',/)
43    format (/,'**error ver043** you cannot simultaneously treat: ',
     *          a,/,'as a thermodynamic solution and as a saturated',
     *          ' phase.',/)
44    format (/,'**error ver044** too many saturated phase components.'
     *        /)
45    format (/,'**error ver045** too many mobile components.'/)
46    format (/,'**error ver046** temperature (',g12.6,' K) is out of '
     *       ,'range for the equation of state (',a,'),',/,
     *        'most likely this problem can be corrected by setting ',
     *        'the Anderson_Gruneisen keyword to TRUE',/,
     *        'in the Perple_X option file.')
47    format (/,'**error ver047** solution model ',a,' is incorrectly ',
     *        'formatted (van Laar).',/)
48    format (/,'**error ver048** too many terms in solution model ',a,
     *        ' increase parameter m1 (',i2,').',/)
49    format (/,'**error ver049** the order of solution model ',a,
     *        ' is too high, increase parameter m2 (',i2,').',/)
50    format (/,'**error ver050** requested compositional resolution ',
     *          '(',f6.0,') for a component in',
     *          'solution model: ',a,/,'exceeds 1/MRES (MRES=',i4,') ',
     *          'reduce requested resolution or inrease parameter',/,
     *          'MRES in routine CARTES',/)
51    format (/,'**error ver051** DUMMY1 could not find the auxilliary'
     *         ,' input file:',/,a,/,'required for open system model ',
     *          'computations (ICOPT=9).',/)
52    format (/,'**error ver052** too many solution models in your'
     *         ,' calculation',/,'reduce the number of models or ',
     *          'increase parameter H9 (',i2,').',/)
53    format (/,'**error ver053** phase fractionation calculations '
     *         ,'require >1 thermodynamic component.',/)
54    format (/,'**error ver054** unanticipated condition, probable ',
     *          'cause is incorrect ordering of',/,'endmembers in the',
     *          ' solution model, which leads to inconsistent site ',
     *          'occupancies',/)
55    format (/,'**error ver055** too many make definitions,'
     *         ,'increase parameter K16 (',i2,') and recompile.',/)
56    format (/,'**error ver056** too many phases in a make definition'
     *         ,', increase parameter K17 (',i2,') and recompile.',/)
57    format (/,'**error ver057** failed on an accepted make definition'
     *         ,' for ',a,/,'routine INPUT2'/)
58    format (/,'**error ver058** too many pseudocompounds generated ',
     *     'by refinement, increase dimension k21 (',i8,') routine: ',a)
59    format (/,'**error ver059** too many coordinates generated by ',
     *        'refinement, increase dimension k20 (',i8,') routine: ',a)
60    format (/,'**error ver060** too many coordinates generated by ',
     *        'refinement, increase dimension k22 (',i8,') routine: ',a)
61    format (/,'**error ver061** too many solution coordinates, ',
     *        'increase dimension k18 (',i8,') routine: ',a)
62    format (/,'**error ver062** solution model ',a,' specifies non-',
     *          'Cartesian subdivision (',i1,')',/,' and must be refor',
     *          'mulated for adapative minimization, but VERTEX cannot',
     *        /,'do the reformulation because the initial_reolution ',
     *          'keyword specified in',/,'perplex_option.dat (',f5.2,
     *          ') is invalid',/)
63    format (/,'**error ver063** inconsistent auto-refine data.',
     *        ' Suppress or reinitialize auto-refinement.',/) 
64    format (/,'**error ver064** PSVDRAW plots only ',
     *          'binary mixed-variable and ',/,
     *          'ternary composition diagrams (',a,').',/)
65    format (/,'**error ver065** dimensioning error (',a,').',/)
66    format (/,'**error ver066** invalid format, most probably this',
     *          ' result should be plotted with PSSECT.',/)
67    format (/,'**error ver067** file ',a,/,
     *        'is not formatted correctly for PSVDRAW.',/)
68    format (/,'**error ver068** solution model: ',a,
     *          ' is in microscopic format.',/,'Perple_X 6.6+ does not',
     *          ' support this format.',/,'Use a more recent solution ',
     *          'model file, e.g., copy the current version from: ',
     *        'www.perplex.ethz.ch/datafiles/solution_model.dat',/)
69    format (/,'**error ver069** too many points (',a,'), increase ',
     *          'parameter L5',/)
89    format (/,'**error ver089** SMPLX programming error. Change ',
     *        'minimnization method.',/)
90    format (/,'**error ver090** SMPLX failed to converge within ', 
     *        i6,' iterations.',/,'Probable cause: the possible ',
     *        'phases do not span the systems composition',/,
     *        'To avoid this problem add phases or modify the bulk ',
     *        'composition.',/,'Alternatively, although less ',
     *        'probably, increasing parameter L6 in perplex_',
     *        'parameters.h',/,
     *        'and recompiling VERTEX permit SMPLEX to converge.',/)
106   format (/,'**error ver106** programming error in ',a)
107   format (/,'**error ver107** the assemblage you input is ',
     *        'metastable (ier=',i3,').')
108   format (/,'**error ver108** the assemblage you input is ',
     *        'degenerate (ier=',i3,').')
109   format (/,'**error ver109** the assemblage you input does not '
     *       ,'span the specified bulk composition (ier=',i3,').')
110   format (/,'**error ver110** you have requested a calculation ',
     *        'with the composition ',/,'of a saturated phase as a ',
     *        'variable, but you have not defined its composition')
111   format (/,'**error ver111** you have requested a calculation ',
     *        'with the composition ',/,'of a saturated phase as a ',
     *        'variable, but the phase has only one component')
112   format (/,'**error ver112** the maximum value of an independent '
     *       ,'variable',/,'is less than or equal to the minimum value')
116   format (/,'**error ver116** an independent variable, or at least'
     *       ,' its name, is undefined')
117   format (/,'**error ver117** vmax(iv(3)) ne vmin(iv(3) but no ',
     *        'sectioning variable v(iv(3)) is defined')
118   format (/,'**error ver118** the default increment of the ',
     *        'sectioning variable will result ',/,
     *        'in the generation of more ',
     *        'than 10 sections, to avoid this',/,' error increase ',
     *        'the increment or modify this test')
120   format (/,'**error ver120** file:',/,a,/,
     *        'could not be opened, check that it exists or that it is',
     *        ' not in use by another program.',/) 
122   format ('**error ver120** plot file: ',a,/,'was not found, ',
     *        'you must generate it with VERTEX.')
125   format (/,'**error ver125** a site fraction (',g8.2,') is out',
     *          ' of range for : ',a,/,'   The configurational',
     *          ' entropy model is probably incorrect.',/)
169   format (/,'**error ver169** cart, imod=',i2,' is an invalid ',
     *          'request')
180   format (/,'**error ver180** too many (pseudo-)compounds, ',
     *          'routine: ',a,' currently:',i7)
181   format (/,'**error ver181** too many reactions,',
     *          ' increase dimension k2 (',i6,')')
182   format (/,'**error ver182** too many invariant points,',
     *           ' increase parameter k2 (',i6,')')
183   format (/,'**error ver183** too many assemblages; increase ',
     *        ' parameter k2 (',i6,'), routine ',a)
197   format (/,'**error ver197** to many components (',i2,'), increase'
     *         ,' parameter k5 (',i2,'), routine:',a,/)
200   format (/,'**error ver200** you are trying to use a fluid ',
     *        'equation of state for an invalid component',/)
204   format ('**error ver204** too many stable assemblages, i',
     *        'ncrease dimension j9 (',i8,')',/)
206   format ('**error ver206** too many univariant assemblages ',
     *        'intersect the edges of the diagram, i',
     *        'ncrease dimension k2 (',i6,')',/)
207   format (/,'**error ver207** the value of the stretching ',
     *          ' parameter (',g13.6,')',/,'for solution ',a,
     *          ' is invalid (<1) for transform subdivision,',/,
     *          'check section 4 of PERPLEX documentation.',/)
208   format (/,'**error ver208** too many phases on one side of a',/
     *        ' reaction.',/,'Do not use the full reaction',
     *        ' equation option (',a,').')
227   format (/,'**error ver227** in solution model ',a,' a DQF ',
     *          'correction is specified for endmember: ',i2,/,
     *          'DQF corrections can only be made on the idependent ',
     *          'endmembers of a solution model',/)
228   format (/,'**error ver228** in solution model ',a,' negative ',
     *          'composition (',g12.6,') for component ',i2,/,
     *          'probable cause is an incorrect stoichiometric ',
     *          'definition for a dependent endmember.',/)
279   format (/,'**error ver279** you have got a problem ',i3)
323   format (/,'**error ver323** prime9, imd(i)=0 is the only',/,
     *        'subdivision scheme permitted for this version' )
999   format (/,'**error vertex** unspecified error ier=',i3,/,
     *        ' real=',g15.7,/,' i=',i12,/,' char=',a)
      end

      subroutine warn (ier,realv,int,char)
c---------------------------------------------------------------------
c write warning messages and terminate execution
c---------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'
 
      integer ier,int

      double precision realv
 
      character char*(*)

      if (ier.eq.1) then 
         write (*,1) 
      else if (ier.eq.2) then 
         write (*,2) realv
      else if (ier.eq.3) then 
         write (*,3)
      else if (ier.eq.4) then 
         write (*,4) char
      else if (ier.eq.5) then
         write (*,5) 
      else if (ier.eq.6) then
         write (*,6) 
      else if (ier.eq.7) then
         write (*,7) 
      else if (ier.eq.8) then
         write (*,8) h8
      else if (ier.eq.9) then
         write (*,9) char
      else if (ier.eq.10) then
         write (*,10) int, realv, char
      else if (ier.eq.11) then
         write (*,11) char
      else if (ier.eq.12) then
         write (*,12) char
      else if (ier.eq.13) then
         write (*,13) char
      else if (ier.eq.14) then
         write (*,14) char
      else if (ier.eq.15) then
         write (*,15)
      else if (ier.eq.16) then
         write (*,16)
      else if (ier.eq.17) then
         write (*,17)
      else if (ier.eq.18) then
         write (*,18) realv
      else if (ier.eq.19) then
         write (*,19) 
      else if (ier.eq.20) then
         write (*,20)
      else if (ier.eq.21) then
         write (*,21) realv, char
      else if (ier.eq.22) then
         write (*,22) realv, char
      else if (ier.eq.23) then
         write (*,23) char     
      else if (ier.eq.24) then
         write (*,24) realv
      else if (ier.eq.25) then 
         write (*,25) int, char
      else if (ier.eq.26) then 
         write (*,26) char
      else if (ier.eq.28) then
         write (*,28)
      else if (ier.eq.29) then
         write (*,29) char
      else if (ier.eq.30) then
         write (*,30) char
      else if (ier.eq.31) then 
         write (*,31)
      else if (ier.eq.32) then
         write (*,32) char
      else if (ier.eq.33) then
         write (*,33) char
      else if (ier.eq.34) then
         write (*,34) char
      else if (ier.eq.35) then
         write (*,35) char,realv
      else if (ier.eq.36) then 
         write (*,36) realv, char 
      else if (ier.eq.37) then
         write (*,37)  
      else if (ier.eq.38) then
         write (*,38) 
      else if (ier.eq.39) then
         write (*,39) 
      else if (ier.eq.40) then
         write (*,40) 
      else if (ier.eq.41) then
         write (*,41) char
      else if (ier.eq.42) then
         write (*,42)     
      else if (ier.eq.43) then
         write (*,43) int, char
      else if (ier.eq.44) then
         write (*,44) char
      else if (ier.eq.45) then
         write (*,45) char
      else if (ier.eq.46) then 
         write (*,46) realv, char
      else if (ier.eq.47) then
         write (*,47) int, realv
      else if (ier.eq.48) then 
         write (*,48) 
      else if (ier.eq.49) then 
         write (*,49) int
      else if (ier.eq.50) then
         write (*,50) char
      else if (ier.eq.51) then 
         write (*,51) char
      else if (ier.eq.52) then 
         write (*,52) char
      else if (ier.eq.58) then
         write (*,58)
      else if (ier.eq.60) then
         write (*,60) char
      else if (ier.eq.63) then
         write (*,63)
      else if (ier.eq.73) then
         write (*,73) char, realv, int
      else if (ier.eq.74) then
         write (*,74)
      else if (ier.eq.79) then
         write (*,79) char
      else if (ier.eq.87) then
         write (*,87)
      else if (ier.eq.88) then
         write (*,88)
      else if (ier.eq.89) then
         write (*,89)
      else if (ier.eq.90) then
         write (*,90) 
      else if (ier.eq.91) then
         write (*,91)
      else if (ier.eq.92) then 
         write (*,92) int, l7, char
      else if (ier.eq.106) then
         write (*,106) char
      else if (ier.eq.108) then
         write (*,108)
      else if (ier.eq.109) then
         write (*,109)
      else if (ier.eq.113) then
         write (*,113) int
      else if (ier.eq.114) then
         write (*,114)
      else if (ier.eq.172) then
         write (*,172) 
      else if (ier.eq.173) then
         write (*,173) 
      else if (ier.eq.175) then
         write (*,175) char,ier,realv
      else if (ier.eq.176) then
         write (*,176) char
      else if (ier.eq.190) then
         write (*,190) int
      else if (ier.eq.205) then
         write (*,205) int
         write (*,900)
      else if (ier.eq.207) then
         write (*,207) int
      else if (ier.eq.208) then
         write (*,208) int
      else if (ier.eq.209) then
         write (*,209) int
      else
         write (*,999) ier, char, realv, int
      end if

1     format (/,'**warning ver001** the amount of a saturated phase is'
     *       ,' < 0, this indicates that',/,'the specified amount of a '
     *       ,'saturated component is inadequate to saturate the system'
     *       ,/)
2     format (/,'**warning ver002** the amount of a phase is < ',g12.3,
     *        '(-zero_mode) this may be',/,'indicative of numeric ',
     *        'instability',/)
3     format (/,'**warning ver003** the solution model file is ',
     *        'in a format that is no longer supported.',/,
     *        'copy the current version from: ',
     *        'www.perplex.ethz.ch/datafiles/solution_model.dat',/)
4     format (/,'**warning ver004** the data includes ',a,' values, '
     *      ,'probably because bad_number',/,'in perplex_option.dat = '
     *      ,'NaN, these values will be replaced by zeros. To avoid ',/,
     *       'this behavior set bad_number to a numeric value or use a',
     *       ' plotting program capable',/,'of handling NaNs, e.g., ',
     *       'MatLab or PYWERAMI',/)
5     format (/,'**warning ver005** fluid components are specified',
     *        ' as thermodynamic AND as either',/,'saturated phase',   
     *      ' or saturated components; almost certainly a BAD idea.',/)
6     format (/,'**warning ver006** fluid components are specified',
     *        ' as both thermodynamic AND',/,'saturated ',    
     *        'components; almost certainly a BAD idea.',/)
7     format (/,'**warning ver007** fluid components are specified as'
     *       ,' a saturated phase component',/,'AND as a thermodynamic', 
     *        'or saturated component; almost certainly a BAD idea.',/)
8     format ('**warning ver08** too exclude more phases ',
     *        'increase paramter h8 (',i3,')')
9     format ('**warning ver009** unable to deconstruct transition,'
     *       ,/,'data for ',a,' will not be output.')
10    format (/,'**warning ver010** not able to traverse ',
     *          'the entire',/,'extent of equilibrium (',i6,')',
     *          ' at v(3)=',g12.6,/,
     *          'this error can usually be avoided by increasing the ',
     *          'finite',/,'difference increment delt(iv(1)) or delv',
     *          '(iv(2)), as defined on card 6 of',/,'the file on n2.',
     *          ' In routine:',a,/)
11    format (/,'**warning ver011** ',a,' has > 1',
     *          ' transition with dp/dT ne 0 and may not be treated ',/,
     *          ' correctly')
12    format (/,'**warning ver012** ',a,' has a transition ',
     *          ' with dp/dT < 0 and may not be treated ',/,
     *          ' correctly')
13    format (/,'**warning ver013** ',a,' has null or negative ',
     *          'composition and will be ',/,'rejected from the ',
     *          'composition space.')
14    format (/,'**warning ver014** You can not redefine the ',
     *          'saturated phase component:',a,/,'To circumvent this ',
     *          'restriction use CTRANSF to make a data base with the',/
     *         ,'the desired component transformations',/)
15    format (/,'**warning ver015** if you select > 1 saturated ',
     *          'component, then the order you',/,'enter the ',
     *          'components determines the saturation heirarchy and may'
     *          ,' effect your',/,'results (see Connolly 1990).',/)
16    format (/,'**warning ver016** you are going to treat a saturate',
     *        'd (fluid) phase component',/,'as a thermodynamic ',
     *        'component, this may not be what you want to do.',/)
17    format (/,'**warning ver017** you gotta be kidding, either ',
     *          ' 1 or 2 components, try again:',/)
18    format (/,'**warning ver018** the value of the default dependen',
     *         't variable (',g14.6,') for the following',/,
     *         'equilibrium was inconsistent with the an earlier ',
     *         'determination of the invariant condition',/,
     *         'and will be reset. This may cause the curve to ',
     *         'look kinked near the invariant point',/)
19    format ('**warning ver019** you must specify at least ',
     *        'one thermodynamic component, try again',/)
20    format ('**warning ver020** sfol2')
21    format ('**warning ver021** xmax (',g12.6,') > 1 for '
     *         ,' solution model ',a,/,' xmax will be reset to 1',
     *        /,' see documentation, section 4.0.')
22    format ('**warning ver022** xmin (',g12.6,') < 0 for '
     *         ,' solution model ',a,/,' xmin will be reset to 1',
     *        /,' see documentation, section 4.0.')
23    format ('**warning ver023** xmin > xmax for solution ',a,/,
     *        'xmin will be set to xmax NO PSEUDOCOMPOUNDS WILL BE',
     *        ' GENERATED.',/,'see documentation, section 4.0',/)
24    format (/,'**warning ver024** wway, increment refined out of',
     *          ' range (',g8.1,')',/,' before the stable',
     *          ' extension of the equilibria was located')
25    format ('**warning ver025** ',i1,' endmembers for ',a,
     *          ' The solution will not be considered.')
26    format ('**warning ver026** only one endmember for ',a,
     *          ' The solution will not be considered.')
28    format (/,'**warning ver028** minimization failed, ill-',
     *        'conditioned?',/)
29    format ('**warning ver029** programming error, routine ',a,/)
30    format (/,'**warning ver030** Because of missing endmembers, ',
     *        'or that the',/,'subdivision',
     *        ' scheme specified for solution model ',a,/,'is too',
     *        ' restrictive, there are no valid compositions for', 
     *        ' this model.',/)
31    format (/,'**warning ver031** this choice is disabled because ',
     *        'the dependent_potentials',/,'keyword is missing or off',
     *        ' in perplex_option.dat, to use this choice set the',/,
     *        'keyword to on and re-run VERTEX.',/)
32    format ('**warning ver032** fixed activity option requested',
     *          ' for ',a,/,'This option is disabled, the',
     *          ' solution will not be considered.')
33    format ('**warning ver033** missing endmembers for ',a,/,
     *        'The model may be recast in > 1 way for',
     *        ' the endmember subset.',/,'To control this choice',
     *        ' eliminate undesired endmembers.')
34    format ('**warning ver034** ',a,' could not be recast as',
     *          ' a simpler model.',/,'The solution will not be',
     *          ' considered. Add the missing endmembers or eliminate'
     *          ,/,'additional endmembers to allow this model.',/)
35    format (/,'**warning ver035** ',a,' is only for pure fluids',
     *        /,' XCO2 will be reset to: ',f4.2,/)
36    format ('**warning ver021** xinc (',g12.6,') < 0 for'
     *         ,' solution model ',a,/,'xinc will be reset to 1.'
     *         ,' see documentation, section 4.0. ',/)
37    format (/,'**warning ver37** you will not be able to plot the ',
     *       'results of this',/,'calculation with PSVDRAW. PSVDRAW ',
     *       'only plots ternary composition diagrams.',/)
38    format (/,'**warning ver38** you will not be able to plot the ',
     *       'results of this',/,'calculation with PSVDRAW. PSVDRAW ',
     *       'only plots mixed-variable diagrams for',/,'a binary ',
     *       'system with one independent potential variable.',/)
39    format (/,'**warning ver39** PSVDRAW will plot the results of ',
     *       'this calculation as a',/,'projected section, such plots ',
     *       'may be difficult to interpret. To plot',/,
     *       'pseudosections as a an explicit function of a systems ',
     *       'composition use',/, 'gridded minimization.',/)
40    format (/,'**warning ver040** you have configured a ',
     *       'problem with only one independent variable.',/)
41    format (/,'**warning ver041** icky pseudocompound names'
     *       ,' for solution model: ',a,/,'refer to pseudocompound_'
     *       ,'glossary.dat file for pseudocompound definitions.',/)
42    format (/,'**warning ver042** optimization failed because the ',
     *          'possible phases of the',/,
     *        'system do not span the specified bulk composition.',/,
     *        'To avoid this problem add phases or modify the bulk ',
     *        'composition.',/)
43    format (/,'**warning ver043** ',i2,' solutions referenced ',
     *          'in your input',/,'were not found in the solution ',
     *          'model file, routine:',a,/)
44    format ('**warning ver044** a solution model has destabilized',
     *        ' the endmember: ',a,' (iend=2).')
45    format (/,'**warning ver045** the entity involves ',
     *        ' phases (',a,' )',/,'described by a nonlinear EoS (see',
     *        ' program documentation Eq 2.2)',/,
     *        ' NO OUTPUT WILL BE GENERATED FOR THIS ENTITY.',/)
46    format (/,'**warning ver046** temperature (',g12.6,' K) is out',
     *        ' of range for the equation of state (',a,').',/,
     *        'most likely this problem can be corrected by setting '
     *        'the Anderson_Gruneisen keyword to TRUE',/,
     *        'in the Perple_X option file.')
47    format (/,'**warning ver047** invariant point ',i6,' could ',
     *        ' not be located within',/,' the specified tolerance ',
     *        ' (PTOL= ',g12.6,' ) reset PTOL to avoid this problem.',/)
48    format (/,'**warning ver048** fluid phase pseudocompound data ',
     *         'does not include',/,' volumetric properties (SWASH).',/)
49    format (/,'**warning ver049** warning ',i3,' will not be repeated'
     *         ,' for future instances of this problem.',/)
c49    format (/,'**warning ver049** some pseudocompound data has not',
c     *          ' been output because',/' the bulk modulus pressure ',
c     *          'derivative is not constant for all endmembers ',/,
c     *          ' (SWASH, see program documentation Eq 2.3)',/)
50    format (/,'**warning ver050** reformulating reciprocal ',
     *          'solution: ',a,' because of missing endmembers. ',
     *        /,'(reformulation can be controlled explicitly ',
     *          'by excluding additional endmembers).',/)
51    format (/,'**warning ver051** cannot make ',a,' because of ',
     *          'missing data or'
     *       ,/,'an invalid definition in the thermodynamic data file.'
     *       ,/)
52    format (/,'**warning ver052** rejecting ',a,'; excluded or '
     *       ,'invalid composition.',/)
58    format (/,'**warning ver058** wway, the equilibrium of the '
     *         ,'following reaction',/,' is inconsistent with the ',
     *          'invariant equilibrium.',/)
60    format (/,'**warning ver060** non-fatal programming error ',
     *          'routine:',a,/)
63    format (/,'**warning ver063** wway, invariant point on an edge?',
     *        /)
73    format (/,'**warning ver073** an invariant point has been',
     *          ' skipped, routine:',a,/,' This problem typically',
     *          ' occurs because two phases in the thermodynamic data',
     *          ' file have identical properties.',/,' Otherwise ',
     *          ' decreasing DTOL (',g9.3,') in the thermodynamic', 
     *          ' data file (Doc Sect 3, Card 6) for  variable ',i1,/,
     *          ' may eliminate this problem',/)
74    format (/,'**warning ver074** no new equilibria identified,',
     *          ' if degenerate segments have',/,' been skipped',
     *          ' increase the computational reliability level.',/)
79    format (/,'**warning ver079** univeq failed on an edge for ',
     *          'the following equilibrium.',/,' Probable cause is ',
     *          'extreme independent variable limits (e.g., xco2=0)',/
     *          ' or poor convergence criteria ',
     *          'in the thermodynamic data file. In routine:',a,/)
87    format (/,'**warning ver087** wway-univeq did not converge ',
     *          'when div was refined',/)
88    format (/,'**warning ver088** SMPLX converged to a non-unique ',
     *        'solution.',/,3x,'Probable cause: system composition ',
     *        'coincides with that of ',//,3x,'a compound or a ',
     *        'tieline between compounds.',//,3x,'This may lead to ',
     *        'erratic results.',//,3x,'To avoid this problem ',
     *        'perturb the systems composition.',/)
89    format (//,'**warning ver089** BUILD you did not request',
     *        'plot file output.',/,' You will not be able to process',
     *        ' the results of the requested calculation.',//)
90    format (/,'**warning ver090** optimization failed. ',/,
     *        'Probable cause: the possible ',
     *        'phases do not span the systems composition',/,3x,
     *        'To avoid this problem add phases or modify the bulk ',
     *        'composition.',/,'Alternatively, although less ',
     *        'probably, increasing parameter L6 in perplex_',
     *        'parameters.h',/,
     *        'and recompiling VERTEX permit SMPLEX to converge.',/)
91    format (/,'**warning ver091** optimization failed. Change ',
     *        'minimnization method',/)
92    format (/,'**warning ver092** you have requested ',i4,
     *        ' grid points. Current',/,'dimensioning is for ',
     *        i4,' points. To obtain the requested resolution',/,
     *        'increase parameter L7 and recompile; or reduce the ',
     *        'required resolution via',/,'the ',a,' keyword in ',
     *        'perplex_option.dat',/)
106   format ('**warning ver106** programming error in ',a)
108   format (/,'**warning ver108** wway, a phase field with the '
     *         ,'following',/,' reaction is stable on both ',
     *          'sides of an invariant point',/,' this error can ',
     *          'usually be avoided by increasing the finite ',/,
     *          ' difference increment delt(iv(1)) or delv',
     *          '(iv(2)), defined',
     *           /,' on card 6 of the thermodynamic data file',/)
109   format (/,'**warning ver109** you may ',
     *        'have assigned a mobile component as an independent ',/,
     *        ' variable without defining the component',/)
113   format (/,'**warning ver113** maximum variance for equilibrium',
     *        ' tracing [the variance keyword in ',/,
     *        'perplex_option.dat] must be > 0, but is ',i2,
     *        '. Set to 1 for the current calculation',/)
114   format (/,'**warning ver114** the default increment of an ',
     *        'independent variable is <',/,' 1 percent of ',
     *        'its range, this is usually inefficient',/)
172   format (/,'**warning ver172** you cannot use this equation of',
     *          ' state with Y(CO2)',/,' as an indepedent variable, ',
     *          ' pick another one:',/)
173   format (/,'**warning ver173** invalid buffer choice ',/)
175   format (/,'**warning ver175** speciation routine ',a,' did',
     *          ' not converge ',/,' possibly due to graphite super-',
     *          'saturation. ier = ',i1,' real = ',g16.5,/)
176   format ('**warning ver176** fluid equation of state routine ',
     *        a,' did not converge.',/,' If execution continues this ',
     *        'may lead to incorrect results.',/,' To avoid this ',
     *        'problem choose a different equation of state.')
190   format (/,'**warning ver190** SMPLX failed to converge within ', 
     *        i6,' iterations.',/,3x,'Probable cause: the possible ',
     *        'phases do not span the systems composition',/,3x,
     *        'To avoid this problem add phases or modify the bulk ',
     *        'composition.',/,3x,'Alternatively, although less ',
     *        'probably, increasing parameter L6 in perplex_',
     *        'parameters.h',/,3x,
     *        'and recompiling VERTEX permit SMPLEX to converge.',/)
205   format (/,'**error ver205** too many new phase assemblages, ',
     *        'found by routine newhld',/,' increase dimension j9 (',
     *        i8,')',/)
207   format ('**warning ver207** the assemblage you input is ',
     *        'metastable (ier=',i3,').')
208   format ('**warning ver208** the assemblage you input is ',
     *        'degenerate (ier=',i3,').')
209   format ('**warning ver209** the assemblage you input does not'
     *       ,' span the specified bulk composition (ier=',i3,').')
900   format (' the calculation may be incomplete !!!!',/)
999   format (/,'**warning unspecified** ier =',i3,' routine ',a6
     *         ,' r = ',g12.6,' int = ',i9,/)
      end

      subroutine rmakes (iopt)
c----------------------------------------------------------------------
c rmakes is called by topn2 to read make definitions of thermodynamic
c entities, these entities are defined as a linear combination of 
c exisiting entities as defined in the thermodynamic file, with an 
c optional pressure/temperature dependent DQF correction. The format
c assumes data on one line of less than 240 characters, the expected format
c is

c name = num_1 * name_1 + num_2 * name_2 ....+ num_int * name_int
c dnum_1 dnum_2 dnum_3

c where i num_j is a number or fraction (i.e., two numbers separated by a 
c '/') and name_j is the name of the int existing entities. 
c and the dqf correction to the entity 'name' is
c Gdqf(J/mol) = dnum_1 + T[K]*dnum_2 + P[bar]*dnum_3

c end_of_data is either a "|" or the end of the record.

c make definitions are preceeded by the keyword:

c begin_makes 

c and truncated by the keyword:

c end_makes

c if iopt > 3, data is echoed to LUN n8 (for ctransf/actcor).
c----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer ibeg, iend, len, ier, iscan, i, nreact, iopt

      double precision rnum

      character tname*8, name*8, rec*240, tag*3

      double precision mcomp
      character mknam*8
      integer nmak
      logical mksat
      common / cst333 /mcomp(k16,k0),nmak,mksat(k16),mknam(k16,k17)

      double precision mkcoef, mdqf
      integer mknum, mkind
      common / cst334 /mkcoef(k16,k17),mdqf(k16,k17),mkind(k16,k17),
     *                 mknum(k16)

      integer ixct,iexyn,ifact
      common/ cst37 /ixct,iexyn,ifact 

      character*8 exname,afname
      common/ cst36 /exname(h8),afname(2)

      integer length,iblank,icom
      character chars*1
      common/ cst51 /length,iblank,icom,chars(240)
c----------------------------------------------------------------------

      call readcd (n2,len,ier)
      if (ier.ne.0) goto 90 
c                                 echo data for ctransf/actcor
      if (iopt.gt.3) write (n8,'(240a1)') (chars(i),i=1,len)

      iend = len
      nmak = 0 

      write (rec,'(240a1)') chars
      read (rec,'(a3)') tag

      do while (tag.ne.'end')   

         nmak = nmak + 1
         if (nmak.gt.k16) call error (55,mkcoef(1,1),nmak,'RMAKES')
c                                 get first name
         ibeg = 1
         call readnm (ibeg,iend,len,ier,tname)
         if (ier.ne.0) goto 90
c                                 find start of data marker '='
         ibeg = iscan (1,len,'=') + 1
c                                 the rest of the data should
c                                 consist of coefficients followed
c                                 by names
         nreact = 0 

         do while (ibeg.lt.len) 
c                                 find the number
            call readfr (rnum,ibeg,iend,len,ier)
            if (ier.eq.2) then 
c                                 ier = 2 = a read error
               goto 90
            else if (ier.eq.1) then 
c                                 ier = 1, end-of-definition
               exit 
            end if 
c                                 find the name
            call readnm (ibeg,iend,len,ier,name)
            if (ier.ne.0) goto 90

            nreact = nreact + 1
            if (nreact.gt.k17) call error (56,mkcoef(1,1),nmak,'RMAKES')

            mkcoef(nmak,nreact) = rnum 
            mknam(nmak,nreact) = name
           
         end do

         if (nreact+1.gt.k17) call error (56,mkcoef(1,1),nmak,'RMAKES')
         mknam(nmak,nreact+1) = tname
         mknum(nmak) = nreact
c                                 now the dqf
         call readcd (n2,len,ier)
         if (ier.ne.0) goto 90
c                                 echo data for ctransf/actcor 
         if (iopt.gt.3) write (n8,'(240a1)') (chars(i),i=1,len)

         write (rec,'(240a1)') chars
         read (rec,*) mdqf(nmak,1),mdqf(nmak,2),mdqf(nmak,3)
c                                 start next make definition
         call readcd (n2,len,ier)
         write (rec,'(240a1)') chars
         read (rec,'(a3)') tag
c                                 echo data for ctransf/actcor
         if (iopt.gt.3) write (n8,'(240a1)') (chars(i),i=1,len)

c                                 reject excluded makes
         do i = 1, ixct
            if (tname.eq.exname(i)) then 
               nreact = nreact - 1
               exit 
            end if 
         end do 

      end do 

      goto 99

90    write (*,1000) (chars(i),i=1,len)
      stop
      
1000  format (/,'**error ver200** READMK bad make definition in the',
     *        ' thermodynamic data file',/,'currently reading: ',/
     *        ,240a)

99    end 

      subroutine readnm (ibeg,iend,len,ier,name)
c----------------------------------------------------------------------
c readnm looks for the first word in a record chars, ibeg is the index
c of the 1st letter, iend is the index of the last letter.
c-----------------------------------------------------------------------
      implicit none

      integer ibeg, iend, len, iscan, iscnlt, ier, i, imax

      character name*8

      integer length,iblank,icom
      character chars*1
      common/ cst51 /length,iblank,icom,chars(240)
c----------------------------------------------------------------------

      ier = 0 
c                                 find start of name
      ibeg = iscnlt (ibeg,len,' ') 
c                                 find next blank
      iend = iscan (ibeg,len,' ') - 1

      imax = iend - ibeg
c                                 initialize to be safe:
      name = '        '

      if (imax.le.7) then

         write (name,'(8a1)') (chars(i),i=ibeg,iend)

      else 
c                                 can't be a valid name, save it
c                                 anyway in case it's a tag
         write (name,'(8a1)') (chars(i),i=ibeg,ibeg+7)
         ier = 4

      end if 

      ibeg = iend + 1

      end 

      subroutine readcd (nloc,len,ier)
c----------------------------------------------------------------------
c readcd - read 240 column card image from unit 9, strip out unwanted
c characters. ier = 1 no card found.
c----------------------------------------------------------------------    
      implicit none

      integer len, ier, iscan, ict, i, iscnlt, ibeg, nloc

      character card*240

      integer length,iblank,icom
      character chars*1
      common/ cst51 /length,iblank,icom,chars(240)
c----------------------------------------------------------------------

      ier = 0 

      ibeg = 0
  
      len = 0 

      card = ' '

      do while (ibeg.ge.len) 

         read (nloc,'(a)',end=90) card

         if (card.ne.' ') then 

            read (card,'(240a)') chars
c                                 find end of data marker '|'
            len = iscan (1,240,'|') - 1
c                                 '|' in first column
            if (len.eq.0) cycle
c                                 find a non blank character
            ibeg = iscnlt (1,len,' ')

         end if 

      end do 

      ict = 1

      do i = 2, len 
c                                 strip out '+' and '*' chars
         if (chars(i).eq.'+'.or.chars(i).eq.'*') chars(i) = ' '
c                                 eliminate blanks after '/' and '-'
c                                 and double blanks
         if ((chars(ict).eq.'/'.and.chars(i  ).ne.' ') .or. 
     *       (chars(ict).eq.'-'.and.chars(i  ).ne.' ') .or.
     *       (chars(ict).eq.' '.and.chars(i  ).ne.' ') .or.
     *       (chars(ict).ne.'-'.and.chars(ict).ne.'/'.and.
     *        chars(ict).ne.' ') ) then
             ict = ict + 1
             chars(ict) = chars(i)
         end if

      end do 

      len = ict

      goto 99

90    ier = 3

99    end

      subroutine readfr (rnum,ibeg,iend,len,ier)
c----------------------------------------------------------------------
c readfr looks for a number or two numbers separated by a backslash / in
c that array chars(iend:ibeg), the latter case is interpreted as a ratio. 
c the result is returned as num
c-----------------------------------------------------------------------
      implicit none

      double precision rnum, rnum1 

      integer ibeg, iend, len, iback, ier, iscan, iscnlt, i

      character num*30

      integer length,iblank,icom
      character chars*1
      common/ cst51 /length,iblank,icom,chars(240)
c----------------------------------------------------------------------
      ier = 0 
c                                 now find start of a number
      ibeg = iscnlt (ibeg,len,' ')  
c                                 find backslash
      iback = iscan (ibeg,len,'/') - 1
c                                 find next blank
      iend = iscan (ibeg,len,' ') - 1
c                                 three cases:
      if (iend.ge.len) then

         ier = 1
         goto 99 

      else if (iback.gt.iend) then
c                                 no fraction
         if (iend-ibeg+1.gt.30) goto 90
c                                 first constant
         write (num,'(30a)') (chars(i),i=ibeg,iend)
         read (num,*,err=90) rnum

      else 
c                                 fraction write numerator
         if (iback+1-ibeg.gt.30) goto 90
c                                 first number
         write (num,'(30a)') (chars(i),i=ibeg,iback)       
         read (num,*,err=90) rnum
c                                 second number 

         if (iend-iback-1.gt.30) goto 90
         write (num,'(30a)') (chars(i),i=iback+2,iend)      
         read (num,*,err=90) rnum1

         rnum = rnum/rnum1

      end if 

      ibeg = iend + 1

      goto 99

90    ier = 2

99    end 

      integer function iscan (ibeg,iend,char)
c----------------------------------------------------------------------
c iscan finds the first occurence of char in chars(ibeg..iend), if not
c found iscan is ?; kscan does the forward/inverse scans and sets value
c for bad ranges
c----------------------------------------------------------------------
      implicit none

      character char*1

      integer ibeg, iend

      integer length,iblank,icom
      character chars*1
      common/ cst51 /length,iblank,icom,chars(240)
c----------------------------------------------------------------------

      do iscan = ibeg, iend

         if (chars(iscan).eq.char) exit

      end do 

      end 

      integer function kscan (ibeg,iend,char)
c----------------------------------------------------------------------
c iscan finds the first occurence of char in chars(ibeg..iend), if not
c found iscan is iend + inc
c----------------------------------------------------------------------
      implicit none

      character char*1

      integer ibeg, iend, inc

      integer length,iblank,icom
      character chars*1
      common/ cst51 /length,iblank,icom,chars(240)
c----------------------------------------------------------------------
      if (ibeg.gt.iend) then 
         inc = -1
      else 
         inc = 1
      end if 

      do kscan = ibeg, iend, inc 

         if (chars(kscan).eq.char) exit

      end do 
c                                 normal loop exit kscan = iend + inc
      end 

      integer function iscnlt (ibeg,iend,char)
c----------------------------------------------------------------------
c iscan finds the first occurence of a character in chars(ibeg..iend) that
c is greater than char. assuming ascii collating sequence +/- < 0 < a
c----------------------------------------------------------------------
      implicit none

      character char*1

      integer ibeg, iend, inc

      integer length,iblank,icom
      character chars*1
      common/ cst51 /length,iblank,icom,chars(240)
c----------------------------------------------------------------------

      if (ibeg.le.iend) then 
         inc = 1
      else 
         inc = -1
      end if 

      do iscnlt = ibeg, iend, inc

         if (chars(iscnlt).gt.char) exit

      end do 

      end 

      subroutine deblnk (text)
c----------------------------------------------------------------------
c deblnk - scan text and delete multiple blank characters, strip
c out sequential + - or - + operators, trailing -/+ operators, 
c leading blanks, and leading + operators.
 
c     text - character string 

c no test is made for a blank string or a string of "+" signs.
c----------------------------------------------------------------------
      implicit none 

      integer i, ict, nchar

      logical strip
 
      character text*(*), bitsy(400)*1 
 
      nchar = len(text) 

      read (text,1000) (bitsy(i), i = 1, nchar)
c                                find last non-blank
      ict = 1 
      
      do i = 1, nchar
         if (bitsy(i).gt.' ') ict = i
      end do  

      nchar = ict          
c                                 kill any trailing +/-
      if (bitsy(nchar).eq.'+'.or.bitsy(nchar).eq.'-') nchar = nchar - 1
         
c                                 scan for first non blank/+ character:
      ict = 0 
      
      do i = 1, nchar
         if (bitsy(i).eq.' '.or.bitsy(i).eq.'+') cycle
         ict = i
         exit 
      end do 
c                                 shift everything right
      if (ict.gt.1) then 

         ict = ict - 1
         
         do i = ict+1, nchar
            bitsy(i-ict) = bitsy(i)
         end do 

         nchar = nchar - ict

      end if 

      ict = 1
      
      do i = 2, nchar
c                                 strip out double blanks
         if (bitsy(i).eq.' '.and.bitsy(i-1).eq.' ') cycle 
         ict = ict + 1
         bitsy(ict) = bitsy(i)

      end do

      nchar = ict      
c                                 strip put + - and - + strings
      strip = .false.

      do i = 1, nchar - 2

         if (bitsy(i).eq.'+'.and.bitsy(i+1).eq.'-'.or.
     *       bitsy(i).eq.'-'.and.bitsy(i+1).eq.'+') then

             bitsy(i) = '-'
             bitsy(i+1) = ' '
             strip = .true.

         else if (bitsy(i).eq.'+'.and.bitsy(i+2).eq.'-'.or.
     *            bitsy(i).eq.'-'.and.bitsy(i+2).eq.'+') then

             bitsy(i) = '-'
             bitsy(i+2) = ' '
             strip = .true.

         end if 

      end do 

      if (strip) then 
c                                 strip out new double blanks
         ict = 1

         do i = 2, nchar

            if (bitsy(i).eq.' '.and.bitsy(i-1).eq.' ') cycle 
            ict = ict + 1
            bitsy(ict) = bitsy(i)

         end do 

      end if 

      write (text,1000) (bitsy(i), i = 1, ict),
     *                  (' ',i = ict+1, len(text))
 
1000  format (400a)

      end

      subroutine getnam (name,ids)
c----------------------------------------------------------------------
c subroutine to retrieve phase name corresponding to index ids
c----------------------------------------------------------------------
      implicit none 

      include 'perplex_parameters.h'

      integer ids

      character names*8, name*14
      common/ cst8  /names(k1)

      character fname*10
      common/ csta7 /fname(h9)
c-----------------------------------------------------------------------
      if (ids.lt.0) then
c                                 simple compound:
         name = names(-ids)

      else  
c                                 solution phases:
         name = fname(ids)

      end if 
      
      end 

      subroutine sopen 
c-----------------------------------------------------------------------
c simple file open for data echo programs (e.g., actcor, rewrit, ctransf)
c-----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'
 
      character*100 n2name

      integer iam
      common/ cst4 /iam
c-----------------------------------------------------------------------
c                                 first the thermo data file
      do 

         call fopen2 (2,n2name)
 
         if (iam.eq.6) then 
            write (*,1070) 'ctransf.dat'
            open (n8,file='ctransf.dat')
         else if (iam.eq.9) then 
            write (*,1070) 'actcor.dat'
            open (n8,file='actcor.dat')
         else if (iam.eq.10) then 
            write (*,1070) 'new_'//n2name
            open (n8,file='new_'//n2name)
         end if 

         exit

      end do 
 
1070  format (/,'Output will be written to file: ',a,/)
 
      end

      block data
c-----------------------------------------------------------------------
      implicit none
 
      include 'perplex_parameters.h'

      double precision p,t,xco2,u1,u2,tr,pr,r,ps
      common/ cst5  /p,t,xco2,u1,u2,tr,pr,r,ps

      double precision pp,tt,yy,rr
      common/ cst85 /pp,tt,yy,rr

      integer iff,idss,ifug,ifyn,isyn
      common / cst10 /iff(2),idss(h5),ifug,ifyn,isyn
    
      double precision ptx
      integer ipt2
      common/ cst32 /ptx(l5),ipt2

      double precision thermo,uf,us
      common/ cst1 /thermo(k4,k10),uf(2),us(h5)

      logical gflu,aflu,fluid,shear,lflu,volume,rxn
      common/ cxt20 /gflu,aflu,fluid(k5),shear,lflu,volume,rxn
c                                 interval limits conformal transformation
      integer intv
      double precision yint, yfrc
      common/ cst47 /yint(5,ms1,mst,h9),yfrc(4,ms1,mst,h9),intv(4)

      character*2 strgs, mstrg, dstrg, tstrg*3
      common/ cst56 /strgs(18), mstrg(6), dstrg(8), tstrg(10)

      character*29 list
      common / cst206 /list(20)

      character*80 com
      common/delet/com 

      integer hs2p
      double precision hsb
      common/ cst84 /hsb(i8,4),hs2p(6)
c-----------------------------------------------------------------------
      data hs2p/4, 5, 18, 19, 20, 21/

      data iff/2*0/,ipt2/0/
c
      data us, uf/ h5*0d0, 2*0d0/

      data r,rr/8.3144126d0,83.144126d0/

      data gflu/.false./

      data com/' '/

      data intv/1,2,4,1/
c                                 tags for thermo data i/o
      data strgs/'G0','S0','V0','c1','c2','c3','c4','c5','c6',
     *           'c7','b1','b2','b3','b4','b5','b6','b7','b8'/
      data mstrg/'m0','m1','m2','k0','k1','k2'/
      data dstrg/'d1','d2','d3','d4','d5','d6','d7','d8'/
      data tstrg/'t1 ','t2 ','t3 ','t4 ','t5 ','t6 ','t7 ','t8 ','t9 ',
     *           't10'/
c     data estrg/'eG0','eS0','eV0','ec1','ec2','ec3','ec4','ec5','ec6',
c    *           'ec7','eb1','eb2','eb3','eb4','eb5','eb6','eb7','eb8'/

      data list /'standard free energy g (j)   ',
     *           'standard entropy s (j/k)     ',
     *           'standard volume v (j/bar)    ',
     *           'heat capacity coefficient c1 ',
     *           'heat capacity coefficient c2 ',
     *           'heat capacity coefficient c3 ',
     *           'heat capacity coefficient c4 ',
     *           'heat capacity coefficient c5 ',
     *           'heat capacity coefficient c6 ',
     *           'heat capacity coefficient c7 ',
     *           'volumetric coefficient b1    ',
     *           'volumetric coefficient b2    ',
     *           'volumetric coefficient b3    ',
     *           'volumetric coefficient b4    ',
     *           'volumetric coefficient b5    ',
     *           'volumetric coefficient b6    ',
     *           'volumetric coefficient b7    ',
     *           'volumetric coefficient b8    ',
     *           'activity                     ',
     *           'reaction coefficient         '/

      end

      subroutine getphi (name,eof)
c----------------------------------------------------------------------
c read phase data from the thermodynamic data file from lun N2, assumes
c topn2 has read the header section of the file.
c----------------------------------------------------------------------
      implicit none
 
      include 'perplex_parameters.h'
 
      integer i, it, j, ier, err

      double precision ct

      logical eof

      character key*22, val*3, name*8,
     *          nval1*12, nval2*12, nval3*12, strg*40, strg1*40

      integer ictr, itrans
      double precision ctrans
      common/ cst207 /ctrans(k0,k5),ictr(k5),itrans

      integer idh2o,idco2,ikind,icmpn,icout,ieos
      double precision comp,tot
      common/ cst43 /comp(k0),tot,icout(k0),idh2o,idco2,
     *               ikind,icmpn,ieos

      integer indxs(k4), ierct 
      logical amir 
      double precision therm0, err0, qemm0
      common/ cst53 /therm0(k4,k10), err0(k4,k10), qemm0(4,k10), amir
c----------------------------------------------------------------------
      eof = .false.

      do 

         call redcd1 (n2,ier,key,val,nval1,nval2,nval3,strg,strg1)

         if (ier.lt.0) then
 
            eof = .true.
            exit

         else if (ier.gt.0) then
                 
            call error (23,ct,i,name)

         end if 
c                                 name          
         read (key,'(a)',iostat=ier) name
         if (ier.ne.0) exit
c                                 EoS
         read (nval2,*,iostat=ier) ieos
         if (ier.ne.0) exit    
c                                 look for comments
c        write (com,'(80a1)') (chars(i),i=icom,icom+79)
c                                 composition
         call formul (n2)
c                                 thermodynamic data
         call indata (n2)
c                                 amir
         if (amir) then 
            read (n2,*,iostat=err) (err0(i,k10), i = 1, 11)
            if (err.ne.0) then 
               write (*,*) ' ok, fuckwit, at or before ',name
               write (*,*) ' you have an entry without 11 numeric error'
     *                    ,' values.' 
               stop
            end if 
         end if   
c                                 do component transformation if
c                                 itrans is not zero
         if (itrans.gt.0) then
 
            do i = 1, itrans
               it = ictr(i)
               if (comp(it).ne.0d0.and.ctrans(it,i).ne.0d0) then
c                                 ct is how much of the new
c                                 component is in the phase.
                  ct =  comp(it) / ctrans(it,i)
 
                  do j = 1, icmpn
                     comp(j) = comp(j) - ct * ctrans(j,i)
                  end do 
 
                  comp(it) = ct
               end if 
            end do
         end if
 
         exit 

      end do 

      end

      subroutine indata (lun)
c----------------------------------------------------------------------
c called by getphi to decompile thermodynamic data cards read from lun.
c----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer lun, ier, iscan, iscnlt, i, j, ibeg, iend, jlam

      character key*22, values*80, strg*80

      double precision var

      logical ok

      integer idh2o,idco2,ikind,icmpn,icout,ieos
      double precision comp,tot
      common/ cst43 /comp(k0),tot,icout(k0),idh2o,idco2,
     *               ikind,icmpn,ieos

      integer ilam,idiso,lamin,idsin
      double precision tm,td
      common/ cst202 /tm(m7,m6),td(m8),ilam,idiso,lamin,idsin

      double precision emodu
      common/ cst318 /emodu(k15)

      integer length,iblank,icom
      character chars*1
      common/ cst51 /length,iblank,icom,chars(240)

      double precision thermo, uf, us
      common/ cst1 /thermo(k4,k10),uf(2),us(h5)

      character*2 strgs, mstrg, dstrg, tstrg*3
      common/ cst56 /strgs(18), mstrg(6), dstrg(8), tstrg(10)
c-----------------------------------------------------------------------
c                                 initialize data
c                                 flag for t-dependent disorder
      idiso = 0
c                                 flag for mock-lambda transitions
      ilam = 0 
c                                 counter of mock-lambda transitions
      jlam = 0 
c                                 flag for shear moduli
      ikind = 0 
c                                 standard thermo parameters
      do i = 1, k4
         thermo(i,k10) = 0d0
      end do 
c                                 shear modulus
      do i = 1, k15
         emodu(i) = 0d0
      end do
c                                 lamda transitions
      do j = 1, m6
         do i = 1, m7
            tm(i,j) = 0d0
         end do
      end do
c                                 t-dependent disorder
      do i = 1, m8
         td(i) = 0d0
      end do 

      do 
c                                 find a data card
         call redcd0 (lun,ier,key,values,strg)
         if (ier.ne.0) call error (23,tot,ier,strg) 

         ibeg = 1

         if (key.eq.'end') then 

            exit 

         else if (key.eq.'transition') then 

            ibeg = iscan (iblank,icom,'=') + 1
            ibeg = iscnlt (ibeg,icom,' ')
            iend = iscan (ibeg+1,icom,'=') + 1
c                                 write ilam data to values
            write (values,'(80a1)',iostat=ier) (chars(i),i=ibeg,iend)
            if (ier.ne.0) call error (23,tot,ier,strg)
c                                 ilam as read is the counter, code
c                                 currently assumes the data is entered
c                                 sequentially, therefore this isn't necessary.
            read (values,*,iostat=ier) ilam
            if (ier.ne.0) call error (23,tot,ier,strg)
c                                 next get the type flag jlam.
            ibeg = iend
            iend = iscnlt (ibeg,icom,'9')

            write (values,'(80a1)',iostat=ier) (chars(i),i=ibeg,iend)
            if (ier.ne.0) call error (23,tot,ier,strg)
            read (values,*,iostat=ier) jlam
            if (ier.ne.0) call error (23,tot,ier,strg) 
c                                 position for next keyword
            ibeg = iend

         end if
c                                 read remaining keywords and values
c                                 from card
         do 
c                                 locate end of keyword
            if (ibeg.ge.icom) exit 
            iend = iscan (ibeg,icom,'=') - 1
            if (iend.ge.icom) exit
c                                 write keyword
            write (key,'(22a1)',iostat=ier) (chars(i),i=ibeg,iend)
            if (ier.ne.0) call error (23,tot,ier,strg) 
c                                 locate data
            ibeg = iscnlt (iend+2,icom,' ')
            iend = iscan (ibeg,icom,' ')
c                                 write data 
            write (values,'(80a1)',iostat=ier) (chars(i),i=ibeg,iend)
            if (ier.ne.0) call error (23,tot,ier,strg) 
c                                 shift pointer to next key
            ibeg = iscnlt(iend,icom,' ')
c                                 assign data
            ok = .false.
c                                 =====================================
c                                 simple thermo data 
            do i = 1, 18
               if (key.eq.strgs(i)) then 
                  read (values,*,iostat=ier) thermo(i,k10)
                  if (ier.ne.0) call error (23,tot,ier,strg) 
                  ok = .true.
                  exit 
               end if 
            end do 

            if (ok) cycle
c                                 =====================================
c                                 shear mod data 
            do i = 1, 6
               if (key.eq.mstrg(i)) then 
c                                 set shear/bulk mod flag
                  if (ikind.eq.0.and.i.lt.4) then
                     ikind = 1
                  else if (i.gt.3) then 
                     ikind = 2
                  end if 
                  
                  read (values,*,iostat=ier) emodu(i)
                  if (ier.ne.0) call error (23,tot,ier,strg) 
                  ok = .true.
                  exit 
               end if 
            end do 

            if (ok) cycle
c                                 =====================================
c                                 explicit temperature-dependent disorder data 
            do i = 1, 8
               if (key.eq.dstrg(i)) then 
c                                 set disorder flag
                  idiso = 1
                  read (values,*,iostat=ier) td(i)
                  if (ier.ne.0) call error (23,tot,ier,strg) 
                  ok = .true.
                  exit 
               end if 
            end do 

            if (ok) cycle
c                                 =====================================
c                                 mock-lambda transition data 
            do i = 1, 10
               if (key.eq.tstrg(i)) then 
                  read (values,*,iostat=ier) tm(i,ilam)
                  if (ier.ne.0) call error (23,tot,ier,strg) 
                  ok = .true.
                  exit 
               end if 
            end do 

            if (ok) cycle

            call error (9,var,i,key)

         end do

      end do 
c                                 set the transition counter
      if (ilam.gt.0) ilam = 3*(jlam-1) + ilam
                                 
      end  

      subroutine getkey (n,ier,key,values,strg)
c----------------------------------------------------------------------
c getkey calls redcd0 and outputs error message 21 on error.
c----------------------------------------------------------------------
      implicit none
 
      integer n, ier 

      character key*22, values*80, strg*80
c----------------------------------------------------------------------

      call redcd0 (n,ier,key,values,strg)

      if (ier.ne.0) call error (21,0d0,n,strg)

      end 

      subroutine redcd0 (lun,ier,key,values,strg)
c----------------------------------------------------------------------
c this routine seeks a non-blank card that contains data, i.e., something
c other than a comment (text preceeded by a "|") character. 
c the first word of the data is saved as key, the remaining words are
c are saved in values, and the complete data is saved as strg.
c the full record (including comments) is saved in chars.

c the card is also loaded into chars with:

c  length - position of last non-blank character
c  iblank - position of first blank after the key
c  icomm  - position of the comment character
c----------------------------------------------------------------------    
      implicit none

      include 'perplex_parameters.h'

      integer lun, len, ier, iscan, i, iscnlt, ibeg, iend

      character card*240, key*22, values*80, strg*80

      integer length,iblank,icom
      character chars*1
      common/ cst51 /length,iblank,icom,chars(240)
c----------------------------------------------------------------------

      ier = 0 
      key = ' '

      do 

         read (lun,'(a)',iostat=ier) card

         if (card.ne.' ') then 

            read (card,'(240a)') chars
c                                 find end of data marker '|'
            len = iscan (1,240,'|') - 1
            icom = len
c                                 find a non blank character
            ibeg = iscnlt (1,len,' ')
c                                 find the next blank
            iblank = iscan (ibeg,len,' ')
c                                 len < ibeg => only comments
            if (ibeg.ge.len) cycle
c                                 full record length
            length = iscnlt (240,1,' ')

            exit 

         else if (ier.ne.0) then 

            exit 

         end if 

      end do 

      if (ier.eq.0) then 
c                                 find end of keyword 
         iend = ibeg + 1
         iend = iscan (iend,240,' ') - 1
         if (iend.gt.22) iend = 22
c                                 load chars into key
         write (key,'(22a1)') (chars(i), i = ibeg, iend)
c                                 now the values
         ibeg = iscnlt (iend+1,240,' ') 

         if (ibeg.lt.240) then 

            iend = iscnlt (len,ibeg,' ')
            if (iend-ibeg.gt.79) iend = ibeg + 79
c                                 load chars into value
            write (values,'(80a1)') (chars(i), i = ibeg, iend)
c                                 load chars into strg
            if (iend.gt.80) iend = 80
            write (strg,'(80a1)') (chars(i),i=1,iend)
        
         else
c                                 no values
            strg = key

         end if 

      end if 

      end 


      subroutine formul (lun)
c----------------------------------------------------------------------
c formul reads a text formula and coverts the result to the composition
c array comp. allowed component names are read from xcmpnt array to 
c avoid problems associated with component transformations. 
c----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer lun, len0, len1, ier, iscan, i, ibeg, iend

      character key*22, values*80, strg*80, ctemp*5, ntemp*12

      logical ok

      integer idh2o,idco2,ikind,icmpn,icout,ieos
      double precision comp,tot
      common/ cst43 /comp(k0),tot,icout(k0),idh2o,idco2,
     *               ikind,icmpn,ieos

      integer length,iblank,icom
      character chars*1
      common/ cst51 /length,iblank,icom,chars(240)

      character tcname*5,xcmpnt*5
      common/ csta9 /tcname(k0),xcmpnt(k0)
c-----------------------------------------------------------------------
      do i = 1, icmpn
         comp(i) = 0d0
      end do

      call getkey (lun,ier,key,values,strg)

      if (ier.ne.0) call error (23,0d0,i,strg)

      ibeg = 1
      iend = iscan (ibeg,240,' ') - 1

      do 
c                                 find the "(" and ")"
         len0 = iscan (ibeg,iend,'(') 
         len1 = iscan (len0,iend,')')
c                                 write the name and number
         write (ctemp,'(5a)')   (chars(i),i=ibeg,len0-1)
         write (ntemp,'(14a1)') (chars(i),i=len0+1,len1-1)
c                                 identify the component
         ok = .false.

         do i = 1, icmpn
            if (xcmpnt(i).eq.ctemp) then
               read (ntemp,*) comp(i)
               ok = .true.
               exit 
            end if 
         end do      

         if (.not.ok) call error (23,0d0,i,strg)

         if (len1.eq.iend) exit

         ibeg = len1 + 1

      end do                  

      end 

      subroutine outdat (lun,id,option)
c----------------------------------------------------------------------
c lun    - output LUN
c id     - phase pointer
c option - source of compositional data 

c called by frendly, vertex, ctransf, actcor, rewrit. for processed data 
c requires unver and unlam to recover original data; unlam puts the 
c transition data into the local array tm; other data is the primary 
c arrays (cp or comp[see option below], thermo, therdi)

c if option = 1 then formula for entity id created from the 
c    composition array cp and name array cmpnt via pointer ic
c if option = 0  then formula for entity id created from the 
c    composition array comp and name array cmpnt.
c----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'

      integer lun, len, i, j, ibeg, iend, id, option, jcomp

      character text(14)*1

      double precision var

      double precision cp
      common/ cst12 /cp(k5,k1)

      integer ic
      common/ cst42 /ic(k0)

      integer icomp,istct,iphct,icp
      common/ cst6 /icomp,istct,iphct,icp

      integer idh2o,idco2,ikind,icmpn,icout,ieos
      double precision comp,tot
      common/ cst43 /comp(k0),tot,icout(k0),idh2o,idco2,
     *               ikind,icmpn,ieos

      integer ilam,idiso,lamin,idsin
      double precision tm,td
      common/ cst202 /tm(m7,m6),td(m8),ilam,idiso,lamin,idsin

      integer iemod,kmod
      logical smod,pmod
      double precision emod
      common/ cst319 /emod(k15,k10),smod(h9),pmod(k10),iemod(k10),kmod

      integer cl
      character cmpnt*5, dname*80
      common/ csta5 /cl(k0),cmpnt(k0),dname

      integer length,iblank,icom
      character chars*1
      common/ cst51 /length,iblank,icom,chars(240)

      double precision thermo, uf, us
      common/ cst1 /thermo(k4,k10),uf(2),us(h5)

      integer idis,lmda,ltyp
      common/ cst204 /ltyp(k10),lmda(k10),idis(k10)

      double precision therdi,therlm
      common/ cst203 /therdi(m8,m9),therlm(m7,m6,k9)

      integer eos
      common/ cst303 /eos(k10)

      character*8 names
      common/ cst8 /names(k1)

      character*80 com
      common/delet/com 

      character*2 strgs, mstrg, dstrg, tstrg*3
      common/ cst56 /strgs(18), mstrg(6), dstrg(8), tstrg(10)
c-----------------------------------------------------------------------
c                                 =====================================
c                                 name & EoS
      write (lun,*) 
      read (names(id),'(8a1)') (chars(i), i = 1, 8)
      ibeg = 9
      var = eos(id)
      call outthr (var,' EoS',4,ibeg) 

      if (com.ne.' ') then 
         chars(ibeg) = '|'
         read (com,'(80a1)') (chars(i), i = ibeg+1, ibeg+80)
         ibeg = ibeg + 80
      end if 

      write (lun,'(240a1)') (chars(i), i = 1, ibeg)
c                                 =====================================
c                                 formula
      ibeg = 1
      iend = 0

      if (option.eq.0) then
         jcomp = icmpn
      else 
         jcomp = icomp
      end if 
      
      do i = 1, jcomp

         if (option.eq.0) then
            var = comp(i)
         else 
            var = cp(i,id)
         end if 

         if (var.ne.0) then 
c                                 load text name
            iend = ibeg + cl(ic(i)) - 1

            read (cmpnt(ic(i)),'(5a1)') (chars(j), j = ibeg, iend)
c                                 left parenthesis
            chars(iend + 1) = '('
c                                 get number
            call numtxt (var,text,len)
c                                 load number into chars
            ibeg = iend + 2
            iend = ibeg + len - 1

            do j = ibeg, iend
               chars(j) = text(j-ibeg+1)
            end do 

            chars(j) = ')'
 
            ibeg = iend + 2

         end if 

      end do 
c                                 write the formula
      write (lun,'(240a1)') (chars(i), i = 1, iend+1)
c                                 =====================================
c                                 thermo data
      ibeg = 1
 
      do i = 1, 3
         call outthr (thermo(i,id),strgs(i),2,ibeg)
      end do
c                                 write G,S,V
      if (ibeg.gt.1) write (lun,'(240a1)') (chars(i), i = 1, ibeg)
c                                 c1->c7 of thermo data
      ibeg = 1
 
      do i = 4, 10
         call outthr (thermo(i,id),strgs(i),2,ibeg)
      end do
c                                 write c1->c7
      if (ibeg.gt.1) write (lun,'(240a1)') (chars(i), i = 1, ibeg)
c                                 b1->b8 of thermo data
      ibeg = 1

      do i = 11, 18
         call outthr (thermo(i,id),strgs(i),2,ibeg)
      end do
c                                 write b1->b8
      if (ibeg.gt.1) write (lun,'(240a1)') (chars(i), i = 1, ibeg)
c                                 =====================================
c                                 shear/bulk modulus
      ibeg = 1

      do i = 1, 6
         call outthr (emod(i,id),mstrg(i),2,ibeg)
      end do

      if (ibeg.gt.1) write (lun,'(240a1)') (chars(i), i = 1, ibeg)
c                                 =====================================
c                                 disorder parameters
      if (idis(id).ne.0) then 
         ibeg = 1
         do i = 1, 8
            call outthr (therdi(i,idis(id)),dstrg(i),2,ibeg)
         end do 

         if (ibeg.gt.1) write (lun,'(240a1)') (chars(i), i = 1, ibeg)

      end if 
c                                 =====================================
c                                 transition parameters
      do i = 1, lmda(id)

         ibeg = 1
         var = i
         call outthr (var,'transition',10,ibeg)
         var = (ltyp(id)-1)/3 + 1
         call outthr (var,'type',4,ibeg) 

         do j = 1, 10
            call outthr (tm(j,i),tstrg(j),3,ibeg)
         end do 

         if (ibeg.gt.1) write (lun,'(240a1)') (chars(j), j = 1, ibeg)

      end do 

      write (lun,1000)

1000  format ('end',/)

      end 

      subroutine outthr (num,strg,len,ibeg)
c----------------------------------------------------------------------
c output prettified data.

c    num - the numeric data 
c    strg - a text tag for the data
c    len - length of strg
c    ibeg - pointer to the location for the data in the output array (chars)
c----------------------------------------------------------------------
      implicit none

      double precision num

      character strg*(*), text(14)*1

      integer i, ibeg, iend, len, len0 

      integer length,iblank,icom
      character chars*1
      common/ cst51 /length,iblank,icom,chars(240)

      if (num.ne.0d0) then 

         iend = ibeg + len - 1
         read (strg,'(14a1)') (chars(i),i=ibeg,iend)
         chars(iend+1) = ' '
         chars(iend+2) = '='
         chars(iend+3) = ' '

         call numtxt (num,text,len0)

         do i = 1, len0
            chars(iend+3+i) = text(i)
         end do

         chars(iend+3+i) = ' '
         chars(iend+4+i) = ' '

         ibeg = iend + 4 + i

      end if 

      end 

      subroutine numtxt (num,text,len)
c----------------------------------------------------------------------
c convert a g14.7e2 number to simplest possible text
c----------------------------------------------------------------------
      implicit none

      double precision num

      character text(14)*1, strg*14

      logical dec

      integer i, len, inum, ier, ibeg, iend, jscnlt, jscan
c----------------------------------------------------------------------
      inum = int(num)

      if (num-inum.eq.0d0) then 
c                                 the number can be represented as 
c                                 an integer
         write (strg,'(i14)',iostat=ier) inum

      else 

         write (strg,'(g14.7E2)',iostat=ier) num

      end if 

      if (ier.ne.0) then 
 
         write (*,*) 'format overflow in numtxt'
         stop

      end if 

      read (strg,'(14a1)') text

      ibeg = jscnlt (1,14,' ',text)
      iend = jscan (ibeg,14,' ',text) - 1
c                                 shift text left
      len = 0 

      dec = .true.

      do i = ibeg, iend

         len = len + 1
         text(len) = text(i)

         if (text(len).gt.'A') dec = .false. 

      end do 
c                                 pruning:
      if (text(1).eq.'0') then
c                                 cut leading zero/+
         do i = 1, len - 1
            text(i) = text(i + 1)
         end do
         len = len - 1 
      else if (text(1).eq.'-'.and.text(2).eq.'0') then
c                                 cut leading zero
         do i = 2, len-1
            text(i) = text(i + 1)
         end do
         len = len - 1
      end if

      if (dec) then 
c                                decimal number
         iend = jscan (1,len,'.',text)
c                                reduce len to cut trailing zeroes
         if (iend.lt.len) len = jscnlt (len,iend,'0',text)

      else if (num-inum.ne.0d0) then 
c                                 find the E char
         iend = jscnlt (1,len,'A',text)
         ibeg = jscnlt (iend-1,1,'0',text) + 1
         inum = iend - ibeg
c             
         do i = ibeg, len - inum
            text(i) = text(i + inum)
         end do   

         len = len - inum
c                                 the E character is now at
         ibeg = iend - inum   

         if (text(ibeg+1).eq.'+') then

            inum = 1 
            if (text(ibeg+2).eq.'0') inum = 2
c                                 delete superfluous + and 0
            do i = ibeg+1, len - inum
               text(i) = text(i + inum)
            end do
          
            len = len - inum

         else if (text(ibeg+1).eq.'-') then
c                                 delete superfluous 0
            if (text(ibeg+2).eq.'0') then
               do i = ibeg+2, len - 1
                  text(i) = text(i + 1)
               end do
           
               len = len - 1

            end if 

         end if 
       
      end if 

      end 

      integer function jscnlt (ibeg,iend,char,chars)
c----------------------------------------------------------------------
c iscan finds the first occurence of a character in chars(ibeg..iend) that
c is greater than char. assuming ascii collating sequence +/- < 0 < a
c----------------------------------------------------------------------
      implicit none

      character char*1, chars(14)*1

      integer ibeg, iend, inc
c----------------------------------------------------------------------

      if (ibeg.le.iend) then 
         inc = 1
      else 
         inc = -1
      end if 

      do jscnlt = ibeg, iend, inc

         if (chars(jscnlt).gt.char) exit

      end do 

      end 

      integer function jscan (ibeg,iend,char,chars)
c----------------------------------------------------------------------
c jscan finds the first occurence of char in chars(ibeg..iend)
c----------------------------------------------------------------------
      implicit none

      character char*1, chars(14)*1

      integer ibeg, iend
c----------------------------------------------------------------------
      do jscan = ibeg, iend

         if (chars(jscan).eq.char) exit

      end do 

      end 

      subroutine fopen1 
c-----------------------------------------------------------------------
c fopen1 gets the project name and opens the problem definition file
c    n1name = project_name.dat
c iam is a flag indicating the calling program:
c    4 - build
c    else - vertex,meemum
c------------------------------------------------------------------------
      implicit none
 
      include 'perplex_parameters.h'
 
      character y*1,n1name*100

      integer ierr

      character*100 prject,tfname
      common/ cst228 /prject,tfname

      integer iam
      common/ cst4 /iam
c-----------------------------------------------------------------------

      iam = 2

      do 
c                                 get the root for all output files
         if (iam.eq.4) then 
c                                 BUILD
            write (*,1040)

         else  
c                                 VERTEX, MEEMUM
            write (*,1030) 

         end if 
c                                 readrt loads the root into prject
c         call readrt
         prject = 'amir_mantle_input' 
c                                 make the problem definition file name
         call mertxt (n1name,prject,'.dat',0)

         if (iam.eq.4) then 

            write (*,1070) n1name
c                                  BUILD
            open (n1,file=n1name,iostat=ierr,status='new')

            if (ierr.ne.0) then
c                                  name exists
               write (*,1050) n1name
               read (*,'(a)') y

               if (y.eq.'Y'.or.y.eq.'y') then 
c                                  overwrite it
                  open (n1,file=n1name)

               else
c                                  try again 
                  cycle 

               end if 

            end if
         
         else 
c                                  VERTEX, MEEMUM
            open (n1,file=n1name,iostat=ierr,status='old')

            if (ierr.ne.0) then
c                                  name does not exist
               write (*,1080) n1name
               read (*,'(a)') y
               if (y.eq.'Y'.or.y.eq.'y') then 
c                                  try again
                  cycle 

               else 
c                                  quit
                  stop 
 
               end if 

            end if

         end if 

         exit 

      end do 

1030  format (/,'Enter the project name (the name assigned ',
     *        'in BUILD) [default = my_project]:')
1040  format (/,'Enter a name for this project (the name',
     *        ' will be used as the',/,'root for all output file names)'
     *       ,' [default = my_project]:')
1050  format (/,'The file: ',a,/,'exists, overwrite it (y/n)?')
1070  format (/,'The problem definition file will be named: ',a) 
1080  format (/,'**warning ver191** no problem definition file named: ',
     *       a,/,'Run BUILD to create the file or change project names.'
     *       ,//,'Enter a different project name (y/n)?')
      end 

      subroutine readrt
c----------------------------------------------------------------------
c readrt - read file name root from terminal
c----------------------------------------------------------------------    
      implicit none

      include 'perplex_parameters.h'
 
      integer kscan, i, iscnlt, ierr

      character*100 prject,tfname
      common/ cst228 /prject,tfname

      integer length,iblank,icom
      character chars*1
      common/ cst51 /length,iblank,icom,chars(240)
c----------------------------------------------------------------------
      do 

         read (*,'(a)') prject

         if (prject.ne.' ') then 

            read (prject,'(100a)') (chars(i),i=1,100)
c                                 find end of name ' '
            length = iscnlt (100,1,' ') 
c                                 check length
            if (length.gt.90) then 
               write (*,1010) 
               cycle 
            end if 
c                                 look for path characters / or \
            icom = kscan (100,1,'/')
            if (icom.eq.0) icom = kscan (100,1,'\')

            if (icom.eq.length) then 
               write (*,1030)
               cycle
            end if 
c                                 check if directory is valid
            if (icom.ne.0) then 
               write (tfname,'(100a)') (chars(i),i=1,icom)
               call mertxt (tfname,tfname,'delete_me',0)
               open (n1,file=tfname,iostat = ierr)
               if (ierr.ne.0) then 
                  write (*,1040)
                  cycle 
               end if  

            end if 
c                                 look for illegal "." character
            if (kscan(icom+1,length,'.').lt.length) then 
               write (*,1000)
               cycle 
            end if 
c                                 look for illegal " " character
            if (kscan(icom+1,length,' ').lt.length) then 
               write (*,1020)
               cycle
            end if 

         else 

            prject = 'my_project'

         end if 

         exit

      end do 

1000  format (/,'file/project names cannot include . characters, ',
     *          'try again',/)
1010  format (/,'file/project names must be < 91 characters, '
     *         ,'try again',/)
1020  format (/,'tfile/project names cannot include blanks, ',
     *          'try again',/)
1030  format (/,'file/project names cannot end with a / or \ character',
     *        ', try again',/)
1040  format (/,'the path specified in your project name is invalid,',
     *          ' check that all the ',/,
     *          'directories in the path exist, try again.',/)
      end

      subroutine getrt
c----------------------------------------------------------------------
c getrt - extracts root file name from the full file name in tfname
c----------------------------------------------------------------------    
      implicit none

      include 'perplex_parameters.h'
 
      integer kscan, i

      character*100 prject,tfname
      common/ cst228 /prject,tfname

      integer length,iblank,icom
      character chars*1
      common/ cst51 /length,iblank,icom,chars(240)
c----------------------------------------------------------------------
      read (tfname,'(100a)') (chars(i),i=1,100)
c                                 find end of name ' '
      length = kscan (1,100,' ') - 1
c                                 look for dot character
      icom = kscan (length,1,'.') - 1

      if (icom.le.0) icom = length

      write (prject,'(100a)') (chars(i),i=1,icom)

      end

      subroutine fopen2 (jam,name)
c-----------------------------------------------------------------------
c fopen2 - choose and open a thermodynamic data file on unit n2, jam 
c indicates behavior required by the calling program:
c  0 - name passed as argument, error if not found.
c  1 - BUILD, queries for name and writes it to N1
c  2 - queries for name
c-----------------------------------------------------------------------
      implicit none
 
      include 'perplex_parameters.h'
 
      character*100 name, y*1, ddata*14, text*140

      integer ierr, jam

      data ddata/'hp02ver.dat   '/
c-----------------------------------------------------------------------

      do 

         if (jam.ne.0) then 
            write (*,1000)
            read (*,'(a)') name
            if (name.eq.' ') name = ddata
         end if 

         open (n2,file=name,iostat=ierr,status='old')

         if (ierr.ne.0) then
c                                 system could not find the file
            if (jam.eq.0) call error (120,0d0,n2,name)
c                                 if not vertex allow another try
            write (*,1010) name
            read (*,'(a)') y

            if (y.ne.'Y'.and.y.ne.'y') then
               write (*,1060)
               stop
            end if             
c                                 try again
            cycle

         end if
 
         if (jam.ne.1) exit 
c                                 BUILD, echo name to n1: 
         call mertxt (text,name,'thermodynamic data file',5)
         write (n1,'(a)') text 

         exit

      end do 
 
1000  format (/,'Enter thermodynamic data file name',
     *          ' [default = hp02ver.dat]:')
1010  format (/,'**warning ver191** FOPEN2 cannot find file:',/,a
     *         ,//,'try again (y/n)?')
1060  format (/,'O.K., I quit too.')

      end

      subroutine mertxt (text,text1,text2,nblank)
c----------------------------------------------------------------------- 
c mertxt - merge text two strings cutting trailing/leading blanks, with 
c          nblank characters between the two strings if text1 eq 
c          blank then pad by an initial 40 blanks.

c     input  - text1, text2 - character strings
c              nblank - number of blanks between the strings in text
c     output - text - character string 
c----------------------------------------------------------------------
      implicit none

      integer i, nchar1, nchar2, nblank

      character text*(*), text1*(*), text2*(*)

      integer length,iblank,icom
      character chars*1
      common/ cst51 /length,iblank,icom,chars(240)
c----------------------------------------------------------------------
c                                 strip leading blanks in text1 and
c                                 get pointer to end of string
      call leblnk (text1,1,nchar1)

      if (nchar1.le.0) then 
c                                 text1 is blank
         nchar1 = 40

         do i = 1, nchar1 + nblank
            chars(i) = ' '
         end do 

      else 
c                                 put nblank blanks between 1st and 
c                                 2nd strings
         do i = nchar1+1, nchar1 + nblank
            chars(i) = ' '
         end do 

      end if
c                                 nchar1 points to the first empty char
      nchar1 = nchar1 + nblank + 1 
c                                 strip leading blanks from string in text2 and
c                                 get pointer to end of string in chars
      call leblnk (text2,nchar1,nchar2)

      text = ' '
      if (nchar2.gt.len(text)) call error (10,0d0,240,text2)
      write (text,'(240a)') (chars(i), i = 1, nchar2)

      end

      subroutine leblnk (text,ibeg,nchar)
c----------------------------------------------------------------------
c leblnk - scan text and strip leading blanks load into chars from
c position ibeg, nchar is the last non blank in char
c non-blank character in stripped string
c----------------------------------------------------------------------
      implicit none 

      integer i, ibeg, nchar, ist
 
      character text*(*)

      integer length,iblank,icom
      character chars*1
      common/ cst51 /length,iblank,icom,chars(240)
c----------------------------------------------------------------------
      nchar = len(text) + ibeg -1 
      if (nchar.gt.240) nchar = 240

      read (text,'(240a)') (chars(i), i = ibeg, nchar)
c                                 find last non-blank   
      
      do i = ibeg, nchar
         if (chars(i).gt.' ') exit
      end do  

      ist = i 

      if (ist.gt.nchar) then 
c                                 all blank
         nchar = 0

      else 

         if (ist.gt.ibeg) then 
c                                 shift chars ist-1 left
            do i = ist, nchar
               chars(i+ibeg-ist) = chars(i)
            end do
         end if  
c                                 find last non-blank
         nchar = nchar + ibeg - ist

         do i = nchar, ibeg, -1
            if (chars(i).gt.' ') exit
         end do 

         nchar = i 

      end if 

      end

      subroutine getstg (text)
c---------------------------------------------------------------------- 
c getstg - subroutine to get first non-blank string  
c          
c     text - character string on input, first non-blank strg on output
c----------------------------------------------------------------------
      implicit none 

      integer i, nchar, ist
 
      character text*(*)

      integer length,iblank,icom
      character chars*1
      common/ cst51 /length,iblank,icom,chars(240)
c----------------------------------------------------------------------
      nchar = len(text) 
      if (nchar.gt.240) nchar = 240

      read (text,'(240a)') (chars(i), i = 1, nchar)
c                                 scan for blanks:
      ist = 1

      do i = 1, nchar
         if (chars(i).eq.' ') cycle 
         ist = i
         exit 
      end do 

      do i = ist, nchar
         if (chars(i).ne.' ') cycle 
         nchar = i-1
         exit 
      end do 

      text = ' '

      write (text,'(240a)') (chars(i), i = ist, nchar)

      end

      subroutine gettrn (iopt)
c----------------------------------------------------------------------
c iopt = 3 -> build
c iopt = 5 -> ctransf
c----------------------------------------------------------------------
      implicit none
 
      include 'perplex_parameters.h'

      integer i,j,iopt,ict,ier,jscan
 
      character*5 pname, rname, y*1

      double precision sum

      integer ictr, itrans
      double precision ctrans
      common/ cst207 /ctrans(k0,k5),ictr(k5),itrans

      character tcname*5,xcmpnt*5
      common/ csta9 /tcname(k0),xcmpnt(k0)

      integer cl
      character cmpnt*5, dname*80
      common/ csta5 /cl(k0),cmpnt(k0),dname

      double precision atwt
      common/ cst45 /atwt(k0)

      integer id,ikind,icmpn,icout,ieos
      double precision comp,tot
      common/ cst43 /comp(k0),tot,icout(k0),id(2),ikind,icmpn,ieos
c-----------------------------------------------------------------------
c                                 recombine components:
      do 
         write (*,1030)
         write (*,1040) (cmpnt(i), i = 1, icmpn)
         write (*,1050)
         read (*,'(a)') y
         if (y.ne.'Y'.and.y.ne.'y') exit

         write (*,1060)
         read (*,'(a)') pname
         if (pname.eq.' ') exit
c                                 get the identity of the real comp
c                                 to be replaced.
50       write (*,1070) pname
         read (*,'(a)') rname

         do i = 1, icmpn
            if (rname.eq.cmpnt(i)) then
c                                 matches a name, check if it's a 
c                                 special component
               do j = 1, 2
                  if (i.ne.id(j)) cycle 
c                                 matches special component id(j) 
                  if (iopt.eq.3) then
c                                 don't allow build users 
c                                 to transform saturated
c                                 phase components
                     call warn (14,atwt(1),i,cmpnt(i))
                     goto 60
                  else 
c                                 ctransf, ask the user if the 
c                                 new component will be a special 
c                                 component
                     write (*,1010) cmpnt(i),pname
                     read (*,'(a)') y
                     if (y.eq.'y'.or.y.eq.'Y') cycle
                     id(j) = 0 

                  end if 
               end do 

               icout(1) = i
               goto 70

            end if
         end do 
 
60       write (*,1080) 
         write (*,1040) (cmpnt(i), i = 1, icmpn)
         goto 50
c                                 get the identities of the other 
c                                 components in the new component:
70       itrans = itrans + 1
         ict = 1
         if (itrans.gt.k5) call error (999,atwt(1),ict,'GETTRN')
       
         write (*,4050) k5-1,pname
30       read (*,'(a)') rname
         if (rname.eq.'     ') goto 80

         do i = 1, icmpn
            if (rname.eq.cmpnt(i)) then 
               ict = ict + 1
               icout(ict) = i
               goto 30
            end if
         end do 
c                                 no match, try again message
         write (*,2300)
         goto 30
c                                 get the component stoichiometries:
80       write (*,4030) (cmpnt(icout(i)),i=1,ict)
         write (*,4040) pname
90       read (*,*,iostat=ier) (ctrans(icout(i),itrans), i= 1, ict)
         call rerror (ier,*90)
 
         write (*,1100) pname,(ctrans(icout(i),itrans),
     *                      cmpnt(icout(i)), i = 1, ict)
         write (*,1110)
         read (*,'(a)') y
 
         if (y.eq.'y'.or.y.eq.'Y') then
            sum = 0d0
            do i = 1, ict
               sum = sum + ctrans(icout(i),itrans) * atwt(icout(i))
            end do 
            atwt(icout(1)) = sum
            cmpnt(icout(1)) = pname
            cl(icout(1)) = jscan(1,5,' ',pname) - 1
            tcname(itrans) = pname
            ictr(itrans) = icout(1)
         else
            itrans = itrans - 1
            write (*,1000) 
         end if

      end do 

1000  format ('Try again.')
1010  format (/,a,' is a possible saturated phase component. Is '
     *        'the new component ',a,/,'also a possible saturated ',
     *        'phase component (Y/N)?')
1030  format (/,'The current data base components are:')
1040  format (12(1x,a))
1050  format ('Transform them (Y/N)? ')
1060  format ('Enter new component name, < 6 characters,',
     *          ' left justified: ')
1070  format ('Enter old component to be replaced',
     *          ' with ',a,': ')
1080  format ('Select the component from the set: ')
1100  format (1x,a,' = ',6(f6.2,1x,a),/,9x,6(f6.2,1x,a))
1110  format ('Is this correct (Y/N)? ')
2300  format (/,'You made a mistake, try again.',/
     *          'Check spelling and upper/lower case matches.',/)
4030  format ('Enter stoichiometric coefficients of:',/,
     *        2x,12(a,1x))
4040  format ('in ',a,' (in above order): ')
4050  format ('Enter other components (< ',i2,') in ',a,' 1 per',
     *        ' line, <enter> to finish:')

      end

      subroutine topn2 (option)
c----------------------------------------------------------------------
c topn2 reads the header of the thermodynamic data file, if option > 3 
c echoes data to n8
c
c     option  calling program
c       0     vertex, meemum (all calls from clib.f)
c       1     frendly 
c       2     build (2nd, 3rd calls)
c       3     build (first call) 
c       4     actcor
c       5     ctransf
c----------------------------------------------------------------------
      implicit none

      include 'perplex_parameters.h'
 
      character tag*3, string*140, key*22, values*80, strg*80

      integer option, i, j, ier, iscan

      double precision sum

      integer iopt
      logical lopt
      double precision nopt
      common/ opts /nopt(i10),iopt(i10),lopt(i10)

      double precision delt,dtol,utol,ptol
      common/ cst87 /delt(l2),dtol,utol,ptol

      double precision v,tr,pr,r,ps
      common/ cst5  /v(l2),tr,pr,r,ps

      double precision ctrans
      integer ictr,itrans
      common/ cst207 /ctrans(k0,k5),ictr(k5),itrans

      integer iff,idss,ifug,ifyn,isyn
      common/ cst10 /iff(2),idss(h5),ifug,ifyn,isyn

      integer id,ikind,icmpn,icout,ieos
      double precision comp,tot
      common/ cst43 /comp(k0),tot,icout(k0),id(2),
     *               ikind,icmpn,ieos
  
      character vname*8, xname*8
      common/ csta2 /xname(k5),vname(l2)

      integer cl
      character cmpnt*5, dname*80
      common/ csta5 /cl(k0),cmpnt(k0),dname

      character tcname*5,xcmpnt*5
      common/ csta9 /tcname(k0),xcmpnt(k0)

      double precision atwt
      common/ cst45 /atwt(k0)

      integer length,iblank,icom
      character chars*1
      common/ cst51 /length,iblank,icom,chars(240)
c-----------------------------------------------------------------------
      rewind n2
c                                 frendly or actcor is reading
c                                 the header, no transformations
      if (option.eq.1.or.option.eq.4) itrans = 0
c                                 test for old (pre 4/2010) data file format:
      read (n2,*,iostat=ier) i
      if (ier.eq.0) call error (8,r,i,dname)

      rewind n2
c                                 database name
      call getkey (n2,ier,key,values,strg)

      dname = strg
c                                 extrinsic variable names & reference values
c                                 read "begin"
      call getkey (n2,ier,key,values,strg)

      do i = 1, l2

         call getkey (n2,ier,key,values,strg)
c                                 over ride default mobile component naming to 
c                                 allow build to use fugacities or activities.
         if (option.gt.3.or.i.lt.4) read (key,'(a8)') vname(i)
         read (values,*) v(i), delt(i)

      end do
c                                  read end key
      call getkey (n2,ier,key,values,strg)
c                                  set reference conditions
      pr = v(1)
      tr = v(2)
c                                  this block of code probably never gets executed?
      if (option.lt.4) then 
         if ((ifug.ge.10.and.ifug.le.12).or.
     *       ifug.eq.15.or.ifug.eq.17.or.ifug.eq.18) then 
            vname(3) = ' X(O) ' 
         else if (ifug.eq.25) then 
            vname(3) = 'Y(CO2)*'
         else if (ifug.eq.14.or.ifug.eq.13) then 
            vname(3) = 'X(H2)'
         end if 
      end if  
c                                 read tolerance dtol
      call getkey (n2,ier,key,values,strg)

      read (values,*) dtol
      dtol = -dabs(dtol)
c                                 set utol and ptol, the 
c                                 tolerances (in energy units) for determination of
c                                 the stability of divariant, univariant
c                                 and invariant equilibria or reactions.
c                                 utol must be smaller than -utol
c                                 ptol must be > 2*-dtol
      utol = -dtol/1d1
      ptol = -dtol*3d0 
c                                 component names & formula weights
c                                 read "begin"
      call getkey (n2,ier,key,values,strg)

      icmpn = 0 

      do

         call getkey (n2,ier,key,values,strg)
         
         if (key.eq.'end_components') exit

         icmpn = icmpn + 1

         read (key,'(a5)') cmpnt(icmpn)
c                                 get component string length
         cl(icmpn) = iscan(1,length,' ') - 1

         read (values,*) atwt(icmpn)

      end do
c                                 save old names for component transformations
c                                 in ctransf or build.
      do i = 1, k0
         xcmpnt(i) = cmpnt(i)
      end do
c                                 for programs that read the composition 
c                                 vector, check that the cp-dimension (k5)
c                                 is adequate
c     if (option.ne.0.and.option.ne.2.and.icmpn.gt.k5) 
c     *    call error (197,r,icmpn,'TOPN2')
c                                 read special components.
      lopt(7) = .false.
  
      call getkey (n2,ier,key,values,strg)

      if (key.eq.'begin_special_componen') then

         ikind = 0 

         do 
 
            call getkey (n2,ier,key,values,strg)
         
            if (key.eq.'end_special_components') exit

            do j = 1, icmpn
               if (key.eq.cmpnt(j)) then 
                  ikind = ikind + 1
                  id(ikind) = j
                  lopt(7) = .true.
                  exit
               end if 
            end do 
           
         end do 

      else
c                                 no saturated phase constraint possible
c                                 set lopt(7) to false. 
         backspace(n2)

      end if 

      if (option.eq.3.or.option.eq.5) then 
c                                 get transformations if build or ctransf
         call gettrn (option)
c                                 check special components
         if (lopt(7)) then 
            j = 0
            do i = 1, ikind
               if (id(i).ne.0) then
                  j = j + 1
                  id(j) = id(i)
               end if
            end do 
            ikind = j
            if (ikind.eq.0) lopt(7) = .false.
         end if 

      else if (option.ne.2) then 
c                                 substitute transformed component names
c                                 and compute the new formula wieghts
         do i = 1, itrans

            cmpnt(ictr(i)) = tcname(i)

            sum = 0d0

            do j = 1, icmpn
               sum = sum + ctrans(j,i) * atwt(j)
            end do
 
            atwt(ictr(i)) = sum

         end do 

      end if 

      if (option.gt.3) then 
c                                 echo formatted header data for ctransf/actcor:
         write (n8,1000) 
         write (n8,'(a,a,/)') dname,' |<= data base title'

         write (n8,'(a,a)') 'begin_standard_variables |<= name (<9 ',
     *                      'characters), reference value, tolerance'
         do i = 1, l2 
            write (n8,'(a8,1x,f7.2,3x,g6.1E1)') vname(i),v(i),delt(i)
         end do

         write (n8,'(a,/)') 'end_standard_variables'

         write (n8,'(a,g6.1E1,a,/)') 'tolerance  ',dtol,
     *         '  |<= DTOL for unconstrained minimization, energy units'
         write (n8,'(a,a)') 'begin_components |<= name (<5 characters),'
     *                      ,' molar weight (g)'
         write (n8,'(a5,1x,f9.4)') (cmpnt(i),atwt(i), i = 1, icmpn)
         write (n8,'(a,/)') 'end_components'

         if (lopt(7)) then 
            write (n8,'(a)') 'begin_special_components'
            do i = 1, ikind
               write (n8,'(a)') cmpnt(id(i))
            end do 
            write (n8,'(a,/)') 'end_special_components'
         end if  

      end if 
c                                 read and echo unformatted comments and make data                            
      do 

         read (n2,'(a)',iostat=ier) string
         if (ier.ne.0) call error (21,r,i,dname)
         read (string,'(a)') tag
         if (option.gt.3) write (n8,'(a)') string

         if (string.eq.'begin_makes') then
 
            call rmakes (option)

            cycle 

         else if (tag.ne.'end') then     

            cycle

         else 

            exit       

         end if

      end do  

1000  format (/,' | comments are indicated by the | character.',/,
     *     ' | check for warnings at the end of the header section.',/) 

      end 

      double precision function dnan()
c----------------------------------------------------------------------
c george helfrich's function to make a safe NaN
c----------------------------------------------------------------------
      implicit none 

      integer i4

      character c8(8)

      double precision val

      equivalence (c8,i4,val)
c----------------------------------------------------------------------
      i4 = 1

      if (ichar(c8(1)).eq.1) then
C                                 Little-endian
         c8(8)=char(127)
         c8(7)=char(248)
         c8(6)=char(0)
         c8(5)=char(0)
         c8(4)=char(0)
         c8(3)=char(0)
         c8(2)=char(0)
         c8(1)=char(0)

      else
C                                 Big-endian
         c8(1)=char(127)
         c8(2)=char(248)
         c8(3)=char(0)
         c8(4)=char(0)
         c8(5)=char(0)
         c8(6)=char(0)
         c8(7)=char(0)
         c8(8)=char(0)

      endif

      dnan = val

      end

      subroutine plblrb (typ)
c----------------------------------------------------------------------
c write a blurb on plotting options for the calculation
c
c type 1 - tab, ctr, table format
c type 2 - plt, psvdraw format
c type 3 - pts, pspts format
c type 4 - phm, phemgp table format
c----------------------------------------------------------------------
	implicit none

      integer typ
c----------------------------------------------------------------------

      if (typ.eq.1) then
c                                 2d - tab format
         write (*,1000) 
         write (*,1010)
      else if (typ.eq.2) then 
c                                 plt format
         write (*,1020)
      else if (typ.eq.3) then
c                                 pts format
         write (*,1030)
      else if (typ.eq.4) then 
c                                 1d - tab format
         write (*,1000) 
         write (*,1040)
      end if 

1000  format (/,'The tabulated data from this calculation can be ',
     *          'plotted with:',/)
1010  format (5x,'PSTABLE - a Perple_X plotting program',
     *      /,5x,'PYWERAMI - petrol.natur.cuni.cz/~ondro/pywerami:home',
     *      /,5x,'PERPLE_X_PLOT - a MATLAB plotting script',
     *      /,5x,'spread-sheet programs, e.g., EXCEL',//,
     *           'for details of the table format refer to:',/,
     *      /,5x,'perplex.ethz.ch/faq/Perple_X_tab_file_format.txt',/)
1020  format (/,'The output from this calculation can be plotted with ',
     *          'PSVDRAW',/)
1030  format (/,'The output from this calculation can be plotted with ',
     *          'PSPTS or converted to',/,'table/plot format with ',
     *          'PT2CURV',/)
1040  format (5x,'pstable - a Perple_X plotting program',
     *      /,5x,'perple_x_plot - a Matlab plotting script',
     *      /,5x,'spread-sheet programs, e.g., Excel',//,
     *          'for details of the table format refer to:',/,
     *      /,5x,'perplex.ethz.ch/faq/Perple_X_tab_file_format.txt',/)

      end

c-------------------------------------------------------------------
c text manipulation routines
c
c evntually all such rountines will be in one block or file, this is
c not the case now. 6/20/2011. 
c-------------------------------------------------------------------

      subroutine unblnk (text)
c------------------------------------------------------------------- 
c unblnk - subroutine to remove blanks from text
 
c     text - character string 
c     jchar - length of unblanked character string, 0 on input 
c             if unknown.
c-------------------------------------------------------------------
      implicit none

      integer i,ict,nchar

      character text*(*), bitsy(400)*1 

      nchar = len(text)
 
      read (text,'(400a)') (bitsy(i), i = 1, nchar)
c                                 scan for blanks:
      ict = 0

      do i = 1, nchar
         if (bitsy(i).eq.' ') cycle 
         ict = ict + 1
         bitsy(ict) = bitsy(i)
      end do 

      write (text,'(400a)') (bitsy(i), i = 1, ict)

      end

      subroutine enblnk (text)
c---------------------------------------------------------------------- 
c enblnk - scan text to first blank and cut remaining text.
 
c     text - character string 
c     jchar - length of unblanked character string, 0 on input 
c             if unknown.
c----------------------------------------------------------------------
      implicit none

      integer i,ict,nchar
 
      character text*(*), bitsy(400)*1 

      nchar = len(text) 
      read (text,'(400a)') (bitsy(i), i = 1, nchar)
c                                 scan for blanks:
      ict = 0

      do i = 1, nchar
         if (bitsy(i).eq.' ') exit
         ict = ict + 1
      end do 

      text = ' '
      write (text,'(400a)') (bitsy(i), i = 1, ict)

      end

      subroutine reblnk (text)
c------------------------------------------------------------------- 
c reblnk - subroutine to replace blanks followed by a character
c          with an underscore.
 
c     text - character string 
c     jchar - length of unblanked character string, 0 on input 
c             if unknown.
c----------------------------------------------------------------------
      implicit none 

      integer i,ict
 
      character*8 text, bitsy(8)*1 
 
      read (text,'(400a)') bitsy
c                                 scan for blanks:
      ict = 0

      do i = 1, 7

         if (i.eq.1.and.bitsy(i).eq.' ') cycle

         if (bitsy(i).eq.' '.and.bitsy(i+1).ne.' ') then
            ict = ict + 1
            bitsy(ict) = '_'
         else if (bitsy(i).eq.' ') then 
            cycle
         else
            ict = ict + 1
            bitsy(ict) = bitsy(i)
         end if

      end do 
 
      bitsy(ict+1) = bitsy(8)

      write (text,'(400a)') (bitsy(i), i = 1, ict + 1)

      end
